{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About Dasharo is open-source firmware distribution focusing on clean and simple code, long-term maintenance, transparent validation, privacy-respecting implementation, liberty for the owners, and trustworthiness for all. Dasharo consists of productized services, open-core, and SaaS products which help to provide scalable, modular, easy to combine open-source BIOS, UEFI, and firmware solutions. It offers the components that are needed to develop and maintain a high quality, and modular firmware, for the stability and security of your platform. Dasharo homepage Compatible hardware Asus KGPE-D16 NovaCustom NV4X NovaCustom NS5X TUXEDO InfinityBook S 15 Dell OptiPlex 7010/9010 PC Engines apu series Protectli Vault series Raptor Computing Systems Talos II MSI PRO Z690-A DDR4 WIFI Community Dasharo Matrix Workspace - general Dasharo discussion, support and other open-source firmware related work. Dasharo OSF vPub - 3-4 times a year we organize online party to discuss recent achievements in open-source firmware, open source hardware and open instruction set architecture. Feel free to check the website about recent vPub plans or subscribe to newsletter.","title":"Intro"},{"location":"#_1","text":"","title":""},{"location":"#about","text":"Dasharo is open-source firmware distribution focusing on clean and simple code, long-term maintenance, transparent validation, privacy-respecting implementation, liberty for the owners, and trustworthiness for all. Dasharo consists of productized services, open-core, and SaaS products which help to provide scalable, modular, easy to combine open-source BIOS, UEFI, and firmware solutions. It offers the components that are needed to develop and maintain a high quality, and modular firmware, for the stability and security of your platform. Dasharo homepage","title":"About"},{"location":"#compatible-hardware","text":"Asus KGPE-D16 NovaCustom NV4X NovaCustom NS5X TUXEDO InfinityBook S 15 Dell OptiPlex 7010/9010 PC Engines apu series Protectli Vault series Raptor Computing Systems Talos II MSI PRO Z690-A DDR4 WIFI","title":"Compatible hardware"},{"location":"#community","text":"Dasharo Matrix Workspace - general Dasharo discussion, support and other open-source firmware related work. Dasharo OSF vPub - 3-4 times a year we organize online party to discuss recent achievements in open-source firmware, open source hardware and open instruction set architecture. Feel free to check the website about recent vPub plans or subscribe to newsletter.","title":"Community"},{"location":"glossary/","text":"Glossary After years of providing services and products on firmware market we recognize that it is poisoned by incorrect and confusing terminology. In following glossary we would like to explain most used terms from Dasharo Documentation. We try to refer to standards, literature and community best practices to keep content added by us minimalistic. Embedded Firmware We use definition explained in first chapter of \"Embedded Firmware Solutions\" book by Jiming Sun, Marc Jones, Stefan Reinauer and Vincent Zimmer. Firmware is \"layer of software between the hardware and the operating system (OS), with the main purpose to initialize and abstract enough hardware so that the operating systems and their drivers can further configure the hardware to its full functionality.\" Rising complexity of hardware initialization and need for its manageability created need for BMC (Board Management Controllers), EC (Environmental Controllers) and even more specialized one like USB Power Delivery firmware. What may make that firmware also covered by above definition.","title":"Glossary"},{"location":"glossary/#glossary","text":"After years of providing services and products on firmware market we recognize that it is poisoned by incorrect and confusing terminology. In following glossary we would like to explain most used terms from Dasharo Documentation. We try to refer to standards, literature and community best practices to keep content added by us minimalistic.","title":"Glossary"},{"location":"glossary/#embedded-firmware","text":"We use definition explained in first chapter of \"Embedded Firmware Solutions\" book by Jiming Sun, Marc Jones, Stefan Reinauer and Vincent Zimmer. Firmware is \"layer of software between the hardware and the operating system (OS), with the main purpose to initialize and abstract enough hardware so that the operating systems and their drivers can further configure the hardware to its full functionality.\" Rising complexity of hardware initialization and need for its manageability created need for BMC (Board Management Controllers), EC (Environmental Controllers) and even more specialized one like USB Power Delivery firmware. What may make that firmware also covered by above definition.","title":"Embedded Firmware"},{"location":"ways-you-can-help-us/","text":"Ways you can help us Please consider the following methods to support us if you value what we are doing. Join Dasharo Matrix Community We have created Matrix Dasharo Space, an open-source online community, inviting you to join us. Matrix Dasharo Space is a place where you can find solutions to many problems, and if not - our community will gladly help you. We encourage you to troubleshoot your open-source firmware issues there. Here is invitation link . Inside you will find multiple rooms. The main discussion happens in \"Dasharo - General\". Join Dasharo open-source firmware vPub We encourage you to join us at our vPub parties, which we hold 3-4x / year in \"Dasharo OSF vPub.\" vPub is an alternative to live meeting for those who can't or don't want to meet live. It also served as salvation in times of COVID-19. Our goal is to have a platform for open-source firmware, open-source hardware, and open instruction set architectures discussion in a casual atmosphere. For more information please visit event website . Write a Google review Google reviews help us attract new customers that can sponsor open-source development and provide value to the community. Please follow Google review link . Follow us on social media Follow us on Twitter: Dasharo , 3mdeb Follow us on LinkedIn: 3mdeb Like us on Facebook: 3mdeb Join Reddit communities: Dasharo , 3mdeb Contribute through Github If you have a GitHub account, you can help us in multiple ways: Follow out organizations: Dasharo , 3mdeb Give a star to repositories you like Fork repositories you would like to contribute to Report issues, your test results, and feature ideas in dasharo-issues Donate money A donation of any amount motivates us because it means you care about our open-source firmware mission. It is straightforward if you don't have time for other contributions, and there are multiple options - feel free to choose one that works for you. PayPal Transferwise (aka Wise) Donations in USD TransferWise (ACH/ABA: 026073150) IBAN 8311535451 SWIFT: CMFGUS33 Donations in EUR TransferWise Europe SA IBAN: BE11 9672 7712 7548 SWIFT: TRWIBEB1XXX Bank wire Donations in USD 3mdeb Sp. z o.o IBAN: PL 87 1160 2202 0000 0005 1576 2206 SWIFT: BIGBPLPW Donations in EUR 3mdeb Sp. z o.o IBAN: PL 94 1160 2202 0000 0005 1576 1304 SWIFT: BIGBPLPW BTC and other crypto coins If you are concerned about the privacy of your donation as well as the fact how we would spend the money, then please consider Technology Commons Trust Open Firmware Fund . Addresses: Bitcoin: 1GUm6FF7Fon6Umrt5CSi3AxxYg8dM2NKvV PKT: pkt1qyv4gmnvvg2vfyj89e63thzj68jf2y9k7ssee7v If you want to contribute to other cryptocurrencies, please visit OFF website for details about contact information. We are pretty sure the Technology Commons Trust team will find the way. Can't see your option? Contact us contact@dasharo.com For OEM/ODM: Join the private-beta program We created Dasharo private beta program for OEM/ODM to improve quality and the efficiency of platform firmware development and deployment. Program benefits: Early access to the Dasharo roadmap reflects the most recent market trends and covers future hardware support and features. Early access to information about firmware development funding campaigns. Early access to source code and release binaries. Dasharo Tools Suite for seamless integration of value-added features. Dasharo Marketing Package helps explain the value that Dasharo brings to the product. Professional support at all stages of the product life cycle. Vertical market integration support. How to join? Please send us an email to contact@dasharo.com .","title":"Ways you can help us"},{"location":"ways-you-can-help-us/#ways-you-can-help-us","text":"Please consider the following methods to support us if you value what we are doing.","title":"Ways you can help us"},{"location":"ways-you-can-help-us/#join-dasharo-matrix-community","text":"We have created Matrix Dasharo Space, an open-source online community, inviting you to join us. Matrix Dasharo Space is a place where you can find solutions to many problems, and if not - our community will gladly help you. We encourage you to troubleshoot your open-source firmware issues there. Here is invitation link . Inside you will find multiple rooms. The main discussion happens in \"Dasharo - General\".","title":"Join Dasharo Matrix Community"},{"location":"ways-you-can-help-us/#join-dasharo-open-source-firmware-vpub","text":"We encourage you to join us at our vPub parties, which we hold 3-4x / year in \"Dasharo OSF vPub.\" vPub is an alternative to live meeting for those who can't or don't want to meet live. It also served as salvation in times of COVID-19. Our goal is to have a platform for open-source firmware, open-source hardware, and open instruction set architectures discussion in a casual atmosphere. For more information please visit event website .","title":"Join Dasharo open-source firmware vPub"},{"location":"ways-you-can-help-us/#write-a-google-review","text":"Google reviews help us attract new customers that can sponsor open-source development and provide value to the community. Please follow Google review link .","title":"Write a Google review"},{"location":"ways-you-can-help-us/#follow-us-on-social-media","text":"Follow us on Twitter: Dasharo , 3mdeb Follow us on LinkedIn: 3mdeb Like us on Facebook: 3mdeb Join Reddit communities: Dasharo , 3mdeb","title":"Follow us on social media"},{"location":"ways-you-can-help-us/#contribute-through-github","text":"If you have a GitHub account, you can help us in multiple ways: Follow out organizations: Dasharo , 3mdeb Give a star to repositories you like Fork repositories you would like to contribute to Report issues, your test results, and feature ideas in dasharo-issues","title":"Contribute through Github"},{"location":"ways-you-can-help-us/#donate-money","text":"A donation of any amount motivates us because it means you care about our open-source firmware mission. It is straightforward if you don't have time for other contributions, and there are multiple options - feel free to choose one that works for you.","title":"Donate money"},{"location":"ways-you-can-help-us/#for-oemodm-join-the-private-beta-program","text":"We created Dasharo private beta program for OEM/ODM to improve quality and the efficiency of platform firmware development and deployment. Program benefits: Early access to the Dasharo roadmap reflects the most recent market trends and covers future hardware support and features. Early access to information about firmware development funding campaigns. Early access to source code and release binaries. Dasharo Tools Suite for seamless integration of value-added features. Dasharo Marketing Package helps explain the value that Dasharo brings to the product. Professional support at all stages of the product life cycle. Vertical market integration support. How to join? Please send us an email to contact@dasharo.com .","title":"For OEM/ODM: Join the private-beta program"},{"location":"common-coreboot-docs/custom_logo/","text":"Boot logo replacement instructions Introduction The logo displayed at boot can be customized according to the client's preferences. For this, we have created a script that automates the process of replacing the logo. Prerequisites The image file must fulfill a number of requirements: Bitmap (BMP file) up to 577\u00d7432 resolution indexed or 24bit RGB colors uncompressed preferably containing a simple logo on a black background with no additional padding. Replace logo in an existing image For devices supporting persistent bootlogo, it's possible to replace the logo without rebuilding firmware from scratch. You only need the firmware image and cbfstool . Obtain cbfstool source code (skip if you've already cloned the coreboot source): git clone https://review.coreboot.org/coreboot.git Build and install cbfstool: cd coreboot/util/cbfstool make sudo make install Remove the existing logo from the firmware image (replace [path] with the path to your firmware binary): cbfstool [ path ] remove -r BOOTSPLASH -n logo.bmp Add your desired bootlogo to the firmware image (replace [path] with the path to your firmware image and [logo] with the path to the logo): cbfstool [ path ] add -f [ logo ] -r BOOTSPLASH -n logo.bmp -t raw -c lzma Now you can flash the updated firmware image as usual. If you're not updating firmware and just changing the logo, only the BOOTSPLASH region needs to be updated. For example: sudo flashrom -p internal --fmap -i BOOTSPLASH -w [ path ] Build image with custom logo Preparation: Follow the steps specified in the building instructions The script build.sh located in the coreboot directory can be used to replace the logo at build time. To replace the logo, run the following command: ./build.sh build -l path/to/logo.bmp The command will output an updated coreboot image into the directory artifacts .","title":"Logo customization"},{"location":"common-coreboot-docs/custom_logo/#boot-logo-replacement-instructions","text":"","title":"Boot logo replacement instructions"},{"location":"common-coreboot-docs/custom_logo/#introduction","text":"The logo displayed at boot can be customized according to the client's preferences. For this, we have created a script that automates the process of replacing the logo.","title":"Introduction"},{"location":"common-coreboot-docs/custom_logo/#prerequisites","text":"The image file must fulfill a number of requirements: Bitmap (BMP file) up to 577\u00d7432 resolution indexed or 24bit RGB colors uncompressed preferably containing a simple logo on a black background with no additional padding.","title":"Prerequisites"},{"location":"common-coreboot-docs/custom_logo/#replace-logo-in-an-existing-image","text":"For devices supporting persistent bootlogo, it's possible to replace the logo without rebuilding firmware from scratch. You only need the firmware image and cbfstool . Obtain cbfstool source code (skip if you've already cloned the coreboot source): git clone https://review.coreboot.org/coreboot.git Build and install cbfstool: cd coreboot/util/cbfstool make sudo make install Remove the existing logo from the firmware image (replace [path] with the path to your firmware binary): cbfstool [ path ] remove -r BOOTSPLASH -n logo.bmp Add your desired bootlogo to the firmware image (replace [path] with the path to your firmware image and [logo] with the path to the logo): cbfstool [ path ] add -f [ logo ] -r BOOTSPLASH -n logo.bmp -t raw -c lzma Now you can flash the updated firmware image as usual. If you're not updating firmware and just changing the logo, only the BOOTSPLASH region needs to be updated. For example: sudo flashrom -p internal --fmap -i BOOTSPLASH -w [ path ]","title":"Replace logo in an existing image"},{"location":"common-coreboot-docs/custom_logo/#build-image-with-custom-logo","text":"Preparation: Follow the steps specified in the building instructions The script build.sh located in the coreboot directory can be used to replace the logo at build time. To replace the logo, run the following command: ./build.sh build -l path/to/logo.bmp The command will output an updated coreboot image into the directory artifacts .","title":"Build image with custom logo"},{"location":"common-coreboot-docs/dasharo_tools_suite/","text":"Dasharo Tools Suite Introduction Dasharo Tools Suite (DTS) is a set of tools running in a minimal Linux environment, with a goal of deploying, updating and maintaining firmware on Dasharo supported devices. For example, it can be used to update the firmware on a device, even when no OS is currently installed. Distribution methods It can be distributed in various ways. Currently, there are two distribution options: bootable USB stick image. bootable over network (iPXE), Flavors There is a common base, but there might be multiple flavors of the DTS images. Currently, there are: CE - Community Edition Dasharo HCL Report - generates a package with logs containing hardware information flashrom, fwupd, and many more useful tools can drop to shell to update the firmware manually OEM on top of that, provides tools for automatic firmware deployment and rollback (switching to Dasharo back and forth) Bootable USB stick This documentation is compatible with the v0.3.0 version of the DTS. Requirements USB stick (at least 1GB) Wired network connection Secure Boot disabled DTS CE v0.3.0 downloaded Launching DTS Flash the downloaded dts-base-image-ce-v0.3.0.wic.gz image onto USB stick. you can use cross-platform GUI installer - Etcher you can also use dd to flash from command line gzip -cdk dts-base-image-ce-v0.3.0.wic.gz | sudo dd of = /dev/sdX bs = 16M status = progress conv = fdatasync Insert the USB stick to a USB in your device Boot from the USB stick Using DTS A menu should appear Enter 1 to dump logs with hardware from your device Bootable over network This documentation is compatible with the v0.1.0 version of the DTS. Requirements Dasharo device with DTS functionality integrated Wired network connection Secure Boot disabled Launching DTS To access Dasharo Tools Suite: Attach a wired network cable to the device's Ethernet port Power on the device, holding down the Boot Menu entry key In the Boot Menu, select the iPXE Network Boot option In the Network Boot menu, select the Dasharo Tools Suite option Login as root (no password) The DTS shell will now appear. Using DTS Within DTS, you may use the flashrom and fwupdmgr utilities to update, downgrade, or reinstall your firmware. To update your firmware to the latest version: fwupdmgr refresh fwupdmgr update","title":"Dasharo Tools Suite"},{"location":"common-coreboot-docs/dasharo_tools_suite/#dasharo-tools-suite","text":"","title":"Dasharo Tools Suite"},{"location":"common-coreboot-docs/dasharo_tools_suite/#introduction","text":"Dasharo Tools Suite (DTS) is a set of tools running in a minimal Linux environment, with a goal of deploying, updating and maintaining firmware on Dasharo supported devices. For example, it can be used to update the firmware on a device, even when no OS is currently installed.","title":"Introduction"},{"location":"common-coreboot-docs/dasharo_tools_suite/#distribution-methods","text":"It can be distributed in various ways. Currently, there are two distribution options: bootable USB stick image. bootable over network (iPXE),","title":"Distribution methods"},{"location":"common-coreboot-docs/dasharo_tools_suite/#flavors","text":"There is a common base, but there might be multiple flavors of the DTS images. Currently, there are: CE - Community Edition Dasharo HCL Report - generates a package with logs containing hardware information flashrom, fwupd, and many more useful tools can drop to shell to update the firmware manually OEM on top of that, provides tools for automatic firmware deployment and rollback (switching to Dasharo back and forth)","title":"Flavors"},{"location":"common-coreboot-docs/dasharo_tools_suite/#bootable-usb-stick","text":"This documentation is compatible with the v0.3.0 version of the DTS.","title":"Bootable USB stick"},{"location":"common-coreboot-docs/dasharo_tools_suite/#bootable-over-network","text":"This documentation is compatible with the v0.1.0 version of the DTS.","title":"Bootable over network"},{"location":"common-coreboot-docs/fwupd_usage/","text":"Updating firmware using fwupd This document describes the process of installing firmware updates from LVFS using fwupd. Installing fwupd Using binary packages Only .deb packages are provided. The procudure was verified on Ubuntu 20.04 LTS , but is should also apply to other Debian-based dsitributions. If you are using different distribution, you might need to build from source . Download and extract the fwupd archive: wget --content-disposition \\ https://cloud.3mdeb.com/index.php/s/mZyN4NgR8SngJ4j/download \\ https://cloud.3mdeb.com/index.php/s/Z765y233CdJGKy2/download \\ https://cloud.3mdeb.com/index.php/s/KkNaL6dbWs2ei3E/download unzip fwupd-novacustom-v1.2.0.zip This is an example how to verify the binaries (in this case fwupd-novacustom-v1.2.0.zip ): gpg --fetch-keys https://raw.githubusercontent.com/3mdeb/3mdeb-secpack/master/keys/master-key/3mdeb-master-key.asc gpg --fetch-keys https://raw.githubusercontent.com/3mdeb/3mdeb-secpack/oss_master_key/open-source-software/3mdeb-open-source-software-master-key.asc gpg --fetch-keys https://raw.githubusercontent.com/3mdeb/3mdeb-secpack/master/customer-keys/novacustom/novacustom-open-source-firmware-release-1.x-key.asc sha256sum -c fwupd-novacustom-v1.2.0.zip.sha256 gpg -v --verify fwupd-novacustom-v1.2.0.zip.sha256.sig fwupd-novacustom-v1.2.0.zip.sha256 flashrom packages are located inside flashrom-1.2-2-3mdeb.zip : unzip flashrom-1.2-2-3mdeb.zip sudo apt install ./flashrom_1.2-2_amd64.deb sudo apt install ./libflashrom1_1.2-2_amd64.deb fwupd packages are located inside fwupd-2.0.0.0-3mdeb.zip : unzip fwupd-2.0.0.0-3mdeb.zip sudo apt install ./fwupd_2.0.0_amd64.deb \\ ./fwupd-doc_2.0.0_all.deb \\ ./fwupd-tests_2.0.0_amd64.deb \\ ./gir1.2-fwupd-2.0_2.0.0_amd64.deb \\ ./gir1.2-fwupdplugin-1.0_2.0.0_amd64.deb \\ ./gir1.2-gusb-1.0_0.3.5-1_amd64.deb \\ ./libfwupd2_2.0.0_amd64.deb \\ ./libfwupd-dev_2.0.0_amd64.deb \\ ./libfwupdplugin4_2.0.0_amd64.deb \\ ./libfwupdplugin-dev_2.0.0_amd64.deb \\ ./libgusb2_0.3.5-1_amd64.deb \\ ./libgusb-dev_0.3.5-1_amd64.deb Building from source There is no need to do any of these steps unless you can't use the packages provided in the previous step You might need to adjust the package manager commands and package names to your distribution. Flashrom Install build dependencies: sudo apt update sudo apt install -y build-essential pciutils libpci-dev libusb-1.0-0-dev \\ cmake meson pkg-config libftdi1-dev debhelper git wget python3-markdown \\ gcab Obtain source code: git clone https://github.com/Dasharo/flashrom.git -b v1.2.0.1 cd flashrom Build and install flashrom: meson build ninja -C build sudo ninja -C build install fwupd Obtain source code: git clone https://github.com/Dasharo/fwupd.git -b v1.7.3.3 cd fwupd Install build dependencies: ./contrib/setup Build and install fwupd: sudo depmod meson build -Ddocs = none -Dplugin_flashrom = true ninja -C build sudo ninja -C build install Updating firmware from LVFS Disable Secure Boot. To do this you can follow steps described in Secure Boot test . Refresh the fwupd database: sudo fwupdmgr refresh Updating lvfs Downloading\u2026 [ *************************************** ] Downloading\u2026 [ *************************************** ] Successfully downloaded new metadata: 1 local device supported Use the following command to update firmware with fwupd - example for NV41MZ: Note: You may be asked which device to update. If you see a prompt, select NV4XMB,ME,MZ sudo fwupdmgr update Selected device: NV4XMB,ME,MZ \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 Update NV4XMB,ME,MZ to 0 .5.0? \u2551 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2551 This release adds the following features: \u2551 \u2551 \u2551 \u2551 \u2022 vboot Verified Boot \u2551 \u2551 \u2022 TPM Measured Boot \u2551 \u2551 \u2022 Custom fan curve \u2551 \u2551 \u2022 Microcode for Tiger Lake stepping 0x2 \u2551 \u2551 \u2551 \u2551 This release changes the following features: \u2551 \u2551 \u2551 \u2551 \u2022 Disabled unused DPTF device \u2551 \u2551 \u2551 \u2551 NV4XMB,ME,MZ and all connected devices may not be usable while updating. \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d Perform operation? [ Y | n ] : Downloading\u2026 [ *************************************** ] Downloading\u2026 [ *************************************** ] Decompressing\u2026 [ *************************************** ] Decompressing\u2026 [ *************************************** ] Authenticating\u2026 [ *************************************** ] Authenticating\u2026 [ *************************************** ] Restarting device\u2026 [ *************************************** ] Writing\u2026 [ *************************************** ] Decompressing\u2026 [ *************************************** ] Writing\u2026 [ *************************************** ] Verifying\u2026 [ *************************************** ] Writing\u2026 [ *************************************** ] Restarting device\u2026 [ *************************************** ] Waiting\u2026 [ *************************************** ] Successfully installed firmware An update requires the system to shutdown to complete. Shutdown now? [ y | N ] : Shut down the computer when prompted, or manually later on. Power on the laptop again. Log in and run the following command to verify results: sudo fwupdmgr get-results Choose a device: 0 . Cancel 1 . 4bde70ba4e39b28f9eab1628f9dd6e6244c03027 ( 11th Gen Intel Core\u2122 i7-1165G7 @ 2 .80GHz ) 2 . 5792b48846ce271fab11c4a545f7a3df0d36e00a ( Display controller ) 3 . 073c01931cb0e9889bbfb2ea4a4c2fc558805fc6 ( Display controller ) 4 . dbee8bd3b1ae0316ad143336155651eedb495a0e ( NV4XMB,ME,MZ ) 5 . 71b677ca0f1bc2c5b804fa1d59e52064ce589293 ( SSD 980 PRO 1TB ) 6 . c6a80ac3a22083423992a3cb15018989f37834d6 ( TPM ) 7 . eefcbd318bd31fc1eba6358e628b3f9dceb87206 ( USB4 host controller ) Select NV4XMB,ME,MZ when prompted, and the results will be displayed: NV4XMB,ME,MZ: Device ID: dbee8bd3b1ae0316ad143336155651eedb495a0e Previous version: 0 .5.0 Update State: Success Last modified: 2022 -01-13 11 :09 GUID: 230c8b18-8d9b-53ec-838b-6cfc0383493a Device Flags: \u2022 Internal device \u2022 Updatable \u2022 System requires external power source \u2022 Needs shutdown after installation \u2022 Cryptographic hash verification is available","title":"Updating firmware using fwupd"},{"location":"common-coreboot-docs/fwupd_usage/#updating-firmware-using-fwupd","text":"This document describes the process of installing firmware updates from LVFS using fwupd.","title":"Updating firmware using fwupd"},{"location":"common-coreboot-docs/fwupd_usage/#installing-fwupd","text":"","title":"Installing fwupd"},{"location":"common-coreboot-docs/fwupd_usage/#updating-firmware-from-lvfs","text":"Disable Secure Boot. To do this you can follow steps described in Secure Boot test . Refresh the fwupd database: sudo fwupdmgr refresh Updating lvfs Downloading\u2026 [ *************************************** ] Downloading\u2026 [ *************************************** ] Successfully downloaded new metadata: 1 local device supported Use the following command to update firmware with fwupd - example for NV41MZ: Note: You may be asked which device to update. If you see a prompt, select NV4XMB,ME,MZ sudo fwupdmgr update Selected device: NV4XMB,ME,MZ \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 Update NV4XMB,ME,MZ to 0 .5.0? \u2551 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2551 This release adds the following features: \u2551 \u2551 \u2551 \u2551 \u2022 vboot Verified Boot \u2551 \u2551 \u2022 TPM Measured Boot \u2551 \u2551 \u2022 Custom fan curve \u2551 \u2551 \u2022 Microcode for Tiger Lake stepping 0x2 \u2551 \u2551 \u2551 \u2551 This release changes the following features: \u2551 \u2551 \u2551 \u2551 \u2022 Disabled unused DPTF device \u2551 \u2551 \u2551 \u2551 NV4XMB,ME,MZ and all connected devices may not be usable while updating. \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d Perform operation? [ Y | n ] : Downloading\u2026 [ *************************************** ] Downloading\u2026 [ *************************************** ] Decompressing\u2026 [ *************************************** ] Decompressing\u2026 [ *************************************** ] Authenticating\u2026 [ *************************************** ] Authenticating\u2026 [ *************************************** ] Restarting device\u2026 [ *************************************** ] Writing\u2026 [ *************************************** ] Decompressing\u2026 [ *************************************** ] Writing\u2026 [ *************************************** ] Verifying\u2026 [ *************************************** ] Writing\u2026 [ *************************************** ] Restarting device\u2026 [ *************************************** ] Waiting\u2026 [ *************************************** ] Successfully installed firmware An update requires the system to shutdown to complete. Shutdown now? [ y | N ] : Shut down the computer when prompted, or manually later on. Power on the laptop again. Log in and run the following command to verify results: sudo fwupdmgr get-results Choose a device: 0 . Cancel 1 . 4bde70ba4e39b28f9eab1628f9dd6e6244c03027 ( 11th Gen Intel Core\u2122 i7-1165G7 @ 2 .80GHz ) 2 . 5792b48846ce271fab11c4a545f7a3df0d36e00a ( Display controller ) 3 . 073c01931cb0e9889bbfb2ea4a4c2fc558805fc6 ( Display controller ) 4 . dbee8bd3b1ae0316ad143336155651eedb495a0e ( NV4XMB,ME,MZ ) 5 . 71b677ca0f1bc2c5b804fa1d59e52064ce589293 ( SSD 980 PRO 1TB ) 6 . c6a80ac3a22083423992a3cb15018989f37834d6 ( TPM ) 7 . eefcbd318bd31fc1eba6358e628b3f9dceb87206 ( USB4 host controller ) Select NV4XMB,ME,MZ when prompted, and the results will be displayed: NV4XMB,ME,MZ: Device ID: dbee8bd3b1ae0316ad143336155651eedb495a0e Previous version: 0 .5.0 Update State: Success Last modified: 2022 -01-13 11 :09 GUID: 230c8b18-8d9b-53ec-838b-6cfc0383493a Device Flags: \u2022 Internal device \u2022 Updatable \u2022 System requires external power source \u2022 Needs shutdown after installation \u2022 Cryptographic hash verification is available","title":"Updating firmware from LVFS"},{"location":"common-coreboot-docs/vboot_signing/","text":"coreboot vboot signing Introduction Verified Boot is a method of verifying that the firmware compents haven't been tampered with. It uses cryptographic signatures to determine whether the firmware comes from trusted source. This document covers the procedure for generating vboot keys and configuring the coreboot build system to sign the binaries with the generated keys. Prerequisites Navigate to the coreboot tree. Ensure submodules are up to date: git submodule update --init --checkout Install vboot libraries and modules on the host system: sudo make -C 3rdparty/vboot install Generating keys Generate the keys with the following command: ./3rdparty/vboot/scripts/keygeneration/create_new_keys.sh --output keys/ The keys will be created in the directory $PWD/keys , i.e. in the coreboot root directory in the keys subdirectory. If in doubt what parameters you should pass, add --help as a parameter to the script. Adding keys to the coreboot config In the root of the coreboot tree, execute the following command: make nconfig Navigate to Security -> Verified Boot (vboot) -> Vboot keys and enter the paths to the keys in the appropriate fields. Exit nconfig by pressing Esc repeatedly and pressing Enter when prompted to save the configuration. Now, rebuild coreboot with this config to generate images signed with the chosen vboot keys. Signing image without rebuilding Be sure you have generated the keys as in Generate keys section. Assuming you have generated keys to the keys/ directory: ./3rdparty/vboot/scripts/image_signing/sign_firmware.sh \\ ./build/coreboot.rom \\ keys/ \\ coreoot_signed.rom If in doubt what parameters you should pass, add --help as a parameter to the script. The successful output should look like this: No dev firmware keyblock/datakey found. Reusing normal keys. - import root_key from keys//root_key.vbpubk: success - import recovery_key from keys//recovery_key.vbpubk: success successfully saved new image to: coreoot_signed.rom Now the image will be signed with your own keys. Be sure to save the keys in a safe location, because you will need them to sign each firmware update. Otherwise, the firmware updates to RW partitions will not be executed by vboot.","title":"Vboot signing"},{"location":"common-coreboot-docs/vboot_signing/#coreboot-vboot-signing","text":"","title":"coreboot vboot signing"},{"location":"common-coreboot-docs/vboot_signing/#introduction","text":"Verified Boot is a method of verifying that the firmware compents haven't been tampered with. It uses cryptographic signatures to determine whether the firmware comes from trusted source. This document covers the procedure for generating vboot keys and configuring the coreboot build system to sign the binaries with the generated keys.","title":"Introduction"},{"location":"common-coreboot-docs/vboot_signing/#prerequisites","text":"Navigate to the coreboot tree. Ensure submodules are up to date: git submodule update --init --checkout Install vboot libraries and modules on the host system: sudo make -C 3rdparty/vboot install","title":"Prerequisites"},{"location":"common-coreboot-docs/vboot_signing/#generating-keys","text":"Generate the keys with the following command: ./3rdparty/vboot/scripts/keygeneration/create_new_keys.sh --output keys/ The keys will be created in the directory $PWD/keys , i.e. in the coreboot root directory in the keys subdirectory. If in doubt what parameters you should pass, add --help as a parameter to the script.","title":"Generating keys"},{"location":"common-coreboot-docs/vboot_signing/#adding-keys-to-the-coreboot-config","text":"In the root of the coreboot tree, execute the following command: make nconfig Navigate to Security -> Verified Boot (vboot) -> Vboot keys and enter the paths to the keys in the appropriate fields. Exit nconfig by pressing Esc repeatedly and pressing Enter when prompted to save the configuration. Now, rebuild coreboot with this config to generate images signed with the chosen vboot keys.","title":"Adding keys to the coreboot config"},{"location":"common-coreboot-docs/vboot_signing/#signing-image-without-rebuilding","text":"Be sure you have generated the keys as in Generate keys section. Assuming you have generated keys to the keys/ directory: ./3rdparty/vboot/scripts/image_signing/sign_firmware.sh \\ ./build/coreboot.rom \\ keys/ \\ coreoot_signed.rom If in doubt what parameters you should pass, add --help as a parameter to the script. The successful output should look like this: No dev firmware keyblock/datakey found. Reusing normal keys. - import root_key from keys//root_key.vbpubk: success - import recovery_key from keys//recovery_key.vbpubk: success successfully saved new image to: coreoot_signed.rom Now the image will be signed with your own keys. Be sure to save the keys in a safe location, because you will need them to sign each firmware update. Otherwise, the firmware updates to RW partitions will not be executed by vboot.","title":"Signing image without rebuilding"},{"location":"dasharo-menu-docs/overview/","text":"Dasharo menu overview This section describes the overview of the Dasharo firmware setup menu. In the subsections you will get to know: What options are available? How to use submenus and options? How the options and submenus work? Here you may watch a Dasharo menu walkthrough with commentary presenting Dasharo features. Dasharo menu guides This section is under construction and will contain guides for each Dasharo menu feature available in our products.","title":"Overview"},{"location":"dasharo-menu-docs/overview/#dasharo-menu-overview","text":"This section describes the overview of the Dasharo firmware setup menu. In the subsections you will get to know: What options are available? How to use submenus and options? How the options and submenus work? Here you may watch a Dasharo menu walkthrough with commentary presenting Dasharo features.","title":"Dasharo menu overview"},{"location":"dasharo-menu-docs/overview/#dasharo-menu-guides","text":"This section is under construction and will contain guides for each Dasharo menu feature available in our products.","title":"Dasharo menu guides"},{"location":"dev-env/nix-dev-env/","text":"Build system and development environment Docker containers considered harmful Nix as reproducible development environment","title":"Build system and development environment"},{"location":"dev-env/nix-dev-env/#build-system-and-development-environment","text":"","title":"Build system and development environment"},{"location":"dev-env/nix-dev-env/#docker-containers-considered-harmful","text":"","title":"Docker containers considered harmful"},{"location":"dev-env/nix-dev-env/#nix-as-reproducible-development-environment","text":"","title":"Nix as reproducible development environment"},{"location":"dev-proc/feature-bug-fix-dev-process/","text":"Features and bug fixes development We are in favor of Test Driven Bug Fixing methodology for which process looks as follows: Create automated test that validates feature or reproduces bug - test fails at this point Pull upstream master branch to Dasharo forked repository master branch Merge master to <platform>/develop Create new branch <platform>/<feature> from <platform>/develop Commit changes to <platform>/<feature> Run test written in point 1 and make sure it pass. Run <platform> regression test suite and make sure new feature does not introduce new bugs. Submit PR to <platform>/develop","title":"Features and bug fixes development process"},{"location":"dev-proc/feature-bug-fix-dev-process/#features-and-bug-fixes-development","text":"We are in favor of Test Driven Bug Fixing methodology for which process looks as follows: Create automated test that validates feature or reproduces bug - test fails at this point Pull upstream master branch to Dasharo forked repository master branch Merge master to <platform>/develop Create new branch <platform>/<feature> from <platform>/develop Commit changes to <platform>/<feature> Run test written in point 1 and make sure it pass. Run <platform> regression test suite and make sure new feature does not introduce new bugs. Submit PR to <platform>/develop","title":"Features and bug fixes development"},{"location":"dev-proc/smbios-rules/","text":"Dasharo Product Guidelines: SMBIOS Information Introduction This document describes the guidelines for filling in the SMBIOS fields in devices supported by Dasharo. It is meant to be used primarily as a reference for Dasharo developers. BIOS Information (Type 0) Vendor field The Vendor field, for firmware with release date after 13 January 2022, is set as follows: 3mdeb For firmware with release date before 13 January 2022: 3mdeb Embedded Systems Consulting BIOS Version field The BIOS Version string is defined as follows: Dasharo ([ major_framework ] + [ minor_framework ]) v [ version ] major_framework refers to the primary framework in which the firmware is developed, e.g. coreboot or UEFI . minor_framework is the secondary framework, a supporting component for the primary framework, e.g. a coreboot payload. May not always be used, e.g. if edk2 is used as the primary framework. version means version according to official Dasharo Versioning documentation. For TianoCore UEFIPayloadPkg , we use the simpler and more recognizable UEFI name. Examples: Dasharo (coreboot+UEFI) v1.0.0 - for coreboot-based builds with TianoCore UEFIPayload Dasharo (coreboot+SeaBIOS) v1.0.0 - for coreboot-based builds with SeaBIOS payload Dasharo (coreboot+Heads) v1.0.0 - for coreboot-based builds with Heads payload Dasharo (UEFI) v1.0.0 - for plain edk2-based builds System Information (Type 1) Devices with an existing BIOS implementation In this case, set all the fields that are relevant (excluding BIOS version and vendor) to the same values as the stock firmware. To obtain SMBIOS values from the stock firmware, either: Obtain the fwdump-docker logs from 3mdeb cloud Run dmidecode -t 1 on the machine itself Devices with no existing BIOS implementation In the case where the device does not have an existing supported BIOS or the client chooses to use different SMBIOS fields (e.g. to make it easier to differentiate devices), refer to the SMBIOS specification v3.5.0 .","title":"Dasharo Product Guidelines: SMBIOS Information"},{"location":"dev-proc/smbios-rules/#dasharo-product-guidelines-smbios-information","text":"","title":"Dasharo Product Guidelines: SMBIOS Information"},{"location":"dev-proc/smbios-rules/#introduction","text":"This document describes the guidelines for filling in the SMBIOS fields in devices supported by Dasharo. It is meant to be used primarily as a reference for Dasharo developers.","title":"Introduction"},{"location":"dev-proc/smbios-rules/#bios-information-type-0","text":"","title":"BIOS Information (Type 0)"},{"location":"dev-proc/smbios-rules/#system-information-type-1","text":"","title":"System Information (Type 1)"},{"location":"dev-proc/source-code-structure/","text":"Source code structure Every repository forked and maintained by Dasharo Release Team has following branch structure: master - follows upstream project master branch <platform>/release - contains all code releases for given <platform> , list of supported platforms is in Hardware Compatibility List section <platform>/rel_vX.Y.Z - release branch for version X.Y.Z <platform>/develop - contains most recent development and is periodically synced with master branch <platform>/<feature> - tracks development of platform specific feature <platform> = <coreboot_mainboard_vendor>_<coreboot_mainboard_model> if platform is supported by coreboot, otherwise we use common sense and available information about hardware. Remotes It is assumed that upstream repository is cloned and remote named dasharo is added later. This has to be done in order to pull git submodules from upstream repository so they don't have to be kept on Dasharo's repository. This can be done like this: git clone https://review.coreboot.org/coreboot.git cd coreboot git submodule update --init --checkout git remote add dasharo git@github.com:Dasharo/coreboot.git If everything was done properly, this is expected state of remotes: git remote -v dasharo git@github.com:Dasharo/coreboot.git ( fetch ) dasharo git@github.com:Dasharo/coreboot.git ( push ) origin https://review.coreboot.org/coreboot.git ( fetch ) origin https://review.coreboot.org/coreboot.git ( push ) Tags Dasharo Release tags in git repository use format: <platform>_vX.Y.Z New platform support Branch for new platform should be created from most recent master branch tag. If there is justified need to create support for new board at arbitrary non-tagged commit developer should mark this commit with <platform>_v0.0.0 tag. Force-pushes rules Force-pushes to <platform>/rel_vX.Y.Z , <platform>/develop or <platform>/<feature> are forbidden with following exceptions: * rebasing - when some other PR is merged to target branch before our does, or when upstream's master introduces the same fixes that our branch would * squashing - to not produce unnecessary \"fix indentation\" or \"add missing braces\" commits to the history * (re-)signing commits (both -S and -s) - shouldn't happen, but if it does happen it would be better to have it fixed by original author than the person that tries to upstream it some time later. Force-pushes to <platform>/release branches are unconditionally forbidden. Merging guidelines We want to keep the history linear. The rebase merging strategy is desired. Merge commits in the code repositories are not allowed. The rebase strategy should be the only one available in the GitHub web UI. It is, however, strongly advised not to use GitHub web UI to perform code merges. The signed-off tends to be dropped (even when using the rebase strategy), which is problematic for some projects (e.g. it makes the coreboot lint checks fail after merging from the UI). The procedure of merging is as follows: Review the code in GitHub. Make sure to receive at least one Approve in the review process. Make sure that all change requests are resolved. Merge the branch using git CLI. In case of merging the feature branch into develop branch it may look as follows: git fetch dasharo git checkout dasharo/<platform>/develop -b <platform>/develop git merge --ff-only dasharo/<platform>/<feature> git push dasharo <platform>/develop This should automatically trigger closing the MR in the GitHub web UI. The remote branch can be safely deleted after this process. git push dasharo --delete <platform>/<feature> Note that the merging may fail if the source (in this case: feature ) branch is not properly rebased on top of the target (in this case: develop ) branch. In such a case, one must rebase the source branch first: git checkout dasharo/<platform>/<feature> git checkout -b <platform>/<feature> git rebase dasharo/<platform>/<develop> git push -f dasharo <platform>/<feature>","title":"Source code structure"},{"location":"dev-proc/source-code-structure/#source-code-structure","text":"Every repository forked and maintained by Dasharo Release Team has following branch structure: master - follows upstream project master branch <platform>/release - contains all code releases for given <platform> , list of supported platforms is in Hardware Compatibility List section <platform>/rel_vX.Y.Z - release branch for version X.Y.Z <platform>/develop - contains most recent development and is periodically synced with master branch <platform>/<feature> - tracks development of platform specific feature <platform> = <coreboot_mainboard_vendor>_<coreboot_mainboard_model> if platform is supported by coreboot, otherwise we use common sense and available information about hardware.","title":"Source code structure"},{"location":"dev-proc/source-code-structure/#remotes","text":"It is assumed that upstream repository is cloned and remote named dasharo is added later. This has to be done in order to pull git submodules from upstream repository so they don't have to be kept on Dasharo's repository. This can be done like this: git clone https://review.coreboot.org/coreboot.git cd coreboot git submodule update --init --checkout git remote add dasharo git@github.com:Dasharo/coreboot.git If everything was done properly, this is expected state of remotes: git remote -v dasharo git@github.com:Dasharo/coreboot.git ( fetch ) dasharo git@github.com:Dasharo/coreboot.git ( push ) origin https://review.coreboot.org/coreboot.git ( fetch ) origin https://review.coreboot.org/coreboot.git ( push )","title":"Remotes"},{"location":"dev-proc/source-code-structure/#tags","text":"Dasharo Release tags in git repository use format: <platform>_vX.Y.Z","title":"Tags"},{"location":"dev-proc/source-code-structure/#new-platform-support","text":"Branch for new platform should be created from most recent master branch tag. If there is justified need to create support for new board at arbitrary non-tagged commit developer should mark this commit with <platform>_v0.0.0 tag.","title":"New platform support"},{"location":"dev-proc/source-code-structure/#force-pushes-rules","text":"Force-pushes to <platform>/rel_vX.Y.Z , <platform>/develop or <platform>/<feature> are forbidden with following exceptions: * rebasing - when some other PR is merged to target branch before our does, or when upstream's master introduces the same fixes that our branch would * squashing - to not produce unnecessary \"fix indentation\" or \"add missing braces\" commits to the history * (re-)signing commits (both -S and -s) - shouldn't happen, but if it does happen it would be better to have it fixed by original author than the person that tries to upstream it some time later. Force-pushes to <platform>/release branches are unconditionally forbidden.","title":"Force-pushes rules"},{"location":"dev-proc/source-code-structure/#merging-guidelines","text":"We want to keep the history linear. The rebase merging strategy is desired. Merge commits in the code repositories are not allowed. The rebase strategy should be the only one available in the GitHub web UI. It is, however, strongly advised not to use GitHub web UI to perform code merges. The signed-off tends to be dropped (even when using the rebase strategy), which is problematic for some projects (e.g. it makes the coreboot lint checks fail after merging from the UI). The procedure of merging is as follows: Review the code in GitHub. Make sure to receive at least one Approve in the review process. Make sure that all change requests are resolved. Merge the branch using git CLI. In case of merging the feature branch into develop branch it may look as follows: git fetch dasharo git checkout dasharo/<platform>/develop -b <platform>/develop git merge --ff-only dasharo/<platform>/<feature> git push dasharo <platform>/develop This should automatically trigger closing the MR in the GitHub web UI. The remote branch can be safely deleted after this process. git push dasharo --delete <platform>/<feature> Note that the merging may fail if the source (in this case: feature ) branch is not properly rebased on top of the target (in this case: develop ) branch. In such a case, one must rebase the source branch first: git checkout dasharo/<platform>/<feature> git checkout -b <platform>/<feature> git rebase dasharo/<platform>/<develop> git push -f dasharo <platform>/<feature>","title":"Merging guidelines"},{"location":"dev-proc/standard-release-process/","text":"Standard Release Process Following procedure is generic description of release process of firmware for supported hardware platforms. Precise steps and any difference from standard process are described in platform specific documentation. Description here is, intentionally, Open Source Firmware framework agnostics and should be maintained in that way. Process steps Checkout new branch <platform>/rel_vX.Y.Z from recent commit on <platfrom>/release - to understand versioning scheme please read Versioning section Merge current <platform>/develop to <platform>/rel_vX.Y.Z Run platform regression test suite Fix all required issues and repeat point 3 until fixed - this doesn't mean all tests pass, this mean that approved set passed If results are accepted merge it to <platform>/release branch Add tag, which should trigger CI and publish binaries Merge release branch to develop","title":"Standard Release Process"},{"location":"dev-proc/standard-release-process/#standard-release-process","text":"Following procedure is generic description of release process of firmware for supported hardware platforms. Precise steps and any difference from standard process are described in platform specific documentation. Description here is, intentionally, Open Source Firmware framework agnostics and should be maintained in that way.","title":"Standard Release Process"},{"location":"dev-proc/standard-release-process/#process-steps","text":"Checkout new branch <platform>/rel_vX.Y.Z from recent commit on <platfrom>/release - to understand versioning scheme please read Versioning section Merge current <platform>/develop to <platform>/rel_vX.Y.Z Run platform regression test suite Fix all required issues and repeat point 3 until fixed - this doesn't mean all tests pass, this mean that approved set passed If results are accepted merge it to <platform>/release branch Add tag, which should trigger CI and publish binaries Merge release branch to develop","title":"Process steps"},{"location":"dev-proc/versioning/","text":"Versioning Dasharo Releases are versioned using Semantic Versioning and Keep A Changelog to document changes introduced in new releases. Major version zero (0.y.z) is for initial development and may not support all Dasharo Quality Criteria. The only way to map Dasharo Version to version of Open Source Firmware framework or other components included in Dasharo Release is through release notes. Link to Dasharo Release Notes for your hardware platform can be found in Hardware Compatibility List section. Signing keys In Dasharo we use following rules for keys: GPG RSA 4096 for signing and authentication and subkey for encryption There few types of naming conventions, which define Real Name field and chain of trust schemes: Software: Real Name: <name> open-source software relase <version> signing key Signing key: 3mdeb Open Source Software Master Key <contact@3mdeb.com> Firmware: Real Name: <name> open-source firmware relase <version> signing key Signing key: 3mdeb Dasharo Master Key PC Engines (firmware exception): Real Name: PC Engines open-source firmware relase <version> signing key Signing key: 3mdeb Open Source Firmware Master Key <contact@3mdeb.com> Dasharo firmware produced by 3mdeb: Real Name: Dasharo release <version> compatible with <name> signing key Signing key: 3mdeb Dasharo Master Key For Dasharo firmware produced by 3mdeb on customer's behalf: Real Name: Dasharo open-source firmware <version> for <name> signing key Signing key: 3mdeb Dasharo Master Key <name> typically is in form <vendor> <model> or just <vendor> if we release firmware for whole line of products which can be support in one binary e.g. PC Engines. Examples: Dell OptiPlex 7010/9010 ASUS KGPE-D16 MSI MS7D25 NovaCustom Tuxedo Most recent status should be reflected in 3mdeb-secpack repository.","title":"Versioning"},{"location":"dev-proc/versioning/#versioning","text":"Dasharo Releases are versioned using Semantic Versioning and Keep A Changelog to document changes introduced in new releases. Major version zero (0.y.z) is for initial development and may not support all Dasharo Quality Criteria. The only way to map Dasharo Version to version of Open Source Firmware framework or other components included in Dasharo Release is through release notes. Link to Dasharo Release Notes for your hardware platform can be found in Hardware Compatibility List section.","title":"Versioning"},{"location":"dev-proc/versioning/#signing-keys","text":"In Dasharo we use following rules for keys: GPG RSA 4096 for signing and authentication and subkey for encryption There few types of naming conventions, which define Real Name field and chain of trust schemes: Software: Real Name: <name> open-source software relase <version> signing key Signing key: 3mdeb Open Source Software Master Key <contact@3mdeb.com> Firmware: Real Name: <name> open-source firmware relase <version> signing key Signing key: 3mdeb Dasharo Master Key PC Engines (firmware exception): Real Name: PC Engines open-source firmware relase <version> signing key Signing key: 3mdeb Open Source Firmware Master Key <contact@3mdeb.com> Dasharo firmware produced by 3mdeb: Real Name: Dasharo release <version> compatible with <name> signing key Signing key: 3mdeb Dasharo Master Key For Dasharo firmware produced by 3mdeb on customer's behalf: Real Name: Dasharo open-source firmware <version> for <name> signing key Signing key: 3mdeb Dasharo Master Key <name> typically is in form <vendor> <model> or just <vendor> if we release firmware for whole line of products which can be support in one binary e.g. PC Engines. Examples: Dell OptiPlex 7010/9010 ASUS KGPE-D16 MSI MS7D25 NovaCustom Tuxedo Most recent status should be reflected in 3mdeb-secpack repository.","title":"Signing keys"},{"location":"ecosystem/attestation-server/","text":"","title":"Attestation server"},{"location":"ecosystem/customer-infrastructure/","text":"","title":"Customer infrastructure"},{"location":"ecosystem/deployment-and-provisioning-server/","text":"","title":"Deployment and provisioning server"},{"location":"ecosystem/dev/","text":"","title":"Dev"},{"location":"ecosystem/end-user/","text":"","title":"End user"},{"location":"ecosystem/hardware-infrastructure/","text":"","title":"Hardware infrastructure"},{"location":"ecosystem/osf-community/","text":"","title":"Osf community"},{"location":"ecosystem/overview/","text":"Ecosystem Overview Dasharo ecosystem contain multiple components on various levels of organization. This section overview role of every component. Open Source Firmware Community - semi-organised collections of contributors to projects related to embedded firmware. Dasharo project contributors are part of OSF community. Development - Dasharo Development describes processes which Embedded Firmware Team uses for the development of Dasharo Modules, which are sometimes custom services, but most of the time ready to use productised services, Open Core or SaaS. Production - Dasharo Production describes the process of putting together Dasharo Modules according to specific requirements. In this section we describe development infrastructure, build environment, CI/CD and build publishing methods. We also cover how production interacts with Dasharo Transparent Validation System. Customer Infrastructure - Some customers may have the need of replicating part of Dasharo Production process and infrastructure in their own environment, which leads to repositories synchronization, different CI/CD setup and other needs. This section describes interaction with Customer Infrastructure and which part of Dasharo Production is deployable on the customer site. Transparent Validation - Dasharo Transparent Validation (DTV) is a set of software, firmware and hardware components with the goal of simplifying and improving long term maintenance of Dasharo firmware. In this section we introduce components which belong to DTV. Testing Infrastructure - Part of Dasharo Transparent Validation responsible for scheduling automated testing, publishing test results and interacting with Dasharo Production in the area of release candidate quality confirmation.","title":"Overview"},{"location":"ecosystem/overview/#ecosystem-overview","text":"Dasharo ecosystem contain multiple components on various levels of organization. This section overview role of every component. Open Source Firmware Community - semi-organised collections of contributors to projects related to embedded firmware. Dasharo project contributors are part of OSF community. Development - Dasharo Development describes processes which Embedded Firmware Team uses for the development of Dasharo Modules, which are sometimes custom services, but most of the time ready to use productised services, Open Core or SaaS. Production - Dasharo Production describes the process of putting together Dasharo Modules according to specific requirements. In this section we describe development infrastructure, build environment, CI/CD and build publishing methods. We also cover how production interacts with Dasharo Transparent Validation System. Customer Infrastructure - Some customers may have the need of replicating part of Dasharo Production process and infrastructure in their own environment, which leads to repositories synchronization, different CI/CD setup and other needs. This section describes interaction with Customer Infrastructure and which part of Dasharo Production is deployable on the customer site. Transparent Validation - Dasharo Transparent Validation (DTV) is a set of software, firmware and hardware components with the goal of simplifying and improving long term maintenance of Dasharo firmware. In this section we introduce components which belong to DTV. Testing Infrastructure - Part of Dasharo Transparent Validation responsible for scheduling automated testing, publishing test results and interacting with Dasharo Production in the area of release candidate quality confirmation.","title":"Ecosystem Overview"},{"location":"ecosystem/prod/","text":"","title":"Prod"},{"location":"ecosystem/publishing-server/","text":"","title":"Publishing server"},{"location":"ecosystem/reference-os/","text":"","title":"Reference os"},{"location":"ecosystem/roadmap/","text":"Roadmap Each features on below roadmap should be placed in public issue tracker, so it can be publicly referenced. Some places where issues can be discussed: Dasharo Github issues repo especially issues tagged enhancement . coreboot issues tracker edk2 bugzilla Backlog TrenchBoot Roadmap firmware related issues. Dasharo Reference OS on USB stick to simplify firmware deployment fwupd/LVFS for firmware deployment ipxe for firmware deployment","title":"Roadmap"},{"location":"ecosystem/roadmap/#roadmap","text":"Each features on below roadmap should be placed in public issue tracker, so it can be publicly referenced. Some places where issues can be discussed: Dasharo Github issues repo especially issues tagged enhancement . coreboot issues tracker edk2 bugzilla","title":"Roadmap"},{"location":"ecosystem/roadmap/#backlog","text":"TrenchBoot Roadmap firmware related issues. Dasharo Reference OS on USB stick to simplify firmware deployment fwupd/LVFS for firmware deployment ipxe for firmware deployment","title":"Backlog"},{"location":"ecosystem/secure-storage/","text":"","title":"Secure storage"},{"location":"ecosystem/signing-server/","text":"","title":"Signing server"},{"location":"ecosystem/testing-infrastructure/","text":"","title":"Testing infrastructure"},{"location":"ecosystem/transparent-validation/","text":"","title":"Transparent validation"},{"location":"inquiries/commercial-inquiries/","text":"Commercial inquiries If you have any questions about our services, feel free to contact us using Dasharo contact form or 3mdeb contact form , or book a call with us .","title":"Commercial inquiries"},{"location":"inquiries/commercial-inquiries/#commercial-inquiries","text":"If you have any questions about our services, feel free to contact us using Dasharo contact form or 3mdeb contact form , or book a call with us .","title":"Commercial inquiries"},{"location":"inquiries/community-edition/","text":"Community edition TBD: precise terms how community edition support could be developed","title":"Community edition"},{"location":"inquiries/community-edition/#community-edition","text":"TBD: precise terms how community edition support could be developed","title":"Community edition"},{"location":"inquiries/overview/","text":"Overview There are multiple ways you can work with us: depending on your needs, we can drive community edition firmware releases, organize sponsorware project or simply develop precisely what you need in scope of commercial project.","title":"Overview"},{"location":"inquiries/overview/#overview","text":"There are multiple ways you can work with us: depending on your needs, we can drive community edition firmware releases, organize sponsorware project or simply develop precisely what you need in scope of commercial project.","title":"Overview"},{"location":"inquiries/sponsorware/","text":"Sponsorware TBD: Write contact inspired by the: mkdocs insiders page","title":"Sponsorware"},{"location":"inquiries/sponsorware/#sponsorware","text":"TBD: Write contact inspired by the: mkdocs insiders page","title":"Sponsorware"},{"location":"osf-trivia-list/deployment/","text":"Deployment Deployment section of Dasharo Knowledge Base FAQ considers topic of open-source firmware deployment, which may include operations of reading and writing SPI NOR flash, as well as binary modifications. If you can't find the answer to your questions feel free to contact us through Community Channels or submit issue through Dasharo Github . Flashrom Following sections explain how to deal with most common flashrom errors. Could not get I/O privileges (Operation not permitted) If you see a flashrom error like this: ERROR: Could not get I/O privileges (Operation not permitted). You need to be root. Error: Programmer initialization failed. It means you have insufficient privileges to perform initialization. Please use sudo before flashrom command. /dev/mem mmap failed: Operation not permitted /dev/mem mmap failed: Operation not permitted FAILED! FATAL ERROR! Error: Programmer initialization failed. Linux kernel restricts access to IOMEM. To fix that add iomem=relaxed to the kernel command line. Recommended way to fix the problem: Edit /etc/default/grub : GRUB_CMDLINE_LINUX = \"iomem=relaxed\" Update GRUB2 config with: sudo update-grub2 Alternatively, if previous command doesn't work: sudo grub-mkconfig -o /boot/grub/grub.cfg Reboot and try flashrom command again Other method: Edit grub.cfg in /boot/grub/ : linux /boot/vmlinuz-4.15.0-115-generic ro quiet iomem = relaxed Reboot and try flashrom command again Last resort you can try to modify boot option runtime. YMMV: If your computer uses BIOS for booting, then hold down the Shift , or if your computer uses UEFI for booting, press Esc several times, while GRUB is loading to get the boot menu. And, after getting a GRUB menu, press E on a boot entry to append iomem=relaxed to kernel command line and press Ctrl + X or F10 to boot. Although this setting is temporary and will last only during the next boot, this way is faster and a customer doesn't need to re-generate anything. Please note having it as a temporary setting maybe is slightly better for security (there's a reason why it's disabled by default) . If the above does not resolve the problem, the kernel may be compiled with strict devmem, which prohibits accessing the IOMEM. You should then take different Linux system. Transaction error between offset ... ? SPI Configuration is locked down. FREG0: Flash Descriptor region (0x00000000-0x00000fff) is read-only. FREG2: Management Engine region (0x00005000-0x005fffff) is locked. Not all flash regions are freely accessible by flashrom. This is most likely due to an active ME. Please see https://flashrom.org/ME for details. At least some flash regions are read protected. You have to use a flash layout and include only accessible regions. For write operations, you'll additionally need the --noverify-all switch. See manpage for more details. Enabling hardware sequencing due to multiple flash chips detected. OK. Found Programmer flash chip \"Opaque flash chip\" (12288 kB, Programmer-specific) mapped at physical address 0x0000000000000000. Reading flash... Transaction error between offset 0x00005000 and 0x0000503f (= 0x00005000 + 63)! Read operation failed! FAILED. Most probably it means problem lays in ME not allowing to read its region. One of the method to mitigate the issues is to put ME in Manufacturing Mode. Such operation depends on ME version, SPI flash layout and platform design. Detail information you should find in sections dedicated to given hardware. To access documentation for supported hardware please go to Hardware Compatibility List . Please note we consider further mitigations in Dasharo Roadmap .","title":"Deployment"},{"location":"osf-trivia-list/deployment/#deployment","text":"Deployment section of Dasharo Knowledge Base FAQ considers topic of open-source firmware deployment, which may include operations of reading and writing SPI NOR flash, as well as binary modifications. If you can't find the answer to your questions feel free to contact us through Community Channels or submit issue through Dasharo Github .","title":"Deployment"},{"location":"osf-trivia-list/deployment/#flashrom","text":"Following sections explain how to deal with most common flashrom errors.","title":"Flashrom"},{"location":"osf-trivia-list/introduction/","text":"Open Source Firmware Trivia Questions List (OSFTQL) Goal of following questions list is to provide answers to terribly trivial topics or questions that were asked and answered gazillion times. We believe to move forward with so limited resources we have to stop wasting community precious time on something we agree on, but move forward with discussion. Other role of this list is to create taxonomy of OSF trivia questions for community and Dasharo customers, to avoid repeating explanation of topics which most of community already agree on.","title":"Introduction"},{"location":"osf-trivia-list/introduction/#open-source-firmware-trivia-questions-list-osftql","text":"Goal of following questions list is to provide answers to terribly trivial topics or questions that were asked and answered gazillion times. We believe to move forward with so limited resources we have to stop wasting community precious time on something we agree on, but move forward with discussion. Other role of this list is to create taxonomy of OSF trivia questions for community and Dasharo customers, to avoid repeating explanation of topics which most of community already agree on.","title":"Open Source Firmware Trivia Questions List (OSFTQL)"},{"location":"osf-trivia-list/me/","text":"Introduction Until Nehalem (ME version 6) it was possible to remove ME firmware completely. Starting with Nehalem, ME firmware can't be completely removed. If ME firmware is missing, the PC will not boot at all Earlier ME versions left a 30 minute grace period for recovering from a bad flash, but this is no longer true Three methods to reduce ME's capabilities have been found: neutering , disabling and soft-disabling . Removing non-essential portions of the ME's firmware is commonly referred to as neutering ME Setting a bit in the Flash Descriptor which acts as a kill-switch which tells ME to hang after initialization is usually what we mean by disabling ME Neutering ME Neutralizing ME: removing non-essential portions of the ME's firmware Also called \"neutering\" Not initially designed by Intel Method discovered by Nicola Corna of the me_cleaner project Removes all modules other than those required for platform init Modules left in ME 6.0 - 10.x: ROMP , BUP Modules left in ME >= 11.x: rbe , kernel , syslib , bup , sometimes also mfs A neutered ME will initialize hardware, then throw an error due to missing firmware This sometimes results in power management issues Therefore it's not recommended in production without extensive testing Functions provided by ME will no longer be operational ME >= v11.x: Sometimes mfs also needs to be preserved. mfs is responsible for some of the hardware initialization. Soft-disabling ME It's also possible to put ME into a soft-disabled state by sending a HECI SET_ME_DISABLE or HMRFPO_ENABLE message BIOS needs to send these messages ME will stay disabled until a corresponding ENABLE message is sent Functional ME firmware must be present Usually what the \"Disable ME\" option in some BIOSes does Also offered as an option when buying some laptops (e.g. Dell) Why is it possible? The FPT is not signed, has just a checksum The partitions are individually signed The offset and size of each partition are saved in each FPT entry Source: Intel ME myths and reality, Igor Skochinsky & Nicola Corna HAP / AltMeDisable bit (aka disabling ME) Method discovered in 2017 by Positive Technologies. Initially introduced by Intel for government/intelligence purposes. Not even the US government trusts ME entirely! Also supported by the me_cleaner project Involves setting an undocumented, secret bit in the Flash Descriptor which acts as a kill-switch for the ME AltMeDisable on ME versions < 11.x HAP (High Assurance Platform) on ME versions >= 11.x Leaves ME in a stopped state, lets it shut down gracefully instead of erroring out - This can help prevent issues with power management that may arise from neutering the ME - Supported by some OEMs 3mdeb official statement Whenever it is possible 3mdeb try to minimize impact of (CS)ME/SPS/TXE or any other firmware residing on peripheral or built-in CPUs.","title":"Intel ME/CSME"},{"location":"osf-trivia-list/me/#introduction","text":"Until Nehalem (ME version 6) it was possible to remove ME firmware completely. Starting with Nehalem, ME firmware can't be completely removed. If ME firmware is missing, the PC will not boot at all Earlier ME versions left a 30 minute grace period for recovering from a bad flash, but this is no longer true Three methods to reduce ME's capabilities have been found: neutering , disabling and soft-disabling . Removing non-essential portions of the ME's firmware is commonly referred to as neutering ME Setting a bit in the Flash Descriptor which acts as a kill-switch which tells ME to hang after initialization is usually what we mean by disabling ME","title":"Introduction"},{"location":"osf-trivia-list/me/#neutering-me","text":"Neutralizing ME: removing non-essential portions of the ME's firmware Also called \"neutering\" Not initially designed by Intel Method discovered by Nicola Corna of the me_cleaner project Removes all modules other than those required for platform init Modules left in ME 6.0 - 10.x: ROMP , BUP Modules left in ME >= 11.x: rbe , kernel , syslib , bup , sometimes also mfs A neutered ME will initialize hardware, then throw an error due to missing firmware This sometimes results in power management issues Therefore it's not recommended in production without extensive testing Functions provided by ME will no longer be operational ME >= v11.x: Sometimes mfs also needs to be preserved. mfs is responsible for some of the hardware initialization.","title":"Neutering ME"},{"location":"osf-trivia-list/me/#soft-disabling-me","text":"It's also possible to put ME into a soft-disabled state by sending a HECI SET_ME_DISABLE or HMRFPO_ENABLE message BIOS needs to send these messages ME will stay disabled until a corresponding ENABLE message is sent Functional ME firmware must be present Usually what the \"Disable ME\" option in some BIOSes does Also offered as an option when buying some laptops (e.g. Dell)","title":"Soft-disabling ME"},{"location":"osf-trivia-list/me/#why-is-it-possible","text":"The FPT is not signed, has just a checksum The partitions are individually signed The offset and size of each partition are saved in each FPT entry Source: Intel ME myths and reality, Igor Skochinsky & Nicola Corna","title":"Why is it possible?"},{"location":"osf-trivia-list/me/#hap-altmedisable-bit-aka-disabling-me","text":"Method discovered in 2017 by Positive Technologies. Initially introduced by Intel for government/intelligence purposes. Not even the US government trusts ME entirely! Also supported by the me_cleaner project Involves setting an undocumented, secret bit in the Flash Descriptor which acts as a kill-switch for the ME AltMeDisable on ME versions < 11.x HAP (High Assurance Platform) on ME versions >= 11.x Leaves ME in a stopped state, lets it shut down gracefully instead of erroring out - This can help prevent issues with power management that may arise from neutering the ME - Supported by some OEMs","title":"HAP / AltMeDisable bit (aka disabling ME)"},{"location":"osf-trivia-list/me/#3mdeb-official-statement","text":"Whenever it is possible 3mdeb try to minimize impact of (CS)ME/SPS/TXE or any other firmware residing on peripheral or built-in CPUs.","title":"3mdeb official statement"},{"location":"osf-trolling-list/build_process/","text":"[OSFI001] Build process [OSFI0010] There is no healthy OSF without reproducible builds What are the reproducible builds? Reproducible Builds and a lot of its aspects is well explained on the linked website. Why are reproducible builds crucial OSF? This is because knowing hashes of firmware components, we can calculate expected TPM PCRs values. By knowing good PCR values and being able to predict further values after firmware update, we are gaining the following advantages: We can easily confirm if the firmware is valid by reading TPM PCRs and compare to reference integrity measures (RIM), RIM can be calculated by build exactly the same version of OSF. NOTE : Please note that depending on your threat model using TPM chip with closed source firmware implementation may lead to solution which is not trustworthy. Process of replying measurements provided in TPM Event Log is simpler because we can easily obtain software and confirm hashes used during PCR extension the process was valid and the same as produced by the software build process Looking for bugs by using bisection is easier since being able to build every commit of software in a reproducible manner give us confidence that there would be no change in behavior between 2 consecutive builds Consistent behavior for given hash can be confirmed by test results tied to given hash in that way users looking at test results may expect exactly the same behavior for firmware binaries with the same hash Long term maintenance should be easier if firmware build would be reproducible over a long time, because often happen some firmware land in industrial applications, e.g., robots, trains, smart city infrastructure, if the bug will be detected after a long time; it is important to have tools and be able to confirm the same binary can be generated in the future. If we know given toolchain reproduce binary bit by bit we are sure it also reproduces software/firmware behavior. In that light making small incremental improvement using a toolchain that gives reproducible results give us higher the chance that we will not introduce uncontrolled change in behavior and code the change will be reflected by the compilation process without affecting previous software behavior. [OSFI0011] Docker containers as build systems \"considered harmful.\" Docker containers for a couple of last years become the default method for providing reproducible runtime environment for software as well those started to be very useful for developers to transfer exact configuration for building given software stack. We wrote about the usefulness of Docker containers in embedded software development environment on 3mdeb blog . After a long time of using Docker containers for embedded software development and build environments we noticed problems for long time maintenance and reproducibility. coreboot-sdk problems The example can be coreboot-sdk used for building coreboot project . A good summary of the problem was provided by Thrilleratplay in guix-docker repo : Currently, the coreboot build environment, coreboot-sdk , uses a Debian docker base image. To install additional required packages, apt-get update must be run. The resulting Docker image is hosted in the Docker hub repository to be retrieved at any time in the future. However, at any time in the future, building the same docker file will generate a different image based on the latest packages used in apt-get. Over time, as packages are updated due to bug, security or feature improvements, the docker image's provenance in the docker hub repository becomes increasingly difficult, if not impossible, to audit and reproduce. Some more detailed notes related to coreboot-sdk issues are presented below. There is no meaningful versioning of SDK [1] - at some point, there was versioning 1.32-53, now switched to git SHA. Both seemed to have no meaning and were released at arbitrary points in time. The result is that it is hard to find which version of SDK works with the coreboot tree version. Validation of coreboot-sdk is not sufficient - for example, recently, python fixes were merged [2] , somehow this change passed all QA checks, but SeaBIOS use python (not python2 or python3) and all builds using this version of SDK that compile SeaBIOS fail. coreboot-sdk is based on moving target Debian sid. It is close to impossible to build the same Docker images at 2 different points in time. coreboot-sdk enforce given version of ACPI spec - this may not always be a good thing to use the most recent compiler and update code accordingly since it can easily break OSes. Why we care? Whenever we deliver code or service to community or customer, we provide build environment which, for the sake of quality user support, should be stable. CI pipelines rely on those containers. Replacing docker image in CI pipeline whenever something change defeat the purpose of having automation and increase maintenance cost significantly and increase maintenance cost significantly Requirements for OSF dev and build process Open-source firmware development and build environment SHOULD have: * meaningful release process * meaningful validation process, at least basic build system and dev env capabilities should be tested * meaningful revisions with a clear explanation of what software stack can be build with what version of dev and build system, a description should include side-spec compliance, e.g., ACPI, SMBIOS, UEFI, etc. * reproducible process that works across systems and in the long run * signature, so anyone can identify where build and dev env coming from and if it is trustworthy Ideas for solving the above issues Docker images are not reproducible - this is a known fact, and if we are extremely serious about stability, security and quality, we should stop using a not reproducible build environment. Of course, there is some work making Docker images reproducible, but it opens Pandora's box [3] of Yocto or Buildroot. Another path could be Nix or Guix, which is currently pursued in the community OSFW #guix-buildstack channel this is a private channel; feel free to ping anyone from 3mdeb Team to join. coreboot toolchain is built by its own build system, which would be hard to couple with Dockerfile or something else. Docker images can be signed using docker trust commands as described here . Other idea would be to use wget and dpkg -i for every needed package in Dockerfile that create base image for reproducible toolchain. Of course that means quite extensive dependency management, but maybe simplicity is worth the effort. It is also possible to maintain VMs per given coreboot (or other OSF) version. That may mean long term VM image compatibility issues as well as problems with making sure images would work with various hypervisor versions. It is even more complex if multiple OS should be supported. VMs also have quite big overhead in terms of performance I'm not tracking all activity in the community, so some claims may be plain wrong. Please let me know what I miss when I'm wrong.","title":"Firmware build process"},{"location":"osf-trolling-list/build_process/#osfi001-build-process","text":"","title":"[OSFI001] Build process"},{"location":"osf-trolling-list/build_process/#osfi0010-there-is-no-healthy-osf-without-reproducible-builds","text":"","title":"[OSFI0010] There is no healthy OSF without reproducible builds"},{"location":"osf-trolling-list/build_process/#osfi0011-docker-containers-as-build-systems-considered-harmful","text":"Docker containers for a couple of last years become the default method for providing reproducible runtime environment for software as well those started to be very useful for developers to transfer exact configuration for building given software stack. We wrote about the usefulness of Docker containers in embedded software development environment on 3mdeb blog . After a long time of using Docker containers for embedded software development and build environments we noticed problems for long time maintenance and reproducibility.","title":"[OSFI0011] Docker containers as build systems \"considered harmful.\""},{"location":"osf-trolling-list/jsm_documentation/","text":"Jira Service Management client procedure Dasharo Support Package If you are interested in starting cooperation using the Support Package, it is the perfect time to start. The Support Package will help us allocate resources and a secure timeline for your needs. To ensure that we can provide comprehensive assistance with your current products and future new developments, we encourage you to choose our new Support Package for more streamlined cooperation, guaranteed availability, and quick, on-time delivery. Why should you add requests to Jira Service Management? JSM allows you to easily keep track of the status of individual requests. Each new request you add means analysis and pricing of task execution. This conversation will take place on JSM. Progress on the request will also be reported using JSM. Before you raise your first request Remember to provide a list of email addresses of people that need access to the portal. It's required to prepare the organization, where requested people will automatically receive updates on the ticket statuses. How to add a request Raising requests using the portal To add a new request using the web service: Go to portal and select the project. Select a type of request and provide the required data. You can also add attachments by dragging and dropping them into any part of the web page, or by clicking the Browse button. When you are ready to send the request, click Send. Your request is created and awaits our response. Raising requests using email If you prefer raising a request using email, you can do this by sending a message to special email address generated for the project. The email address will be provided to you by separate message. Communication through the Jira Service Desk You can always add a comment to the request and attach files. You can do it directly from the JSM request page or using email simply by replying to the email thread. We'll also add comments, questions and quotations in the comment section. What happens after you raise a request We'll soon let you know about the cost and what solutions are proposed. You'll also receive information on which requests will be resolved in the next release. Process and request statuses The diagram below presents what the workflow of JSM requests looks like. Open - your request is created and visible for us, but we didn't start working on it yet. Analysis - our team is analyzing your request. We will soon let you know what will be the cost of resolving this request. Waiting for the client - your action is required to continue working on the request. Most of the time it will be: acceptance of the estimated effort need for additional clarification. Note that the request with this status is waiting for your response. Delaying a response will result with lack of progress being made on the request. Approved - you have accepted the cost, and we will soon start working to resolve the request. Rejected - you have rejected the cost of resolving the request, and we will not work on this request. In progress - we are actively working on the request. On hold - the progress on resolving the request has been paused, and the work may be resumed in the future. Closed - the request has been resolved, but there was no work to be done or work was stopped due to: the client's decision feasibility study showed 0% success rate other Done - the request is resolved, and work has been completed. Support budget After completing the requests, you'll receive information about the state of your support budget by email (by default two times a month). SLAs Our team aims to provide the best support experience. We want you to always be up to date on the status of your request. We are doing our best to reply on your request in less that 36 hours.","title":"Jira Service Management"},{"location":"osf-trolling-list/jsm_documentation/#jira-service-management-client-procedure","text":"","title":"Jira Service Management client procedure"},{"location":"osf-trolling-list/jsm_documentation/#dasharo-support-package","text":"If you are interested in starting cooperation using the Support Package, it is the perfect time to start. The Support Package will help us allocate resources and a secure timeline for your needs. To ensure that we can provide comprehensive assistance with your current products and future new developments, we encourage you to choose our new Support Package for more streamlined cooperation, guaranteed availability, and quick, on-time delivery.","title":"Dasharo Support Package"},{"location":"osf-trolling-list/jsm_documentation/#why-should-you-add-requests-to-jira-service-management","text":"JSM allows you to easily keep track of the status of individual requests. Each new request you add means analysis and pricing of task execution. This conversation will take place on JSM. Progress on the request will also be reported using JSM.","title":"Why should you add requests to Jira Service Management?"},{"location":"osf-trolling-list/jsm_documentation/#before-you-raise-your-first-request","text":"Remember to provide a list of email addresses of people that need access to the portal. It's required to prepare the organization, where requested people will automatically receive updates on the ticket statuses.","title":"Before you raise your first request"},{"location":"osf-trolling-list/jsm_documentation/#how-to-add-a-request","text":"","title":"How to add a request"},{"location":"osf-trolling-list/jsm_documentation/#process-and-request-statuses","text":"The diagram below presents what the workflow of JSM requests looks like. Open - your request is created and visible for us, but we didn't start working on it yet. Analysis - our team is analyzing your request. We will soon let you know what will be the cost of resolving this request. Waiting for the client - your action is required to continue working on the request. Most of the time it will be: acceptance of the estimated effort need for additional clarification. Note that the request with this status is waiting for your response. Delaying a response will result with lack of progress being made on the request. Approved - you have accepted the cost, and we will soon start working to resolve the request. Rejected - you have rejected the cost of resolving the request, and we will not work on this request. In progress - we are actively working on the request. On hold - the progress on resolving the request has been paused, and the work may be resumed in the future. Closed - the request has been resolved, but there was no work to be done or work was stopped due to: the client's decision feasibility study showed 0% success rate other Done - the request is resolved, and work has been completed.","title":"Process and request statuses"},{"location":"osf-trolling-list/jsm_documentation/#support-budget","text":"After completing the requests, you'll receive information about the state of your support budget by email (by default two times a month).","title":"Support budget"},{"location":"osf-trolling-list/jsm_documentation/#slas","text":"Our team aims to provide the best support experience. We want you to always be up to date on the status of your request. We are doing our best to reply on your request in less that 36 hours.","title":"SLAs"},{"location":"osf-trolling-list/osf_issues_taxonomy/","text":"Open Source Firmware Trolling Topics List (OSFTTL) Name of this list was chosen purposefully and facetiously, because its goal is to confront opinions of various community members about controversial topics. We know those topics sometime cause \"flame wars\" or at least rise the temperature of discussion, but we think it is important to have a base onA which Open Source Firmware community can move forward and evolve instead rambling on basic stuff which was already addressed in other places and discussions. Other role of this list is to create taxonomy of OSF problems and issues to community and Dasharo customers, to avoid repeating argumentation and explanation of topics which most of community already are familiar with. OSFTTL candidates Below is the list of potential candidates for trolling questions. Will OSF support device X?","title":"Open Source Firmware Trolling Topics List (OSFTTL)"},{"location":"osf-trolling-list/osf_issues_taxonomy/#open-source-firmware-trolling-topics-list-osfttl","text":"Name of this list was chosen purposefully and facetiously, because its goal is to confront opinions of various community members about controversial topics. We know those topics sometime cause \"flame wars\" or at least rise the temperature of discussion, but we think it is important to have a base onA which Open Source Firmware community can move forward and evolve instead rambling on basic stuff which was already addressed in other places and discussions. Other role of this list is to create taxonomy of OSF problems and issues to community and Dasharo customers, to avoid repeating argumentation and explanation of topics which most of community already are familiar with.","title":"Open Source Firmware Trolling Topics List (OSFTTL)"},{"location":"osf-trolling-list/osf_issues_taxonomy/#osfttl-candidates","text":"Below is the list of potential candidates for trolling questions. Will OSF support device X?","title":"OSFTTL candidates"},{"location":"osf-trolling-list/trusted_computing/","text":"[OSFI002] Trusted computing [OSFI0020] CRTM what it stand for? According to TCG Glossary v1.1 rev1.0 published in 2017 correct definition is: The instructions executed by the platform when it acts as the RTM. [Formerly described as \u201cCore Root of Trust for Measurement\u201d. Code Root of Trust for Measurement is the preferred expansion.] This acronym expansion is preferred. Not every one agree with that expansion of CRTM abbreviation. What do you think?","title":"Trusted Computing"},{"location":"osf-trolling-list/trusted_computing/#osfi002-trusted-computing","text":"","title":"[OSFI002] Trusted computing"},{"location":"osf-trolling-list/trusted_computing/#osfi0020-crtm-what-it-stand-for","text":"According to TCG Glossary v1.1 rev1.0 published in 2017 correct definition is: The instructions executed by the platform when it acts as the RTM. [Formerly described as \u201cCore Root of Trust for Measurement\u201d. Code Root of Trust for Measurement is the preferred expansion.] This acronym expansion is preferred. Not every one agree with that expansion of CRTM abbreviation. What do you think?","title":"[OSFI0020] CRTM what it stand for?"},{"location":"projects/trenchboot-aem/","text":"Trenchboot as Anti Evil Maid Abstract The firmware is the heart of the security of a given system and should always be up-to-date to maintain the computer's security. However, being up to date does not prevent the firmware vulnerabilities from appearing. The Static Root of Trust (SRT) like Unified Extensible Firmware Interface (UEFI) Secure Boot and measured boot provided by the firmware is not always sufficient to establish a secure environment for an operating system. If the firmware is compromised, it could inject malicious software into operating system components and prevent the machine owner from detecting it. Silicon vendors implement alternative technologies to establish a Dynamic Root of Trust (DRT) to provide a secure environment for operating system launch and integrity measurements. Either from SRT or DRT, these integrity measurements can be used for operating system attestation. However, DRT technologies are designed to provide the ability to establish a secure environment for integrity measurements at any arbitrary point of time instead of relying on the firmware, which requires machine reset to establish the aforementioned secure environment. The usage of DRT technologies like Intel Trusted Execution Technology (TXT) or AMD Secure Startup becomes more and more significant, for example, Dynamic Root of Trust for Measurement (DRTM) requirements of Microsoft Secured Core PCs . DRTM hasn't found its place in open-source projects yet, but that gradually changes. The demand on having firmware independent Roots of Trust is increasing, and projects that satisfy this demand are growing, for instance, TrenchBoot . TrenchBoot is a framework that allows individuals and projects to build security engines to perform launch integrity actions for their systems. The framework builds upon Boot Integrity Technologies (BITs) that establish one or more Roots of Trust (RoT) from which a degree of confidence that integrity actions were not subverted. The project has grown a lot thanks to the previous NLnet NGI0 PET grant and now it looks for further expansion into extensive use of the DRT technologies in open-source and security-oriented operating systems like Qubes OS . Qubes OS Anti Evil Maid (AEM) software heavily depends on the availability of the DRTM technologies to prevent the Evil Maid attacks . However, the project hasn't evolved much since the beginning of 2018 and froze on the support of TPM 1.2 with Intel TXT in legacy boot mode (BIOS). Because of that, the usage of this security software is effectively limited to older Intel machines only. TPM 1.2 implemented SHA1 hashing algorithm, which is nowadays considered weak in the era of forever-increasing computer performance and quantum computing. The solution to this problem comes with a newer TPM 2.0 with more agile cryptographic algorithms and SHA256 implementation by default. Qubes OS AEM software suffers from the following: Lack of TPM 2.0 support to handle more secure hashes and safer design of the TPM firmware according to a newer specification. Lack of UEFI mode support. All modern systems boot in UEFI mode only. Legacy boot modes are being deprecated and dropped from the PC firmware. The AEM usage is not possible on most if not all modern machines. Qubes OS AEM has never supported AMD processors with AMD Secure Startup technology. Implementing AMD support would make a significant impact and broaden the usage of DRTM technologies. The initial AEM implementation relied on the Trusted Boot , Intel's reference implementation of Intel TXT. It never had any plans to support AMD processors. TrenchBoot is filling this gap, supporting both Intel and AMD hardware which makes it an ideal target to replace Trusted Boot in Qubes OS AEM implementation. Furthermore, the project grant would be used to implement the missing pieces in the Qubes OS AEM software to cover the AMD and Intel support for both TPM 1.2 and TPM 2.0. Compare your own project with existing or historical efforts 3mdeb is a licensed provider for quality coreboot consulting services since 2016. We are well-known in the open-source community for maintaining the firmware of the PC Engines APU series platform since 2016. Delivering high-quality firmware releases each month and providing technical support on PC Engines and OPNSense forums. 3mdeb embedded systems developers are experienced engineers accustomed to operating systems development. Our developers have contributed to the fwupd support for Qubes OS . 3mdeb is also regularly co-organizing mini-conference events with Qubes OS maintainer Marek Marczykowski-G\u00f3recki, where various topics related to Qubes OS security are discussed. Among them, the Anti Evil Maid was frequently presented by 3mdeb engineers: Anti Evil Maid for Intel coreboot-based platform Anti Evil Maid for modern AMD UEFI-based platform A similar approach was already tried by Assured Information Security (AIS) to boot Xen in UEFI mode with Intel TXT DRTM technology . However, this is only a tiny portion of the work covered by our proposal. Additionally, Qubes OS does not launch using Xen.efi like in the AIS work but uses Multiboot2 protocol with GRUB2 instead, making this approach unusable. Moreover, the Xen.efi approach is much more complex and assumes usage of Trusted Boot, limiting the feature to Intel hardware only. What are the significant technical challenges you expect to solve First of all, Qubes OS AEM software consists of software packages providing Trusted Boot and the Qubes OS TPM scripts . These software packages would need to replace the Trusted Boot with TrenchBoot supported GRUB2 and Xen. Secondly, the TPM scripts require adding support for TPM 2.0 equivalent functionality. AEM requires access to non-volatile RAM inside TPM, which is defined differently in the TPM 2.0 specification compared to TPM 1.2. Another challenge would be to make Xen possible to boot in UEFI boot mode without Boot Services defined in UEFI specification. Boot Services are a set of functions exposed in UEFI structures that are used to help with handling the boot process. However, the main principle of DRTM technologies is to not depend on any external code that is not a part of the operating system software to be executed after DRTM. UEFI Boot Services are a part of the firmware of which DRTM tries to be independent. The whole security concept of DRTM depends on cutting the ties with firmware. Thus the work includes implementing the capability in Xen not to use the UEFI Boot Services, which GRUB2 would terminate before DRTM is executed. Xen also contains an option not to use the UEFI Runtime Services. Runtime Services is a set of functions available throughout the whole machine lifetime, which means some firmware functionalities are available even when the operating system is launched. Removing the Boot Services from Xen brings certain drawbacks to the system because the Boot Services hold essential information like memory map, TPM event log, graphics framebuffer, etc. This information must be extracted by GRUB before Boot Services are terminated and passed to the Xen. The proposed solution is to pass this information via the Multiboot2 tags defined in the specification for this particular Boot Services information. Another challenge would be to get the work merged in the upstream repositories. It would ensure the long-term support and maintenance of the solution and availability. Providing software packages to be used out of the box is crucial for technology availability. Requested support Phase 1: TrenchBoot Intel TXT and TPM 1.2 support Add TPM 1.2 support for Intel TXT in TrenchBoot GRUB2 The TrenchBoot support hasn't been implemented and verified with TPM 1.2 on Intel TXT path. This requirement ensures that the TPM 1.2 is also supported for older Intel hardware with Intel TXT. Xen Secure Launch - Intel TXT support in Xen for TrenchBoot Due to the requirements of Intel TXT and how it is utilized, it is impossible to use the Xen boot protocols defined in the UEFI or Multiboot2 specifications. This task aims to create a custom Intel TXT entry point for Xen, which would hand off to the standard Multiboot2 entry point and enable the direct launch of Xen by GRUB via DRTM on Intel hardware. Additionally, there is no support for launching Xen with Intel TXT other than Trusted Boot. It has to be ported from Trusted Boot specific code: constructing MLE header waking up APs restoring MTRRs reserving the TXT memory reenabling SMIs handling TXT shutdown and S3 resume/suspend TPM event log finding Test the solution on Intel hardware with TPM 1.2 with legacy boot mode Phase 2 - Qubes OS AEM TPM 2.0 support: Extend the AEM scripts to detect TPM version on the platform As TPM 1.2 and TPM 2.0 use different software stacks and tools, it is necessary to distinguish the TPM module family and use the appropriate software. The task will implement the logic to distinguish the TPM families. Extend the AEM scripts to use the appropriate software stack for TPM 2.0 While AEM fully supports TPM 1.2, there is no support for TPM 2.0 at all. When the TPM family is determined, the script should use the appropriate software stack for the given TPM. The task implements the AEM TPM 1.2 equivalent functionalities using TPM 2.0 software stack and as a result allowing the use of TPM 2.0 with Qubes OS AEM. It will require implementing the access to TPM 2.0 NVRAM, sealing and unsealing the secret data, and generating TOTP. Test the solution on Intel hardware with TPM 2.0 with legacy boot mode Phase 3 - Qubes OS AEM AMD support: Rebase and refresh TrenchBoot GRUB2 for QubesOS Some work to implement TrenchBoot support for Qubes OS on AMD hardware has been done. GRUB2 with TrenchBoot support has been added to Qubes building system on 3mdeb fork The task aims to refresh the work and align with the upstream Qubes OS GRUB2 repository Clean up the Secure Kernel Loader (formerly LandingZone) package support for QubesOS Since the initial work done by 3mdeb engineers for AMD AEM in Qubes OS, a lot of time has passed, and Secure Kernel Loader - SKL (formerly Landing Zone) has improved a lot and added new features. SKL is an open-source module written by TrenchBoot developers required by AMD Secure Startup technology to perform DRTM launch. The task aims to refresh the previous work and update the SKL package for Qubes OS to the newest revision. TrenchBoot Secure Kernel Loader (SKL) improvements for AMD server CPUs with multiple nodes While SKL was extensively tested on System on Chip and single CPU platforms, it was not tested on workstation/server segment CPUs which are more complex. For example, one server CPU package may contain two independent CPUs inside called nodes. Each node will enable protection on the SKL during DRTM execution, and this protection must be disabled on each node when TrenchBoot DRTM tasks are done. The task implements the correct support for server CPUs in TrenchBoot SKL. Test the solution on AMD hardware with TPM 2.0 and TPM 1.2 with legacy boot mode Phase 4 - Xen UEFI boot mode with DRTM: TrenchBoot support for UEFI boot mode for AMD in GRUB While TrenchBoot DRTM was extensively tested on Intel hardware with UEFI firmware and Linux, it was not on AMD platforms. This task ensures that DRTM works with UEFI boot mode on AMD processors in GRUB2 and Linux without UEFI Boot Services. TrenchBoot support for UEFI boot mode in Xen When UEFI boot mode with TrenchBoot is working with GRUB2 and Linux, all that is missing to fully support AMD and Intel hardware with Qubes OS AEM is the Xen support to boot in UEFI mode without Boot Services. This requires a significant amount of work to ensure that all information that Xen would obtain from UEFI Boot Services would still be available. The information has to be passed by GRUB2 to Xen via Multiboot2 protocol: EFI memory map Framebuffer information PCI devices information with their option ROMs Additionally \"EFI boot services not terminated\" Multiboot2 tag must not be passed to Xen by GRUB2 on DRTM launch when GRUB2 will terminate Boot Services. Xen should detect such situations and act according to the state of Boot Services. Xen will be implemented to: parse the EFI memory map, framebuffer information, and PCI devices information passed by GRUB2 do not expose the \"EFI boot services\" Multiboot2 tag indicating that Xen can be executed without UEFI Boot Services presence allocate the memory space for the trampoline used to launch other processors or use the allocation done by GRUB2 if necessary do not go error path when Boot Services are not present and skip all calls to UEFI Boot Services by using the information provided by GRUB2 Test the solution on AMD and Intel hardware with TPM 2.0 and TPM 1.2 with legacy and UEFI boot mode Projects or organizations relevant to this project before? Qubes OS Xen Hypervisor GNU GRUB TrenchBoot Invisible Things Lab Apertus Solutions Oracle 3mdeb The ecosystem of the project 3mdeb has a good relationship with the maintainers of relevant projects which will participate in the review of the work: Marek Marczykowski-G\u00f3recki (Invisible Things Lab CTO) - Qubes OS maintainer Andrew Cooper (Citrix) - Xen Hypervisor Maintainer Daniel Kiper (Oracle) - GRUB2 Maintainer Daniel Smith (Apertus Solutions) - TrenchBoot founder and maintainer Review Further reviews and suggestions are welcome. You can do it in two ways: using Giscus on the bottom of this page contributing to this repository directly via Pull Request","title":"TrenchBoot Anti Evil Maid"},{"location":"projects/trenchboot-aem/#trenchboot-as-anti-evil-maid","text":"","title":"Trenchboot as Anti Evil Maid"},{"location":"projects/trenchboot-aem/#abstract","text":"The firmware is the heart of the security of a given system and should always be up-to-date to maintain the computer's security. However, being up to date does not prevent the firmware vulnerabilities from appearing. The Static Root of Trust (SRT) like Unified Extensible Firmware Interface (UEFI) Secure Boot and measured boot provided by the firmware is not always sufficient to establish a secure environment for an operating system. If the firmware is compromised, it could inject malicious software into operating system components and prevent the machine owner from detecting it. Silicon vendors implement alternative technologies to establish a Dynamic Root of Trust (DRT) to provide a secure environment for operating system launch and integrity measurements. Either from SRT or DRT, these integrity measurements can be used for operating system attestation. However, DRT technologies are designed to provide the ability to establish a secure environment for integrity measurements at any arbitrary point of time instead of relying on the firmware, which requires machine reset to establish the aforementioned secure environment. The usage of DRT technologies like Intel Trusted Execution Technology (TXT) or AMD Secure Startup becomes more and more significant, for example, Dynamic Root of Trust for Measurement (DRTM) requirements of Microsoft Secured Core PCs . DRTM hasn't found its place in open-source projects yet, but that gradually changes. The demand on having firmware independent Roots of Trust is increasing, and projects that satisfy this demand are growing, for instance, TrenchBoot . TrenchBoot is a framework that allows individuals and projects to build security engines to perform launch integrity actions for their systems. The framework builds upon Boot Integrity Technologies (BITs) that establish one or more Roots of Trust (RoT) from which a degree of confidence that integrity actions were not subverted. The project has grown a lot thanks to the previous NLnet NGI0 PET grant and now it looks for further expansion into extensive use of the DRT technologies in open-source and security-oriented operating systems like Qubes OS . Qubes OS Anti Evil Maid (AEM) software heavily depends on the availability of the DRTM technologies to prevent the Evil Maid attacks . However, the project hasn't evolved much since the beginning of 2018 and froze on the support of TPM 1.2 with Intel TXT in legacy boot mode (BIOS). Because of that, the usage of this security software is effectively limited to older Intel machines only. TPM 1.2 implemented SHA1 hashing algorithm, which is nowadays considered weak in the era of forever-increasing computer performance and quantum computing. The solution to this problem comes with a newer TPM 2.0 with more agile cryptographic algorithms and SHA256 implementation by default. Qubes OS AEM software suffers from the following: Lack of TPM 2.0 support to handle more secure hashes and safer design of the TPM firmware according to a newer specification. Lack of UEFI mode support. All modern systems boot in UEFI mode only. Legacy boot modes are being deprecated and dropped from the PC firmware. The AEM usage is not possible on most if not all modern machines. Qubes OS AEM has never supported AMD processors with AMD Secure Startup technology. Implementing AMD support would make a significant impact and broaden the usage of DRTM technologies. The initial AEM implementation relied on the Trusted Boot , Intel's reference implementation of Intel TXT. It never had any plans to support AMD processors. TrenchBoot is filling this gap, supporting both Intel and AMD hardware which makes it an ideal target to replace Trusted Boot in Qubes OS AEM implementation. Furthermore, the project grant would be used to implement the missing pieces in the Qubes OS AEM software to cover the AMD and Intel support for both TPM 1.2 and TPM 2.0.","title":"Abstract"},{"location":"projects/trenchboot-aem/#compare-your-own-project-with-existing-or-historical-efforts","text":"3mdeb is a licensed provider for quality coreboot consulting services since 2016. We are well-known in the open-source community for maintaining the firmware of the PC Engines APU series platform since 2016. Delivering high-quality firmware releases each month and providing technical support on PC Engines and OPNSense forums. 3mdeb embedded systems developers are experienced engineers accustomed to operating systems development. Our developers have contributed to the fwupd support for Qubes OS . 3mdeb is also regularly co-organizing mini-conference events with Qubes OS maintainer Marek Marczykowski-G\u00f3recki, where various topics related to Qubes OS security are discussed. Among them, the Anti Evil Maid was frequently presented by 3mdeb engineers: Anti Evil Maid for Intel coreboot-based platform Anti Evil Maid for modern AMD UEFI-based platform A similar approach was already tried by Assured Information Security (AIS) to boot Xen in UEFI mode with Intel TXT DRTM technology . However, this is only a tiny portion of the work covered by our proposal. Additionally, Qubes OS does not launch using Xen.efi like in the AIS work but uses Multiboot2 protocol with GRUB2 instead, making this approach unusable. Moreover, the Xen.efi approach is much more complex and assumes usage of Trusted Boot, limiting the feature to Intel hardware only.","title":"Compare your own project with existing or historical efforts"},{"location":"projects/trenchboot-aem/#what-are-the-significant-technical-challenges-you-expect-to-solve","text":"First of all, Qubes OS AEM software consists of software packages providing Trusted Boot and the Qubes OS TPM scripts . These software packages would need to replace the Trusted Boot with TrenchBoot supported GRUB2 and Xen. Secondly, the TPM scripts require adding support for TPM 2.0 equivalent functionality. AEM requires access to non-volatile RAM inside TPM, which is defined differently in the TPM 2.0 specification compared to TPM 1.2. Another challenge would be to make Xen possible to boot in UEFI boot mode without Boot Services defined in UEFI specification. Boot Services are a set of functions exposed in UEFI structures that are used to help with handling the boot process. However, the main principle of DRTM technologies is to not depend on any external code that is not a part of the operating system software to be executed after DRTM. UEFI Boot Services are a part of the firmware of which DRTM tries to be independent. The whole security concept of DRTM depends on cutting the ties with firmware. Thus the work includes implementing the capability in Xen not to use the UEFI Boot Services, which GRUB2 would terminate before DRTM is executed. Xen also contains an option not to use the UEFI Runtime Services. Runtime Services is a set of functions available throughout the whole machine lifetime, which means some firmware functionalities are available even when the operating system is launched. Removing the Boot Services from Xen brings certain drawbacks to the system because the Boot Services hold essential information like memory map, TPM event log, graphics framebuffer, etc. This information must be extracted by GRUB before Boot Services are terminated and passed to the Xen. The proposed solution is to pass this information via the Multiboot2 tags defined in the specification for this particular Boot Services information. Another challenge would be to get the work merged in the upstream repositories. It would ensure the long-term support and maintenance of the solution and availability. Providing software packages to be used out of the box is crucial for technology availability.","title":"What are the significant technical challenges you expect to solve"},{"location":"projects/trenchboot-aem/#requested-support","text":"Phase 1: TrenchBoot Intel TXT and TPM 1.2 support Add TPM 1.2 support for Intel TXT in TrenchBoot GRUB2 The TrenchBoot support hasn't been implemented and verified with TPM 1.2 on Intel TXT path. This requirement ensures that the TPM 1.2 is also supported for older Intel hardware with Intel TXT. Xen Secure Launch - Intel TXT support in Xen for TrenchBoot Due to the requirements of Intel TXT and how it is utilized, it is impossible to use the Xen boot protocols defined in the UEFI or Multiboot2 specifications. This task aims to create a custom Intel TXT entry point for Xen, which would hand off to the standard Multiboot2 entry point and enable the direct launch of Xen by GRUB via DRTM on Intel hardware. Additionally, there is no support for launching Xen with Intel TXT other than Trusted Boot. It has to be ported from Trusted Boot specific code: constructing MLE header waking up APs restoring MTRRs reserving the TXT memory reenabling SMIs handling TXT shutdown and S3 resume/suspend TPM event log finding Test the solution on Intel hardware with TPM 1.2 with legacy boot mode Phase 2 - Qubes OS AEM TPM 2.0 support: Extend the AEM scripts to detect TPM version on the platform As TPM 1.2 and TPM 2.0 use different software stacks and tools, it is necessary to distinguish the TPM module family and use the appropriate software. The task will implement the logic to distinguish the TPM families. Extend the AEM scripts to use the appropriate software stack for TPM 2.0 While AEM fully supports TPM 1.2, there is no support for TPM 2.0 at all. When the TPM family is determined, the script should use the appropriate software stack for the given TPM. The task implements the AEM TPM 1.2 equivalent functionalities using TPM 2.0 software stack and as a result allowing the use of TPM 2.0 with Qubes OS AEM. It will require implementing the access to TPM 2.0 NVRAM, sealing and unsealing the secret data, and generating TOTP. Test the solution on Intel hardware with TPM 2.0 with legacy boot mode Phase 3 - Qubes OS AEM AMD support: Rebase and refresh TrenchBoot GRUB2 for QubesOS Some work to implement TrenchBoot support for Qubes OS on AMD hardware has been done. GRUB2 with TrenchBoot support has been added to Qubes building system on 3mdeb fork The task aims to refresh the work and align with the upstream Qubes OS GRUB2 repository Clean up the Secure Kernel Loader (formerly LandingZone) package support for QubesOS Since the initial work done by 3mdeb engineers for AMD AEM in Qubes OS, a lot of time has passed, and Secure Kernel Loader - SKL (formerly Landing Zone) has improved a lot and added new features. SKL is an open-source module written by TrenchBoot developers required by AMD Secure Startup technology to perform DRTM launch. The task aims to refresh the previous work and update the SKL package for Qubes OS to the newest revision. TrenchBoot Secure Kernel Loader (SKL) improvements for AMD server CPUs with multiple nodes While SKL was extensively tested on System on Chip and single CPU platforms, it was not tested on workstation/server segment CPUs which are more complex. For example, one server CPU package may contain two independent CPUs inside called nodes. Each node will enable protection on the SKL during DRTM execution, and this protection must be disabled on each node when TrenchBoot DRTM tasks are done. The task implements the correct support for server CPUs in TrenchBoot SKL. Test the solution on AMD hardware with TPM 2.0 and TPM 1.2 with legacy boot mode Phase 4 - Xen UEFI boot mode with DRTM: TrenchBoot support for UEFI boot mode for AMD in GRUB While TrenchBoot DRTM was extensively tested on Intel hardware with UEFI firmware and Linux, it was not on AMD platforms. This task ensures that DRTM works with UEFI boot mode on AMD processors in GRUB2 and Linux without UEFI Boot Services. TrenchBoot support for UEFI boot mode in Xen When UEFI boot mode with TrenchBoot is working with GRUB2 and Linux, all that is missing to fully support AMD and Intel hardware with Qubes OS AEM is the Xen support to boot in UEFI mode without Boot Services. This requires a significant amount of work to ensure that all information that Xen would obtain from UEFI Boot Services would still be available. The information has to be passed by GRUB2 to Xen via Multiboot2 protocol: EFI memory map Framebuffer information PCI devices information with their option ROMs Additionally \"EFI boot services not terminated\" Multiboot2 tag must not be passed to Xen by GRUB2 on DRTM launch when GRUB2 will terminate Boot Services. Xen should detect such situations and act according to the state of Boot Services. Xen will be implemented to: parse the EFI memory map, framebuffer information, and PCI devices information passed by GRUB2 do not expose the \"EFI boot services\" Multiboot2 tag indicating that Xen can be executed without UEFI Boot Services presence allocate the memory space for the trampoline used to launch other processors or use the allocation done by GRUB2 if necessary do not go error path when Boot Services are not present and skip all calls to UEFI Boot Services by using the information provided by GRUB2 Test the solution on AMD and Intel hardware with TPM 2.0 and TPM 1.2 with legacy and UEFI boot mode","title":"Requested support"},{"location":"projects/trenchboot-aem/#projects-or-organizations-relevant-to-this-project-before","text":"Qubes OS Xen Hypervisor GNU GRUB TrenchBoot Invisible Things Lab Apertus Solutions Oracle 3mdeb","title":"Projects or organizations relevant to this project before?"},{"location":"projects/trenchboot-aem/#the-ecosystem-of-the-project","text":"3mdeb has a good relationship with the maintainers of relevant projects which will participate in the review of the work: Marek Marczykowski-G\u00f3recki (Invisible Things Lab CTO) - Qubes OS maintainer Andrew Cooper (Citrix) - Xen Hypervisor Maintainer Daniel Kiper (Oracle) - GRUB2 Maintainer Daniel Smith (Apertus Solutions) - TrenchBoot founder and maintainer","title":"The ecosystem of the project"},{"location":"projects/trenchboot-aem/#review","text":"Further reviews and suggestions are welcome. You can do it in two ways: using Giscus on the bottom of this page contributing to this repository directly via Pull Request","title":"Review"},{"location":"quality-principles/introduction/","text":"Dasharo Quality Principles Secure Delivery Each Dasharo release is secured cryptographically, ensuring with RSA 4096 keys the authenticity of binary SHA-256 integrity checksum. The three-step key verification is guarantees that your client receives a clean file without any third-party modifications. Integrity and signature verification procedure is included, so that the key compliance can be easily checked. Secure Maintenance Dasharo doesn't believe in security through obscurity. That is why each Dasharo firmware is supported with the system of Transparent Validation, proving its efficiency and quality with testing results. As an Open Source product, it provides timely emergency releases and patches together with long-lasting maintenance. Credibility Dasharo values credibility. Each release is extended by a validation report based on a project charter and a complete changelog with a description of the product versioning. Transparency Generic testing procedures for a given Dasharo product line are included in the product documentation. Specific testing procedures are delivered in the form of a PDF document accompanying a release. Availability Dasharo product line page includes a hardware compatibility platform list. The platform for which the new product line is created becomes its reference platform. The consecutive hardware platforms are added to the hardware compatibility list (HCL). Compliance No danger of version lock. Dasharo releases are versioned according to the [Semantic Versioning 2.0.0] ( https://semver.org/ ) specification for the sake of consistency. Release notes comply with the [Keep A Changelog 1.0.0] specification ( https://keepachangelog.com/en/1.0.0/ ).","title":"Quality Principles"},{"location":"quality-principles/introduction/#dasharo-quality-principles","text":"","title":"Dasharo Quality Principles"},{"location":"quality-principles/introduction/#secure-delivery","text":"Each Dasharo release is secured cryptographically, ensuring with RSA 4096 keys the authenticity of binary SHA-256 integrity checksum. The three-step key verification is guarantees that your client receives a clean file without any third-party modifications. Integrity and signature verification procedure is included, so that the key compliance can be easily checked.","title":"Secure Delivery"},{"location":"quality-principles/introduction/#secure-maintenance","text":"Dasharo doesn't believe in security through obscurity. That is why each Dasharo firmware is supported with the system of Transparent Validation, proving its efficiency and quality with testing results. As an Open Source product, it provides timely emergency releases and patches together with long-lasting maintenance.","title":"Secure Maintenance"},{"location":"quality-principles/introduction/#credibility","text":"Dasharo values credibility. Each release is extended by a validation report based on a project charter and a complete changelog with a description of the product versioning.","title":"Credibility"},{"location":"quality-principles/introduction/#transparency","text":"Generic testing procedures for a given Dasharo product line are included in the product documentation. Specific testing procedures are delivered in the form of a PDF document accompanying a release.","title":"Transparency"},{"location":"quality-principles/introduction/#availability","text":"Dasharo product line page includes a hardware compatibility platform list. The platform for which the new product line is created becomes its reference platform. The consecutive hardware platforms are added to the hardware compatibility list (HCL).","title":"Availability"},{"location":"quality-principles/introduction/#compliance","text":"No danger of version lock. Dasharo releases are versioned according to the [Semantic Versioning 2.0.0] ( https://semver.org/ ) specification for the sake of consistency. Release notes comply with the [Keep A Changelog 1.0.0] specification ( https://keepachangelog.com/en/1.0.0/ ).","title":"Compliance"},{"location":"transparent-validation/muxpi/basic-validation/","text":"muxPi board validation In case of any troubles, first it is recommended to read comprehend Theory of Operations for muxPi devices. Necessary components preparation NanoPi muxPi ETH, microUSB<->USB cables, power supply (5V/2A Dc 5.5/2.1mm jack) 2 SDcards (minimum 8GB each) IDC-uSD adapter (DUT<->SD card) SD card adapter (USB<->SD card) Device bootable from SD card (e.g. RPI) NanoPi setup Prepare microSD card (minimum 8GB) for NanoPi NEO operating system. Download and extract image - link Flash image into microSD card ( Etcher tool could be helpful) muxPi setup Attach NanoPi to muxPi connectors. Plug ETH cable to RJ45 NanoPi port. Plug microUSB<->USB cable to muxPi and your machine. Plug in power supply. Make sure that jumpers are correctly set according to image: Connect to NanoPi using terminal: sudo minicom -D /dev/ttyUSB0 -o -b 115200 ` Save ip address: ifconfig Connect to NanoPi via ssh (with password: fa ): bash ssh root@192.168.4.XXX Or via serial connection. NOTE: Connecting with MuxPi through serial will automatically login as non root user pi with password pi . Validation steps 1. Install WiringNP git clone https://github.com/friendlyarm/WiringNP cd WiringNP/ chmod 755 build ./build verify installation: gpio readall If your installation is successful the following messages will show up: +-----+-----+----------+------+---+-NanoPi-NEO--+------+----------+-----+-----+ | BCM | wPi | Name | Mode | V | Physical | V | Mode | Name | wPi | BCM | +-----+-----+----------+------+---+----++----+---+------+----------+-----+-----+ | | | 3 .3V | | | 1 || 2 | | | 5V | | | | 12 | 8 | GPIOA12 | ALT5 | 0 | 3 || 4 | | | 5V | | | | 11 | 9 | GPIOA11 | ALT5 | 0 | 5 || 6 | | | 0v | | | | 203 | 7 | GPIOG11 | OFF | 0 | 7 || 8 | 0 | ALT5 | GPIOG6 | 15 | 198 | | | | 0v | | | 9 || 10 | 0 | ALT5 | GPIOG7 | 16 | 199 | | 0 | 0 | GPIOA0 | ALT5 | 0 | 11 || 12 | 0 | OUT | GPIOA6 | 1 | 6 | | 2 | 2 | GPIOA2 | OFF | 0 | 13 || 14 | | | 0v | | | | 3 | 3 | GPIOA3 | OFF | 0 | 15 || 16 | 0 | OFF | GPIOG8 | 4 | 200 | | | | 3 .3v | | | 17 || 18 | 0 | OFF | GPIOG9 | 5 | 201 | | 64 | 12 | GPIOC0 | ALT4 | 0 | 19 || 20 | | | 0v | | | | 65 | 13 | GPIOC1 | ALT4 | 0 | 21 || 22 | 0 | ALT5 | GPIOA1 | 6 | 1 | | 66 | 14 | GPIOC2 | ALT4 | 0 | 23 || 24 | 1 | OUT | GPIOC3 | 10 | 67 | +-----+-----+----------+------+---+----++----+---+------+----------+-----+-----+ | BCM | wPi | Name | Mode | V | Physical | V | Mode | Name | wPi | BCM | +-----+-----+----------+------+---+-NanoPi-NEO--+------+----------+-----+-----+ +-----+----NanoPi-NEO USB/Audio-+----+ | BCM | wPi | Name | Mode | V | Ph | +-----+-----+----------+------+---+----+ | | | 5V | | | 25 | | | | USB-DP1 | | | 26 | | | | USB-DM1 | | | 27 | | | | USB-DP2 | | | 28 | | | | USB-DM2 | | | 29 | | | | IR-RX | | | 30 | | 17 | 19 | GPIOA17 | OFF | 0 | 31 | | | | PCM/I2C | | | 32 | | | | PCM/I2C | | | 33 | | | | PCM/I2C | | | 34 | | | | PCM/I2C | | | 35 | | | | 0V | | | 36 | +-----+-----+----------+------+---+----+ +-----+----NanoPi-NEO Debug UART-+----+ | BCM | wPi | Name | Mode | V | Ph | +-----+-----+----------+------+---+----+ | 4 | 17 | GPIOA4 | ALT5 | 0 | 37 | | 5 | 18 | GPIOA5 | ALT5 | 0 | 38 | +-----+-----+----------+------+---+----+ 2. Cortex-M0 flashing The second controllable unit on the muxPi board is embedded microcontroller STM32 F030C6T6 from Cortex-M0 family. It is required to flash special binary prepared by Tizen group (the code is not open yet, but this process is in progress). To flash muxPi's microcontroller, follow steps below: Make sure that VDD jumper is left open. Download binary file - link . Copy binary to nanoPi: scp <path-to-file> root@192.168.4.XXX:/root/ Update package lists (nanoPi): apt-get update Install stm32flash utility (nanoPi): sudo apt-get install stm32flash Export GPIO: gpio mode 3 out and gpio mode 7 out Set Cortex-M0 to \"Flashing mode\": gpio write 7 1 Power up microcontroller: gpio write 3 1 Flash firmware: stm32flash -w /root/firmware-05.bin -v -g 0x0 /dev/ttyS2 Power off microcontroller: gpio write 3 0 Set Cortex-M0 to \"Execution mode\": gpio write 7 0 Power on microcontroller: gpio write 3 1 From now on, muxPi's LCD should light on and display: * MuxPi * HW: 1 .0 SW: 0 .5 3. SD Adapter Connect IDC-uSD adapter to the muxPI board: Insert the microSD card to microSD card slot accessible on the bottom side of muxPi board. To enable microSD card reader, connect to Cortex from MuxPi via minicom: minicom -D /dev/ttyS2 and enter in minicom following commands: ts and then dut NOTE: Each command should return OK Connect IDC-uSD adapter to a SD card adapter plugged into your machine NOTE: You need to force IDC-uSD adapter to insert into SD card adapter (On your machine) Check if device is connected: dmesg -w should help. You should also be able to read and write data to uSD card from file manager. Flash image into microSD card (for RPI or other device bootable form SD card). Disconnect uSD adapter form a SD card adapter and connect to the device (e.g. RPI). Connect device to the power supply, now device should boot via IDC-uSD adapter. 4. Screening It is recommended to use screen program for communication: Install screen: sudo apt-get install screen Open connection (from muxPi): screen /dev/ttyS2 115200,cs8,ixon,ixoff Write help and press Enter. Help output: help --- This help version --- Display version of the firmware echo --- Get ( no arguments ) or set ( 'on' or 'off' ) echo on serial \"console\" : echo [ on | off ] . The default value is on. power --- Get ( no arguments ) or set ( 'on' or 'off' ) or switch off and on ( 'tick' ) power supply for DUT: power [ on | off | tick ] hdmi --- Get ( no arguments ) or set ( 'on' or 'off' ) HDMI HOTPLUG pin: hdmi [ on | off ] dyper --- Get ( no second argument ) or set ( 'on' or 'off' ) DyPer state: dyper 1 | 2 [ on | off ] mux --- Connect microSD card to external connector ( DUT ) or card reader ( ts ) : mux [ dut | ts ] dut --- Connect microSD card and power to DUT: dut ts --- Connect microSD card and power to TS: ts led --- Get ( no second or third argument ) or set ( 'R G B' ) color of led ( 1 | 2 ) , ex: led 1 255 0 255 clr --- Clear oled display text --- Print text on the OLED display: text x y color content draw --- Draw an object on the OLED display: draw object x1 y1 [ x2 y2 ] , objects are: - point x y color - draws one point at given coordinates - line x1 y1 x2 y2 color - draws line between given coordinates - rectangle left top width height color - draws line between given coordinates - circle x y radius color - draws line between given coordinates color must be 'on' , 'off' or 'inv' adc --- Print current adc value of all ( if no arguments are given ) or one specified channel, ex: adc 1 voltage --- Print current voltage [ mV ] of all ( if no arguments are given ) or one specified channel, ex: voltage 1 current --- Print current current [ mA ] being consumed by DUT lthor --- Get ( no second argument ) or set state of lthor control signals: - lthor switch [ usb | uart ] - redirect DUT 's USB wires to NanoPi' s 'usb' or 'uart' - lthor id [ usb | uart ] - switch DUT 's USB to ' usb ' or ' uart ' mode - lthor vbus [on|off] - switch DUT' s VBUS 'on' or 'off' - lthor combo [ usb | uart ] - make DUT and MuxPi USB work in 'usb' or 'uart' mode - no get function key --- Get current state of given key or both if no key number is given: key [ 1 | 2 ] uart --- Get current value of UART voltage or set if new value is given [ in millivolts ] NOTE: help might not display anything. Then try to use minicom. Minicom quick guide: Install minicom: sudo apt-get install minicom Connect via minicom: sudo minicom -D /dev/ttyS2 -o -b 115200 Type: help NOTE: If output is the same as above then basic validation for muxPi is done. Images source: Wiki Tizen","title":"Basic validation"},{"location":"transparent-validation/muxpi/basic-validation/#muxpi-board-validation","text":"In case of any troubles, first it is recommended to read comprehend Theory of Operations for muxPi devices.","title":"muxPi board validation"},{"location":"transparent-validation/muxpi/basic-validation/#necessary-components-preparation","text":"NanoPi muxPi ETH, microUSB<->USB cables, power supply (5V/2A Dc 5.5/2.1mm jack) 2 SDcards (minimum 8GB each) IDC-uSD adapter (DUT<->SD card) SD card adapter (USB<->SD card) Device bootable from SD card (e.g. RPI)","title":"Necessary components preparation"},{"location":"transparent-validation/muxpi/basic-validation/#nanopi-setup","text":"Prepare microSD card (minimum 8GB) for NanoPi NEO operating system. Download and extract image - link Flash image into microSD card ( Etcher tool could be helpful)","title":"NanoPi setup"},{"location":"transparent-validation/muxpi/basic-validation/#muxpi-setup","text":"Attach NanoPi to muxPi connectors. Plug ETH cable to RJ45 NanoPi port. Plug microUSB<->USB cable to muxPi and your machine. Plug in power supply. Make sure that jumpers are correctly set according to image: Connect to NanoPi using terminal: sudo minicom -D /dev/ttyUSB0 -o -b 115200 ` Save ip address: ifconfig Connect to NanoPi via ssh (with password: fa ): bash ssh root@192.168.4.XXX Or via serial connection. NOTE: Connecting with MuxPi through serial will automatically login as non root user pi with password pi .","title":"muxPi setup"},{"location":"transparent-validation/muxpi/basic-validation/#validation-steps","text":"","title":"Validation steps"},{"location":"transparent-validation/muxpi/theory-of-operations/","text":"MuxPi - Theory of Operations Block diagram muxPi setup NanoPi NEO Preparation of the muxPi's \"heart\": Prepare microSD card (minimum 8GB) for NanoPi NEO operating system. Download and extract image - link Flash image into microSD card ( Etcher tool could be helpful) Insert card to NanoPi microSD slot. Attach NanoPi to muxPi connectors. Plug Ethernet cable to RJ45 NanoPi port. Serial communication There are two methods to setup serial communication with muxPi: with microUSB<->USB cable with UART/USB converter Attach USB/UART converter to muxPi's left addon female header ( GND , DBG UART RX , DBG UART TX on pinout image below): and plug USB connector to the computer. Next, open connection in PC terminal by typing: sudo minicom -D /dev/ttyUSB0 -o -b 115200 . /dev/ttyUSB0 is example device - check whether USB0 is the correct one Jumpers configuration UART - pins Vloc & VCC - if jumped then internal voltage generator is used as voltage reference for data lines and powers up target device. If open then voltage reference for data lines comes from target device and internal voltage generator is unused. USB/ETH - determines what USB data lines of one USB HUB are connected to. If first two pins are jumped then USB lines are connected to add-on connector. If last two pins are jumped then these lines are connected tu USB<->ETH converter. If none of the pins are jumped then the only connection is the upper socket of double connector. NOTE: The upper socket of double USB-A connector must be left empty if USB<->ETH is selected or add-on connector is selected and something is connected to these data lines on the addon! NOTE: Both jumpers must be placed in the same position! VDD - if this pins are jumped then the VDD and 3V3 are always on. If this is left open then VDD and 3V3 are controlled by NanoPi. The usage example is setting value of USB ID potentiometer (which is located underneath NanoPi). But when NanoPi NEO is removed there is no way to turn on power for microcontroller (that is when VDD jumper is helpful). NOTE: If there is no particular need then leave this jumper open. Power supply To power on MuxPi with NanoPi attached, plug the 5V/2A DC 5.5/2.1mm power supply jack to the CON1 muxPi's connector. Power consumption of MuxPi should be less then 1A assuming no addons connected. IP address To check which IP address has been assigned, type in terminal: ifconfig . OPTIONAL STEP: To set static IP, create the following file: sudo vi /etc/NetworkManager/NetworkManager.conf Edit NetworkManger.conf and set the value of \"managed\" under \"ifupdown\" to false: [ ifupdown ] managed = false Add network setting to /etc/network/interfaces : sudo vi /etc/network/interfaces Here is sample of /etc/network/interfaces : # The loopback network interface auto lo iface lo inet loopback # network interface not managed by Network Manager allow-hotplug eth0 iface eth0 inet static address 192 .168.4.XXX netmask 255 .255.255.0 gateway 192 .168.4.1 dns-nameservers 192 .168.4.1 Restart the whole device: reboot Now you should be able to connect to device through ssh: ssh root@192.168.4.XXX with the password: fa Install WiringNP Connect to NanoPi NEO through ssh (serial connection automatically login to non root user pi ), then type: git clone https://github.com/friendlyarm/WiringNP cd WiringNP/ chmod 755 build ./build Verify installation: gpio readall If your installation is successful the following messages will show up: +-----+-----+----------+------+---+-NanoPi-NEO--+------+----------+-----+-----+ | BCM | wPi | Name | Mode | V | Physical | V | Mode | Name | wPi | BCM | +-----+-----+----------+------+---+----++----+---+------+----------+-----+-----+ | | | 3 .3V | | | 1 || 2 | | | 5V | | | | 12 | 8 | GPIOA12 | ALT5 | 0 | 3 || 4 | | | 5V | | | | 11 | 9 | GPIOA11 | ALT5 | 0 | 5 || 6 | | | 0v | | | | 203 | 7 | GPIOG11 | OFF | 0 | 7 || 8 | 0 | ALT5 | GPIOG6 | 15 | 198 | | | | 0v | | | 9 || 10 | 0 | ALT5 | GPIOG7 | 16 | 199 | | 0 | 0 | GPIOA0 | ALT5 | 0 | 11 || 12 | 0 | OUT | GPIOA6 | 1 | 6 | | 2 | 2 | GPIOA2 | OFF | 0 | 13 || 14 | | | 0v | | | | 3 | 3 | GPIOA3 | OFF | 0 | 15 || 16 | 0 | OFF | GPIOG8 | 4 | 200 | | | | 3 .3v | | | 17 || 18 | 0 | OFF | GPIOG9 | 5 | 201 | | 64 | 12 | GPIOC0 | ALT4 | 0 | 19 || 20 | | | 0v | | | | 65 | 13 | GPIOC1 | ALT4 | 0 | 21 || 22 | 0 | ALT5 | GPIOA1 | 6 | 1 | | 66 | 14 | GPIOC2 | ALT4 | 0 | 23 || 24 | 1 | OUT | GPIOC3 | 10 | 67 | +-----+-----+----------+------+---+----++----+---+------+----------+-----+-----+ | BCM | wPi | Name | Mode | V | Physical | V | Mode | Name | wPi | BCM | +-----+-----+----------+------+---+-NanoPi-NEO--+------+----------+-----+-----+ +-----+----NanoPi-NEO USB/Audio-+----+ | BCM | wPi | Name | Mode | V | Ph | +-----+-----+----------+------+---+----+ | | | 5V | | | 25 | | | | USB-DP1 | | | 26 | | | | USB-DM1 | | | 27 | | | | USB-DP2 | | | 28 | | | | USB-DM2 | | | 29 | | | | IR-RX | | | 30 | | 17 | 19 | GPIOA17 | OFF | 0 | 31 | | | | PCM/I2C | | | 32 | | | | PCM/I2C | | | 33 | | | | PCM/I2C | | | 34 | | | | PCM/I2C | | | 35 | | | | 0V | | | 36 | +-----+-----+----------+------+---+----+ +-----+----NanoPi-NEO Debug UART-+----+ | BCM | wPi | Name | Mode | V | Ph | +-----+-----+----------+------+---+----+ | 4 | 17 | GPIOA4 | ALT5 | 0 | 37 | | 5 | 18 | GPIOA5 | ALT5 | 0 | 38 | +-----+-----+----------+------+---+----+ Cortex-M0 flashing The second controllable unit on the muxPi board is embedded microcontroller STM32 F030C6T6 from Cortex-M0 family. It is required to flash special binary prepared by Tizen group (the code is not open yet, but this process is in progress). To flash muxPi's microcontroller, follow steps below: Make sure that VDD jumper is left open. Download binary file - link Copy binary to nanoPi: scp <path-to-file> root@192.168.4.XXX:/root/ Update package lists (nanoPi): apt-get update Install stm32flash utility (nanoPi): sudo apt-get install stm32flash Export GPIO: gpio mode 3 out and gpio mode 7 out Set Cortex-M0 to \"Flashing mode\": gpio write 7 1 Power up microcontroller: gpio write 3 1 Flash firmware: stm32flash -w firmware-05.bin -v -g 0x0 /dev/ttyS2 Power off microcontroller: gpio write 3 0 Set Cortex-M0 to \"Execution mode\": gpio write 7 0 Power on microcontroller: gpio write 3 1 From now on, muxPi's LCD should light on and display: * MuxPi * HW: 1 .0 SW: 0 .5 Software installation NOTE: It is recommended to cross-compile muxPi's software on your host machine Building using docker Prerequisites: Docker , Make . Clone repository: git clone https://github.com/SamsungSLAV/muxpi.git . Change directory: cd muxpi/sw/nanopi . Build muxPi software: make docker-build Resulting binaries will be in bin directory. Building from source Prerequisites: git , go (1.10+) Go get it: go get github.com/SamsungSLAV/muxpi Change directory: cd $GOPATH/src/github.com/SamsungSLAV/muxpi/sw/nanopi Download dependencies: go get ./... Build binaries: mkdir -p bin GOARCH = arm GOOARM = 7 GOOS = linux go build -o bin/stm ./cmd/stm/ GOARCH = arm GOOARM = 7 GOOS = linux go build -o bin/fota ./cmd/fota/ Install muxpi-power muxpi-power - tool for controling power supply for MuxPi's main board. Copy muxpi-power files (change XXX to proper values): scp power/muxpi-power root@192.168.4.XXX:/usr/bin scp power/systemd/muxpi-power.service root@192.168.4.XXX:/etc/systemd/system On your MuxPi device, enable and start muxpi-power service: systemctl enable muxpi-power.service systemctl start muxpi-power.service Install stm stm - tools/libs for communicating with STM32F030 microcontroller. Copy stm binary and systemd files (change XXX to proper values): scp bin/stm_armv7 root@192.168.4.XXX:/usr/bin/stm scp stm/systemd/stm.service root@192.168.4.XXX:/etc/systemd/system scp stm/systemd/stm-user.socket root@192.168.4.XXX:/etc/systemd/system scp stm/systemd/stm.socket root@192.168.4.XXX:/etc/systemd/system scp stm/stm root@192.168.4.XXX:/usr/local/bin/stm On your MuxPi device - create group stm and add your user: groupadd stm usermod -aG stm root On your MuxPi device - enable stm sockets: systemctl daemon-reload systemctl enable stm.socket stm-user.socket systemctl start stm.socket stm-user.socket Install fota fota - tools/libs for flashing devices - usually microSD card. Copy fota binary to MuxPi device (change XXX to proper values): scp bin/fota_armv7 root@192.168.4.XXX:/usr/bin/fota On your MuxPi device - create a symlink from /usr/local/bin/fota to /usr/bin/fota/ . Only /usr/local/bin/fota/ should be used by software interfacing with MuxPi. This allows to swap fota implementation to your preferred tool: ln -s /usr/bin/fota /usr/local/bin/fota DUT setup DUT power supply MuxPi is capable of: power switching on/off current measurement Power switching - it can switch power supply up to 5A and 250VAC. One line is connected directly and one is connected through relay. Current measurement - It is able to measure up to -/+5A and is galvanically isolated from the rest of components thanks to use of Hall effect current sensor ACS712ELCTR-05B-T. It is connected to unswitchable power line. The current sensor is bypassed with 3 0R resistors tha can be populated if current sensor is not needed. These resistors must not be populated if current measurement is required. UART connections GND - digital ground of MuxPi board N.C. - not connected Vloc - local voltage - voltage may be generated internally on MuxPi if the DUT, or anything else we are connecting to, has not power pin. Nn such case voltage generator must be set to desired value and activated. Command \"uart 3300\" must be sent to Cortex-M0, where 3300 is desired voltage given in millivolts. The voltage range is from 0 to 5000mv. Pins Vloc an VCC must be connected eachother. Typical jumper is a perfect connector for this purpose. Vloc may be also used to power up additional converter RS232C. For example if converter to RS232C (+/-12v) must be used then it may be powered from Vloc pin. VCC - power of DUT. If dut has no such power pin then it must be connected to Vloc and vloc must be configured properly as stated above. DUT RX - receiver data line in the DUT - through this line MuxPi sends data to the DUT DUT TX - transmitter data line in the DUT - from this line MuxPi reads data form the DUT DUT CTS - Clear To Send - hardware handshake DUT RTS - Ready To Send - hardware handshake Example configuration for OrangePi (DUT) uart connection: Set 3.3V Vloc (/dev/ttyS2 terminal): uart 3300 Attach UART jumper ( Vloc and Vcc ). Connect GND, RX and TX (without crossing). Open connection: screen /dev/ttyS1 115200,cs8,ixon,ixoff NOTE: RX , TX , XTS , RTS are crossed on the board so you don't need to cross the wires by yourself. NOTE: A device powered from Vloc mustn't draw more than 50mA of current. Add-ons Add-ons headers are extensions for attaching new shields or simply using NanoPi and CortexM0 interfaces: 5V - power supply - not switchable - always present 3V3 - switchable (controlled by NanoPi) 3.3V power supply I2C0 SDA - I2C0 SDA line connected to NanoPi I2C0 SCL - I2C0 SCL line connected to NanoPi DBG UART TX - UART0 (debug) of NanoPi DBG UART RX - UART0 (debug) of NanoPi USB B+/- , USB A+/- USB host lines connected to NanoPi through USB HUB GND - ground lines N.C . - not connected SPI0 CLK - SPI0 clock line connected to NanoPi SPI0 MOSI - SPI0 \"master output slave input\" line connected to NanoPi SPI0 CS - SPI0 \"chip select\" line connected to NanoPi SPI0 MISO - SPI0 \"master input slave output\" line connected to NanoPi PI GPIO 1,2,3 - GPIO (General Purpose Input/Output) connected to NanoPi NEO. Ports PG11, PL11, PA17 respectively. ST GPIO 1,2,3 - GPIO connected to Cortex-M0 microcontroller. Ports PB3, PB4, PB5 of STM32F03C6T6 respectively. ADC1,2 - analog inputs connected to analog to digital converter of Cortex-M0 microcontroller. Ports PA1, PA2 respectively. Voltage range of this input is 0 to 3.3V. This lines are not buffered in any way so attention must paid when dealing with them. GND - ground lines NOTE: PI GPIO 1 has additional special function. It is connected to Cortex-M0 Boot0 pin which enables firmware download mode during microcontroller boot. 1 - enables this mode while 0 disables it. So it is useless as GPIO when the microcontroller is being booted. DyPers Dyper is a small, electromagnetic relay which is controllable by software. There are 2 dypers on MuxPi board. Each of them has two channels. Both channels are switched at the same time with the same command. So both of them can be on and both can be off but there is no way to turn one on and one off. They can be controlled by CortexM0 - examples here . ETH and USB ETH and upper USB of double USB socket share the same USB channel from USB HUB. Jumpers located at the rear side of double USB connector allow to disconnect this USB from ETH and connect to add-on connector. Details on this topic are covered in jumpers section. USB-M This is USB connector dedicated to mobile devices from Samsung company. This connector has controllable Vbus line and also controllable ID line. More information about this type of interface, it's capabilities and example of flashing smartphone can be found here . SD Adapter This connector is used to connect microSD card, put into MuxPi, to a DUT. This connector requires IDC-uSD cable adapter: Target microSD card must be attached to microSD card reader accessible on bottom side of muxPi board. To enable microSD card reader, connect to Cortex from MuxPi via minicom: minicom -D /dev/ttyS2 and enter in minicom following commands: ts and then: dut Each command should return OK After doing this you can connect the uSD's end of the cable adapter to the external card reader and check if it is correctly recognized by PC. You should also be able to run the microcontroller from the card attached to MuxPi if the card contains appropriate OS. Interacting with muxPi Connection with NanoPi User can simply open SSH connection by (password: fa ): ssh root@<muxpi-ip-address> or use serial connection mentioned here NOTE: Connecting with MuxPi through serial will automatically login as non root user pi with password pi . User interface Features operable directly via NanoPi GPIOs: #Pin (board) #WiringNP Description Low state \"0\" High state \"1\" 12 1 LED1 LED off LED on 13 2 LED2 LED off LED on 15 3 Power (Cortex m0) Power off Power on 7 7 Boot (Cortex m0) Execution mode Flashing mode NOTE: Initially, above GPIOs are not exported. Set GPIOs mode with gpio mode <#WiringNP> out . Example LED1 control: LED1 on: gpio write 1 1 LED1 off: gpio write 1 0 Example of flashing Cortex-M0 is described here . The microcontroller is connected to NanoPi NEO with UART. This UART is connected to third UART of NanoPi - /dev/ttyS2. The port is configured to 115200,8,N1 and cannot be changed without modification of the firmware. The protocol is text based, simple and human readable. Each command has to be ended with 'n' or 'r' character. Each command is confirmed with 'OK' string or error string. It is recommended to use screen program for communication: Install screen: sudo apt-get install screen Open connection (from muxPi): screen /dev/ttyS2 115200,cs8,ixon,ixoff Write help and press Enter . Features operable through Cortex-M0 microcontroller (help output): help --- This help version --- Display version of the firmware echo --- Get ( no arguments ) or set ( 'on' or 'off' ) echo on serial \"console\" : echo [ on | off ] . The default value is on. power --- Get ( no arguments ) or set ( 'on' or 'off' ) or switch off and on ( 'tick' ) power supply for DUT: power [ on | off | tick ] hdmi --- Get ( no arguments ) or set ( 'on' or 'off' ) HDMI HOTPLUG pin: hdmi [ on | off ] dyper --- Get ( no second argument ) or set ( 'on' or 'off' ) DyPer state: dyper 1 | 2 [ on | off ] mux --- Connect microSD card to external connector ( DUT ) or card reader ( ts ) : mux [ dut | ts ] dut --- Connect microSD card and power to DUT: dut ts --- Connect microSD card and power to TS: ts led --- Get ( no second or third argument ) or set ( 'R G B' ) color of led ( 1 | 2 ) , ex: led 1 255 0 255 clr --- Clear oled display text --- Print text on the OLED display: text x y color content draw --- Draw an object on the OLED display: draw object x1 y1 [ x2 y2 ] , objects are: - point x y color - draws one point at given coordinates - line x1 y1 x2 y2 color - draws line between given coordinates - rectangle left top width height color - draws line between given coordinates - circle x y radius color - draws line between given coordinates color must be 'on' , 'off' or 'inv' adc --- Print current adc value of all ( if no arguments are given ) or one specified channel, ex: adc 1 voltage --- Print current voltage [ mV ] of all ( if no arguments are given ) or one specified channel, ex: voltage 1 current --- Print current current [ mA ] being consumed by DUT lthor --- Get ( no second argument ) or set state of lthor control signals: - lthor switch [ usb | uart ] - redirect DUT 's USB wires to NanoPi' s 'usb' or 'uart' - lthor id [ usb | uart ] - switch DUT 's USB to ' usb ' or ' uart ' mode - lthor vbus [on|off] - switch DUT' s VBUS 'on' or 'off' - lthor combo [ usb | uart ] - make DUT and MuxPi USB work in 'usb' or 'uart' mode - no get function key --- Get current state of given key or both if no key number is given: key [ 1 | 2 ] uart --- Get current value of UART voltage or set if new value is given [ in millivolts ] Images source: Wiki Tizen","title":"Theory of Operations"},{"location":"transparent-validation/muxpi/theory-of-operations/#muxpi-theory-of-operations","text":"","title":"MuxPi - Theory of Operations"},{"location":"transparent-validation/muxpi/theory-of-operations/#block-diagram","text":"","title":"Block diagram"},{"location":"transparent-validation/muxpi/theory-of-operations/#muxpi-setup","text":"","title":"muxPi setup"},{"location":"transparent-validation/muxpi/theory-of-operations/#software-installation","text":"NOTE: It is recommended to cross-compile muxPi's software on your host machine","title":"Software installation"},{"location":"transparent-validation/muxpi/theory-of-operations/#dut-setup","text":"","title":"DUT setup"},{"location":"transparent-validation/muxpi/theory-of-operations/#interacting-with-muxpi","text":"","title":"Interacting with muxPi"},{"location":"transparent-validation/rte/introduction/","text":"RTE Introduction RTE is certified Open Source Hardware , so based on published schematics you can build and modify PCB yourself. RTE is a hat designed for Orange Pi Zero board which runs specially crafted Linux distribution using the Yocto Project. RTE boards are used for controlling Device Under Test fully remotely through the network interface. Most common applications are: debugging tasks, flashing firmware, controlling GPIOs power management for Device Under Test . Where to buy? RTE can be also bought in our 3mdeb shop . Full Remote Testing Environment set includes: Category Description Quantity shield Remote Testing Environment v1.1.0 1 control unit Orange Pi Zero 256MB RAM version 1 power supply MicroUSB 5V/2A 1 storage SanDisk 16GB microSD card (with preinstalled compatible system) 1 clip Pomona 8-pin SOIC clip for Device Under Test SPI interface 1 cables standard female-female connection wire 2.56mm raster 8 cables IDC 8-pin wires for Device Under Test SPI interface 1 cables DC Jack - DC Jack power cable for Device Under Test 1 cables RS232 D-Sub 9P/9P cable for serial communication 1 jumpers jumper for UART OUTPUT SELECT header 2 spacers Polyamide M3 spacers and bolts 4 Why choose 3mdeb RTE? high accessibility and flexibility test your device from any location. efficiency simplify validation: write one script and run it on unlimited platforms. Don\u2019t repeat yourself! independent development open hardware license: modify, upgrade and set it as you like. All blueprints are at your disposal. instant setup intuitive connection: you do not need to be a certified engineer. automation time is money: let the machine do all the work for you","title":"Introduction"},{"location":"transparent-validation/rte/introduction/#rte-introduction","text":"RTE is certified Open Source Hardware , so based on published schematics you can build and modify PCB yourself. RTE is a hat designed for Orange Pi Zero board which runs specially crafted Linux distribution using the Yocto Project. RTE boards are used for controlling Device Under Test fully remotely through the network interface. Most common applications are: debugging tasks, flashing firmware, controlling GPIOs power management for Device Under Test .","title":"RTE Introduction"},{"location":"transparent-validation/rte/introduction/#where-to-buy","text":"RTE can be also bought in our 3mdeb shop . Full Remote Testing Environment set includes: Category Description Quantity shield Remote Testing Environment v1.1.0 1 control unit Orange Pi Zero 256MB RAM version 1 power supply MicroUSB 5V/2A 1 storage SanDisk 16GB microSD card (with preinstalled compatible system) 1 clip Pomona 8-pin SOIC clip for Device Under Test SPI interface 1 cables standard female-female connection wire 2.56mm raster 8 cables IDC 8-pin wires for Device Under Test SPI interface 1 cables DC Jack - DC Jack power cable for Device Under Test 1 cables RS232 D-Sub 9P/9P cable for serial communication 1 jumpers jumper for UART OUTPUT SELECT header 2 spacers Polyamide M3 spacers and bolts 4","title":"Where to buy?"},{"location":"transparent-validation/rte/introduction/#why-choose-3mdeb-rte","text":"high accessibility and flexibility test your device from any location. efficiency simplify validation: write one script and run it on unlimited platforms. Don\u2019t repeat yourself! independent development open hardware license: modify, upgrade and set it as you like. All blueprints are at your disposal. instant setup intuitive connection: you do not need to be a certified engineer. automation time is money: let the machine do all the work for you","title":"Why choose 3mdeb RTE?"},{"location":"transparent-validation/rte/pcengines/","text":"How to connect RTE to PC Engines?","title":"RTE and PC Engines"},{"location":"transparent-validation/rte/pcengines/#how-to-connect-rte-to-pc-engines","text":"","title":"How to connect RTE to PC Engines?"},{"location":"transparent-validation/rte/revision-history/","text":"Revision history v1.1.0 added Open hardware logo added SW1 reset button added D5 relay state LED indicator added J16 2x3pin UART OUTPUT SELECT header added J18 1x2pin UART1 header added 1.8V stabilizer populated SPI Vcc pin modified capacitors near MAX3232 SOIC reduced OC buffers GPIO header (J11) from 12 to 9 pin eliminated issue with J6 USB port (unreliable detection of USB devices) v1.0.0 added RoHS logo added Crossed Wheelie Bin logo modified footprints of the pin headers v0.5.3 enlarged added holes v0.5.2 modified I2C GPIO expander outputs connections (now 4 of them are connected to the dedicated header) modified version number on board removed SPI header for APU recovery with output pin role information labels removed 7 and 8 pin of SPI header with GPIO expander connection v0.5.1 added micro USB connector for power supply added 5 V power supply pins added SPI connector for APU SPI recovery added fiducials on the bottom layer added pins information labels modified relay control system elements placement modified SPI connector for APU paths placement modified project text descriptions removed 2 pin GPIO expander connector v0.5 added 5 V power supply signal diode (red) + limiting current resistor added 3.3 V power supply signal diode (orange) + limiting current resistor relay NO/NC connection switched to the previous configuration switched SPI1_MISO with SPI1_MOSI output mirrored RS232 socket pads removed I2C pull-up resistors v0.3.6 relay NO/NC connection switched v0.3.5 enlarged the hole diameter by 0.1 mm v0.3.4 added 3mdeb logo and board name on PCB modified elements marks placing v0.3.3 added SPI output IO pins connection with GPIO added PCB mechanical schematic added I2C INT pins connection added mounting holes added fiducials modified MOSFET transistor pinout numeration modified USB footprint from horizontal to vertical modified I2C GPIO expander with OC buffers connection v0.3.2 added mounting holes modified relay pinout removed I2C to GND connection v0.3.1 modified power supply from 5V to 3V3 for I2C bus MCP23017 , and MAX3232 removed capacitors connected to the I2C bus v0.3 added I2C bus with output header added MCP23017 I2C GPIO expander added second SN74LS06 OC buffer added relay with required neighboring items added MAX3232 RS232 electrical level changer added RS232 socket added GPIO output header for pins unused to OC buffer control modified some of input pins connection removed ARK joint for the relay module removed header for relay module control","title":"Revision History"},{"location":"transparent-validation/rte/revision-history/#revision-history","text":"","title":"Revision history"},{"location":"transparent-validation/rte/revision-history/#v110","text":"added Open hardware logo added SW1 reset button added D5 relay state LED indicator added J16 2x3pin UART OUTPUT SELECT header added J18 1x2pin UART1 header added 1.8V stabilizer populated SPI Vcc pin modified capacitors near MAX3232 SOIC reduced OC buffers GPIO header (J11) from 12 to 9 pin eliminated issue with J6 USB port (unreliable detection of USB devices)","title":"v1.1.0"},{"location":"transparent-validation/rte/revision-history/#v100","text":"added RoHS logo added Crossed Wheelie Bin logo modified footprints of the pin headers","title":"v1.0.0"},{"location":"transparent-validation/rte/revision-history/#v053","text":"enlarged added holes","title":"v0.5.3"},{"location":"transparent-validation/rte/revision-history/#v052","text":"modified I2C GPIO expander outputs connections (now 4 of them are connected to the dedicated header) modified version number on board removed SPI header for APU recovery with output pin role information labels removed 7 and 8 pin of SPI header with GPIO expander connection","title":"v0.5.2"},{"location":"transparent-validation/rte/revision-history/#v051","text":"added micro USB connector for power supply added 5 V power supply pins added SPI connector for APU SPI recovery added fiducials on the bottom layer added pins information labels modified relay control system elements placement modified SPI connector for APU paths placement modified project text descriptions removed 2 pin GPIO expander connector","title":"v0.5.1"},{"location":"transparent-validation/rte/revision-history/#v05","text":"added 5 V power supply signal diode (red) + limiting current resistor added 3.3 V power supply signal diode (orange) + limiting current resistor relay NO/NC connection switched to the previous configuration switched SPI1_MISO with SPI1_MOSI output mirrored RS232 socket pads removed I2C pull-up resistors","title":"v0.5"},{"location":"transparent-validation/rte/revision-history/#v036","text":"relay NO/NC connection switched","title":"v0.3.6"},{"location":"transparent-validation/rte/revision-history/#v035","text":"enlarged the hole diameter by 0.1 mm","title":"v0.3.5"},{"location":"transparent-validation/rte/revision-history/#v034","text":"added 3mdeb logo and board name on PCB modified elements marks placing","title":"v0.3.4"},{"location":"transparent-validation/rte/revision-history/#v033","text":"added SPI output IO pins connection with GPIO added PCB mechanical schematic added I2C INT pins connection added mounting holes added fiducials modified MOSFET transistor pinout numeration modified USB footprint from horizontal to vertical modified I2C GPIO expander with OC buffers connection","title":"v0.3.3"},{"location":"transparent-validation/rte/revision-history/#v032","text":"added mounting holes modified relay pinout removed I2C to GND connection","title":"v0.3.2"},{"location":"transparent-validation/rte/revision-history/#v031","text":"modified power supply from 5V to 3V3 for I2C bus MCP23017 , and MAX3232 removed capacitors connected to the I2C bus","title":"v0.3.1"},{"location":"transparent-validation/rte/revision-history/#v03","text":"added I2C bus with output header added MCP23017 I2C GPIO expander added second SN74LS06 OC buffer added relay with required neighboring items added MAX3232 RS232 electrical level changer added RS232 socket added GPIO output header for pins unused to OC buffer control modified some of input pins connection removed ARK joint for the relay module removed header for relay module control","title":"v0.3"},{"location":"transparent-validation/rte/v1.1.0/getting-started/","text":"RTE Getting Started Canonical example of RTE usage is hooking it to some hardware for SPI flashing, power control and serial logs gathering. Please follow theory of operation guide to understand how you can hook RTE to various hardware platforms. PC Engines","title":"Getting Started"},{"location":"transparent-validation/rte/v1.1.0/getting-started/#rte-getting-started","text":"Canonical example of RTE usage is hooking it to some hardware for SPI flashing, power control and serial logs gathering. Please follow theory of operation guide to understand how you can hook RTE to various hardware platforms. PC Engines","title":"RTE Getting Started"},{"location":"transparent-validation/rte/v1.1.0/reference-os/","text":"Dasharo RTE Reference OS Our specially crafted operating system fully customized for Remote Testing Environment platform aspects. meta-rte is based on open-source project - Yocto Project used for building Linux-based systems regardless of the hardware architecture. meta-rte has most mandatory tools and dependencies required for everyday debugging task with various range of hardware. RTE running meta-rte is ready to use completely out of the box, without the need for additional laborious configuration. Moreover, open-source solutions such as the Yocto Project and meta-rte provides possibility to rebuild the whole system strictly for the end users requirements, making the whole set more universal with endless applications! More information can be found in meta-rte repository","title":"RTE Reference OS"},{"location":"transparent-validation/rte/v1.1.0/reference-os/#dasharo-rte-reference-os","text":"Our specially crafted operating system fully customized for Remote Testing Environment platform aspects. meta-rte is based on open-source project - Yocto Project used for building Linux-based systems regardless of the hardware architecture. meta-rte has most mandatory tools and dependencies required for everyday debugging task with various range of hardware. RTE running meta-rte is ready to use completely out of the box, without the need for additional laborious configuration. Moreover, open-source solutions such as the Yocto Project and meta-rte provides possibility to rebuild the whole system strictly for the end users requirements, making the whole set more universal with endless applications! More information can be found in meta-rte repository","title":"Dasharo RTE Reference OS"},{"location":"transparent-validation/rte/v1.1.0/specification/","text":"RTE elements UART0 header - 1x3 Orange Pi Zero system debug output and console (pins: RX , TX , GND ). SPI header - 2x4 standard 2.5mm IDC compatible header with all necessary signals to flash SPI chips. Orange Pi Zero GPIO - 1x3 GPIO pin header directly connected to Orange Pi zero platform. I2C header - 1x4 populated pins: 3.3V , SCK , SDA , GND . OC buffers output - 1x12 GPIO pin header connected to Open Collector buffers. DUT power control connectors - 2x DC jack 5.5/2.1mm female connectors for a Device Under Test power supply controlled directly through the relay. Reset button - Simple switch to reset RTE RS232 - DB9 male connector for RS232 communication with a hardware flow control. UART output select header 2x3 UART OUTPUT SELECT header destined for selecting serial output between UART1 header and DB9 RS232 connector. UART1 header - 1x3 UART header for 3V3 serial communication with DUT (pins: RX , TX , GND ). 2x USB connectors - Connect additional storages, external flash programmers, USB-RS232 or USB-UART converters. 5V header - 1x2 5V output populated pins: 5V , GND . expander GPIO - 1x4 GPIO pin header connected to GPIOs expander with no OC buffers. Relay - Controls Device Under Tests power supply micro USB connector - Connector for powering up RTE and OrangePi Zero setup. Product features Key features Cheaper and more feature-rich in comparison to other products Ultra-fast SPI flashing (16MHz) In-Circuit Programming (program onboard SPI Flash) Pomona connector to work with Serial Flash soldered on board Two logic levels SPI (1.8V and 3.3V) Remote power control over the target device Open Hardware Open Source software attached Open Source REST API controller Cost-free future software improvements RteCtrl: Web interface RteCtrl is a REST API controller used for RTE board. It comes with meta-rte operating system and starts automatically on port 8000 without the necessity of additional configuration. REST API dashboard can be reached through the Internet browser and provides a possibility to: control Device Under Test power supply (coldboot and warmboot) reset Device Under Test platform flash Device Under Test firmware More information can be found at RteCtrl repository DISCLAIMER: Before starting the flashing procedure through REST API console, make sure that appropriate SPI logic levels are set accordingly to SPI section. Specification GPIO header (1) First GPIO header ( J1 ) is a 1x3 pin header straight type 2.54mm pitch. It is derived directly from Orange Pi GPIOs for general use. By default, these GPIOs are set to INPUT mode. Maximum voltage for all data signals: 3.3 V. Description Pin # GPIO12 1 GPIO11 2 GPIO6 3 GPIO header (2) Second GPIO header ( J10 ) is a 1x4 pin header straight type 2.54mm pitch. It is derived from GPIO expander on RTE board. They are accessible for general use. By default, these GPIOs are set to INPUT mode. Maximum voltage for all data signals: 3.3 V. Expander GPIO: 25 mA maximum output current. Description Pin # GPIO400 1 GPIO401 2 GPIO402 3 GPIO403 4 GPIO header (3) Third GPIO header ( J11 ) is a 1x9 pin header straight type 2.54mm pitch. It is derived from GPIO expander on RTE board with an additional connection to OC (Open Collector) buffers. By default, these GPIOs are set to OUTPUT mode. Maximum voltage for all data signals: 3.3 V. OC buffers: 40 mA maximum output current. Description Pin # GPIO407 1 GPIO415 2 GPIO414 3 GPIO408 4 GPIO409 5 GPIO410 6 GPIO411 7 GPIO412 8 GPIO413 9 I2C header I2C header ( J9 ) is 1x4 pin header straight type 2.54mm pitch. It is used to rather low-speed applications such as reading sensors or accessing DACs and ADCs. Maximum voltage for all data signals: 3.3 V. Description Pin # 3V3 1 SCK 2 SDA 3 GND 4 SPI header SPI header ( J7 ) is a 2x4 pin header straight type 2.54mm pitch. It is used to control the application SPI flash with a minimal set of connections. Maximum voltage for all data signals: 3.3 V. Description Pin # Pin # Description Vcc 1 2 GND CS 3 4 SCLK MISO (SO) 5 6 MOSI (SI) ISP 7 8 NC Revision v1.1.0 features new possibilities for SPI configuration: SPI Vcc pin has been populated - power is now supplied to the SPI Vcc connector and can be enabled/disabled on demand: GPIO406 (OC_OUT1) state SPI Vcc 0 - low disabled (by default) 1 - high enabled user can choose the voltage level for Vcc SPI - either 1.8V or 3.3 V: GPIO405 (OC_OUT2) state SPI Vcc voltage level 0 - low 1.8 V (by default) 1 - high 3.3 V user can enable/disable SPI lines (some platforms have problems when booting with SPI wires connected): GPIO404 (OC_OUT3) state SPI lines (MOSI/MISO/CS/SCLK) 0 - low disabled (by default) 1 - high enabled UART OUTPUT SELECT header UART OUTPUT SELECT header ( J16 ) is a 2x3 pin header straight type 2.54mm pitch. It is used for enabling serial communication output: RS232 DB9 port ( J14 ) or UART1 header ( J18 ). If jumpers are not attached, serial ports are disabled. Jumper position (TX) Jumper position (RX) Serial communication enabled RS232 + COM RS232 + COM RS232 DB9 port (J14) EXT + COM EXT + COM 3.3V UART1 header (J18) RS232 connector RS232 connector ( J14 ) is a DB9 male 9 pin connector for serial communication between Remote Testing Environment and Device Under Test platform. It supports a hardware flow control. RS232 connector can be enabled/disabled according to UART OUTPUT SELECT section. Pin # Signal Description 1 DCD Data Carrier Detect 2 RXD Receive Data 3 TXD Transmit Data 4 DTR Data Terminal Ready 5 GND Signal Ground 6 DSR Data Set Ready 7 RTS Request to Send 8 CTS Clear to Send 9 RI Ring Indicator UART0 header UART0 header ( J2 ) is a 1x3 pin header straight type 2.54mm pitch. It is derived from Orange Pi Zero serial debug UART for debugging and serial communication purposes. Maximum voltage for all data signals: 3.3 V. Description Pin # GND 1 RX 2 TX 3 UART1 header UART1 header ( J18 ) is a 1x3 pin header straight type 2.54mm pitch. It is used for serial communication with DUT. UART1 header can be enabled/disabled according to UART OUTPUT SELECT section. Maximum voltage for all data signals: 3.3 V. Description Pin # GND 1 RX 2 TX 3 Power output header Power output header ( J15 ) is 1x2 pin header straight type 2.54mm pitch. It is used for additional 5V or ground pin connections with various devices. .pure-table[ | Description | Pin # | |:-----------:|:-----:| | 5V | 1 | | GND | 2 |] DC jack Two DC Jacks ( J12 and J13 ) are 5.5/2.1mm female plug connectors used for Device Under Test power supply. The output from DC Jacks is controlled through a relay. There is no matter whether J12 or J13 plug is input/output for power supply. Relay Relay ( K1 ) is a mechanical switch for controlling Device Under Test power supply. Technical reference: 1 Form C (1PDT) contact arrangement 5 V coil nominal voltage 70 Ohms nominal resistance 72 mA nominal current 24 VDC maximal input voltage 10 A maximal input voltage Expected relay life: 100 000 operations Relay state is indicated by LED ( D5 ) located near relay and can be controlled via meta-rte operating system through GPIO199: GPIO199 state Relay state D5 LED state 0 OFF OFF 1 ON ON USB connectors USB connectors ( J6 , J8 ) available on RTE are additional USB type A ports derived from Orange Pi Zero header. They can be used for storage extension, serial communication through various adapters or USB programmer extension. microUSB connector The micro USB connector ( J17 ) is a USB B micro socket for powering up RTE and OrangePi Zero setup. It is required to use a 5V/2A power adapter. There is no difference whether the user plugs the power supply to the micro USB connector located on RTE board or use OrangePi Zero original socket. Reset button Reset button ( SW1 ) located near relay is used for resetting the RTE itself. FAQ How to set GPIO states to flash SPI: Set proper SPI Vcc Voltage: Adequate Vcc voltege is neccesary for succesfull flash procedure. If it will be to low chip will not recognize any signals, if too high chip will be damaged. echo 0 > /sys/class/gpio/gpio405/value Or when flash chip operates on 3.3V: echo 1 > /sys/class/gpio/gpio405/value Enable SPI Vcc: echo 1 > /sys/class/gpio/gpio406/value Enable SPI signals: echo 1 > /sys/class/gpio/gpio404/value Flash SPI chip: flashrom -w /path/to/coreboot.rom -p linux_spi:dev = /dev/spidev1.0,spispeed = 16000 When done, change back all states: echo 0 > /sys/class/gpio/gpio405/value echo 0 > /sys/class/gpio/gpio406/value echo 0 > /sys/class/gpio/gpio404/value","title":"Specification"},{"location":"transparent-validation/rte/v1.1.0/specification/#rte-elements","text":"UART0 header - 1x3 Orange Pi Zero system debug output and console (pins: RX , TX , GND ). SPI header - 2x4 standard 2.5mm IDC compatible header with all necessary signals to flash SPI chips. Orange Pi Zero GPIO - 1x3 GPIO pin header directly connected to Orange Pi zero platform. I2C header - 1x4 populated pins: 3.3V , SCK , SDA , GND . OC buffers output - 1x12 GPIO pin header connected to Open Collector buffers. DUT power control connectors - 2x DC jack 5.5/2.1mm female connectors for a Device Under Test power supply controlled directly through the relay. Reset button - Simple switch to reset RTE RS232 - DB9 male connector for RS232 communication with a hardware flow control. UART output select header 2x3 UART OUTPUT SELECT header destined for selecting serial output between UART1 header and DB9 RS232 connector. UART1 header - 1x3 UART header for 3V3 serial communication with DUT (pins: RX , TX , GND ). 2x USB connectors - Connect additional storages, external flash programmers, USB-RS232 or USB-UART converters. 5V header - 1x2 5V output populated pins: 5V , GND . expander GPIO - 1x4 GPIO pin header connected to GPIOs expander with no OC buffers. Relay - Controls Device Under Tests power supply micro USB connector - Connector for powering up RTE and OrangePi Zero setup.","title":"RTE elements"},{"location":"transparent-validation/rte/v1.1.0/specification/#product-features","text":"","title":"Product features"},{"location":"transparent-validation/rte/v1.1.0/specification/#specification","text":"","title":"Specification"},{"location":"transparent-validation/sd-wire/getting-started/","text":"SDWire is a small board with two features SD card reader SD card MUX SDWire allows to flash SD card connected to the DUT (Device Under Test), without physical contact with the device. There is only one micro USB socket for connecting to host PC. Both USB mass storage and MUX control are served through the same USB connection. The PCB board is designed in such way that it fits into micro SD card slots. Thanks to this, there is no need for special cables with a micro SD adapter , like in the muxPi product .","title":"Getting started"},{"location":"transparent-validation/sd-wire/getting-started/#sdwire-is-a-small-board-with-two-features","text":"SD card reader SD card MUX SDWire allows to flash SD card connected to the DUT (Device Under Test), without physical contact with the device. There is only one micro USB socket for connecting to host PC. Both USB mass storage and MUX control are served through the same USB connection. The PCB board is designed in such way that it fits into micro SD card slots. Thanks to this, there is no need for special cables with a micro SD adapter , like in the muxPi product .","title":"SDWire is a small board with two features"},{"location":"transparent-validation/sd-wire/specification/","text":"Hardware design Design of this board is based on SD MUX . SDWire does not have power switch or USB switch but has built in USB SD card reader. SD card multiplexer itself is exactly the same in both devices. There are four LEDs on the board: red - power presence from USB blue - USB reader activity blue - card connected to TS ( Test Server ) green - card connected to DUT ( Device Under Test ) All LEDs are present on both sides of the board to make them visible no matter which side of the board will be facing you. LED positions are showed in the image below. Source: wiki.tizen.org PCB elements and scheme Source: wiki.tizen.org","title":"Specification"},{"location":"transparent-validation/sd-wire/specification/#hardware-design","text":"Design of this board is based on SD MUX . SDWire does not have power switch or USB switch but has built in USB SD card reader. SD card multiplexer itself is exactly the same in both devices. There are four LEDs on the board: red - power presence from USB blue - USB reader activity blue - card connected to TS ( Test Server ) green - card connected to DUT ( Device Under Test ) All LEDs are present on both sides of the board to make them visible no matter which side of the board will be facing you. LED positions are showed in the image below. Source: wiki.tizen.org","title":"Hardware design"},{"location":"transparent-validation/sd-wire/specification/#pcb-elements-and-scheme","text":"Source: wiki.tizen.org","title":"PCB elements and scheme"},{"location":"transparent-validation/sd-wire/usage-validation/","text":"SDWire usage Environment preparation SDWire has dedicated software which is a simple tool meant to control the hardware. Source code of the tool is published on tizen git server. This is simple to use, command-line utility software written in C and based on open-source libFTDI library. To prepare the environment reproduce the following steps: Clone the repository: git clone https://git.tizen.org/cgit/tools/testlab/sd-mux Check whether the installation requirements for sd-mux are met: libftdi1 1.4 development library is installed. To do this, open the terminal and type the following command: dpkg -L libftdi1-dev If the library is installed, after typing the above command you will see information about the paths to the library components. * popt development library is installed. To do this, open the terminal and type the following command: dpkg -L libpopt-dev If the library is installed, after typing the above command you will see information about the paths to the library components. * cmake binary tool is installed. To do this, open the terminal and type the following command: cmake --version If the tool is installed, after typing the above command you will see information about the installed on your computer cmake version. If any above-mentioned requirements are not met - go to point 3. If they are met - go to point 4. Install missing libraries and/or tools: libftdi1 1.4 development library. To do this, open the terminal and type the following command: sudo apt-get install libftdi1-dev popt development library. To do this, open the terminal and type the following command: sudo apt-get install libpopt-dev cmake binary tool. To do this, open the terminal and type the following command: sudo apt-get install cmake Enter into sd-mux project directory and reproduce the following steps to build project: open directory in terminal create 'build' directory by the following command: mkdir build enter into 'build' directory by the following command: cd build run the following commands one by one: cmake .. make In the above-described directory ( sd-mux/build ) run the following command to build binary: sudo make install Note, that the above-described command installs binary into '/usr/local/bin'. If you want to install files in directory rather than the default one add an argument to cmake command: cmake -DCMAKE_INSTALL_PREFIX = /usr .. Then it is obligatory to run again the following commands: make make install First use The following procedure should be performed not only before the first use of the device, but also as the presale validation procedure! Hardware requirements: SDWire SD card DUT (Device Under Test) bootable from SD card (for example: RPI, Orange PI etc.) DUT power supply Micro-USB --> USB cable TS (Test Server) - in most cases personal computer with prepared environment. To perform first use (assuming Raspberry Pi platform as a DUT) procedure reproduce the following steps: Prepare environment in accordance with this section . Insert SD card to the SDWire. Put SDWire into the DUT (Device Under Test). Prepare a micro USB --> USB cable. It will be used to connect SDWire to TS (Test Server). Check whether SDWire is configured by reproducing the following steps: run in TS terminal the following command: dmesg -w connect the SDWire to your machine using micro-USB --> USB cable. after connecting your dmesg output should looks like this: ( ... ) [ 73278 .307591 ] usb-storage 3 -1.1:1.0: USB Mass Storage device detected [ 73278 .307823 ] scsi host6: usb-storage 3 -1.1:1.0 [ 73278 .384925 ] usb 3 -1.2: new full-speed USB device number 45 using xhci_hcd [ 73278 .492025 ] usb 3 -1.2: New USB device found, idVendor = 0403 , idProduct = 6015 , bcdDevice = 10 .00 [ 73278 .492027 ] usb 3 -1.2: New USB device strings: Mfr = 1 , Product = 2 , SerialNumber = 3 [ 73278 .492028 ] usb 3 -1.2: Product: FT200X USB I2C [ 73278 .492029 ] usb 3 -1.2: Manufacturer: FTDI [ 73278 .492030 ] usb 3 -1.2: SerialNumber: DB007V7V ( ... ) open new terminal window and run the following command: sudo sd-mux-ctrl --list If output looks like below, it means that SDWire is configured and ready to use. Now, you can go to point 6 in this section. Number of FTDI devices found: 1 Dev: 0 , Manufacturer: SRPOL, Serial: sd-wire_11, Description: sd-wire Otherwise, if output shows no devices (like in the example below): Number of FTDI devices found: 0 you have to configure SDWire: sudo sd-mux-ctrl --device-serial = DB007V7V --vendor = 0x0403 --product = 0x6015 --device-type = sd-wire --set-serial = sd-wire_11 where: --device-serial = <SerialNumber> ( from dmesg output ) --vendor = 0x<idVendor> ( from dmesg output ) --product = 0x<idProduct> ( from dmesg output ) --set-serial = <New serial device> After above-desribed procedure check again if SDWire is properly configured: sudo sd-mux-ctrl --list Should output: Number of FTDI devices found: 1 Dev: 0 , Manufacturer: SRPOL, Serial: sd-wire_11, Description: sd-wire Connect SD card to the TS (Test Server): sudo sd-mux-ctrl --device-serial = sd-wire_11 --ts Flash the SD card using bmaptool or balenaEtcher. download the OS image for the target DUT - link for RPi image to do this by balenaEtcher go to the producer site and follow his procedure how to download and flash SD card to do this by bmaptool reproduce the following steps: install bmaptool by opening terminal and typing the following command: sudo apt install bmap-tools create the bmap by typing the following command: bmaptool create /path/to/your/image > /path/where/you/want/bmap/file/saved/bmapfilename.bmap flash image to the SD card by typing the following command: sudo bmaptool copy --bmap ~/path/where/your/bmap/file/is/located /path/where/your/image/is/located /path/to/memory/device Connect SD card to the DUT using sd-mux-ctrl : sudo sd-mux-ctrl --device-serial = sd-wire_11 --dut Connect power supply to the DUT and check if it boots properly from newly burned image. Everyday use scenario Disconnect power supply from the DUT (Device Under Test). Disconnect micro SD card from the DUT. Connect micro SD card to the TS (Test Server) using card reader. Flash the SD card. Connect SD card to the DUT. Connect power supply to the DUT. Boot DUT from new image. Using SDWire there is no need to disconnect SD card from DUT. SDWire with RTE use scenario Insert SD card to the SDWire. Insert SDWire into the DUT and connect it to the TS with micro-USB --> USB cable. Connect RTE power control connectors to the DUT (RTE here is optional but highly recommended for remote work, because it helps with automated and remote power control of the connected device). Check serial no. of SDWire: sudo sd-mux-ctrl --list Output: Number of FTDI devices found: 1 Dev: 0 , Manufacturer: SRPOL, Serial: sd-wire_11, Description: sd-wire Disconnect power supply using RTE. Connect SD card to the TS (using sd-mux-ctrl) sudo sd-mux-ctrl --device-serial = sd-wire_11 --ts Flash the SD card using bmaptool or balenaEtcher as described in the First use section Connect SD card to the DUT (using sd-mux-ctrl) sudo sd-mux-ctrl --device-serial = sd-wire_11 --dut Connect power supply using RTE. DUT should boot from freshly burned SD card. Command sudo sd-mux-ctrl --device-serial=sd-wire_11 --status returns information if SDWire is connected to DUT or TS. \u279c ~ sudo sd-mux-ctrl --device-serial = sd-wire_11 --status SD connected to: TS At the moment RTE does not support sd-mux-ctrl, so SDWire must be controlled from configured TS (Test Server). References: https://wiki.tizen.org/SD_MUX https://wiki.tizen.org/SD_MUX/manpage","title":"Usage"},{"location":"transparent-validation/sd-wire/usage-validation/#sdwire-usage","text":"","title":"SDWire usage"},{"location":"transparent-validation/sd-wire/usage-validation/#environment-preparation","text":"SDWire has dedicated software which is a simple tool meant to control the hardware. Source code of the tool is published on tizen git server. This is simple to use, command-line utility software written in C and based on open-source libFTDI library. To prepare the environment reproduce the following steps: Clone the repository: git clone https://git.tizen.org/cgit/tools/testlab/sd-mux Check whether the installation requirements for sd-mux are met: libftdi1 1.4 development library is installed. To do this, open the terminal and type the following command: dpkg -L libftdi1-dev If the library is installed, after typing the above command you will see information about the paths to the library components. * popt development library is installed. To do this, open the terminal and type the following command: dpkg -L libpopt-dev If the library is installed, after typing the above command you will see information about the paths to the library components. * cmake binary tool is installed. To do this, open the terminal and type the following command: cmake --version If the tool is installed, after typing the above command you will see information about the installed on your computer cmake version. If any above-mentioned requirements are not met - go to point 3. If they are met - go to point 4. Install missing libraries and/or tools: libftdi1 1.4 development library. To do this, open the terminal and type the following command: sudo apt-get install libftdi1-dev popt development library. To do this, open the terminal and type the following command: sudo apt-get install libpopt-dev cmake binary tool. To do this, open the terminal and type the following command: sudo apt-get install cmake Enter into sd-mux project directory and reproduce the following steps to build project: open directory in terminal create 'build' directory by the following command: mkdir build enter into 'build' directory by the following command: cd build run the following commands one by one: cmake .. make In the above-described directory ( sd-mux/build ) run the following command to build binary: sudo make install Note, that the above-described command installs binary into '/usr/local/bin'. If you want to install files in directory rather than the default one add an argument to cmake command: cmake -DCMAKE_INSTALL_PREFIX = /usr .. Then it is obligatory to run again the following commands: make make install","title":"Environment preparation"},{"location":"transparent-validation/sd-wire/usage-validation/#first-use","text":"The following procedure should be performed not only before the first use of the device, but also as the presale validation procedure! Hardware requirements: SDWire SD card DUT (Device Under Test) bootable from SD card (for example: RPI, Orange PI etc.) DUT power supply Micro-USB --> USB cable TS (Test Server) - in most cases personal computer with prepared environment. To perform first use (assuming Raspberry Pi platform as a DUT) procedure reproduce the following steps: Prepare environment in accordance with this section . Insert SD card to the SDWire. Put SDWire into the DUT (Device Under Test). Prepare a micro USB --> USB cable. It will be used to connect SDWire to TS (Test Server). Check whether SDWire is configured by reproducing the following steps: run in TS terminal the following command: dmesg -w connect the SDWire to your machine using micro-USB --> USB cable. after connecting your dmesg output should looks like this: ( ... ) [ 73278 .307591 ] usb-storage 3 -1.1:1.0: USB Mass Storage device detected [ 73278 .307823 ] scsi host6: usb-storage 3 -1.1:1.0 [ 73278 .384925 ] usb 3 -1.2: new full-speed USB device number 45 using xhci_hcd [ 73278 .492025 ] usb 3 -1.2: New USB device found, idVendor = 0403 , idProduct = 6015 , bcdDevice = 10 .00 [ 73278 .492027 ] usb 3 -1.2: New USB device strings: Mfr = 1 , Product = 2 , SerialNumber = 3 [ 73278 .492028 ] usb 3 -1.2: Product: FT200X USB I2C [ 73278 .492029 ] usb 3 -1.2: Manufacturer: FTDI [ 73278 .492030 ] usb 3 -1.2: SerialNumber: DB007V7V ( ... ) open new terminal window and run the following command: sudo sd-mux-ctrl --list If output looks like below, it means that SDWire is configured and ready to use. Now, you can go to point 6 in this section. Number of FTDI devices found: 1 Dev: 0 , Manufacturer: SRPOL, Serial: sd-wire_11, Description: sd-wire Otherwise, if output shows no devices (like in the example below): Number of FTDI devices found: 0 you have to configure SDWire: sudo sd-mux-ctrl --device-serial = DB007V7V --vendor = 0x0403 --product = 0x6015 --device-type = sd-wire --set-serial = sd-wire_11 where: --device-serial = <SerialNumber> ( from dmesg output ) --vendor = 0x<idVendor> ( from dmesg output ) --product = 0x<idProduct> ( from dmesg output ) --set-serial = <New serial device> After above-desribed procedure check again if SDWire is properly configured: sudo sd-mux-ctrl --list Should output: Number of FTDI devices found: 1 Dev: 0 , Manufacturer: SRPOL, Serial: sd-wire_11, Description: sd-wire Connect SD card to the TS (Test Server): sudo sd-mux-ctrl --device-serial = sd-wire_11 --ts Flash the SD card using bmaptool or balenaEtcher. download the OS image for the target DUT - link for RPi image to do this by balenaEtcher go to the producer site and follow his procedure how to download and flash SD card to do this by bmaptool reproduce the following steps: install bmaptool by opening terminal and typing the following command: sudo apt install bmap-tools create the bmap by typing the following command: bmaptool create /path/to/your/image > /path/where/you/want/bmap/file/saved/bmapfilename.bmap flash image to the SD card by typing the following command: sudo bmaptool copy --bmap ~/path/where/your/bmap/file/is/located /path/where/your/image/is/located /path/to/memory/device Connect SD card to the DUT using sd-mux-ctrl : sudo sd-mux-ctrl --device-serial = sd-wire_11 --dut Connect power supply to the DUT and check if it boots properly from newly burned image.","title":"First use"},{"location":"transparent-validation/sd-wire/usage-validation/#everyday-use-scenario","text":"Disconnect power supply from the DUT (Device Under Test). Disconnect micro SD card from the DUT. Connect micro SD card to the TS (Test Server) using card reader. Flash the SD card. Connect SD card to the DUT. Connect power supply to the DUT. Boot DUT from new image. Using SDWire there is no need to disconnect SD card from DUT.","title":"Everyday use scenario"},{"location":"transparent-validation/sd-wire/usage-validation/#sdwire-with-rte-use-scenario","text":"Insert SD card to the SDWire. Insert SDWire into the DUT and connect it to the TS with micro-USB --> USB cable. Connect RTE power control connectors to the DUT (RTE here is optional but highly recommended for remote work, because it helps with automated and remote power control of the connected device). Check serial no. of SDWire: sudo sd-mux-ctrl --list Output: Number of FTDI devices found: 1 Dev: 0 , Manufacturer: SRPOL, Serial: sd-wire_11, Description: sd-wire Disconnect power supply using RTE. Connect SD card to the TS (using sd-mux-ctrl) sudo sd-mux-ctrl --device-serial = sd-wire_11 --ts Flash the SD card using bmaptool or balenaEtcher as described in the First use section Connect SD card to the DUT (using sd-mux-ctrl) sudo sd-mux-ctrl --device-serial = sd-wire_11 --dut Connect power supply using RTE. DUT should boot from freshly burned SD card. Command sudo sd-mux-ctrl --device-serial=sd-wire_11 --status returns information if SDWire is connected to DUT or TS. \u279c ~ sudo sd-mux-ctrl --device-serial = sd-wire_11 --status SD connected to: TS At the moment RTE does not support sd-mux-ctrl, so SDWire must be controlled from configured TS (Test Server). References: https://wiki.tizen.org/SD_MUX https://wiki.tizen.org/SD_MUX/manpage","title":"SDWire with RTE use scenario"},{"location":"unified-test-documentation/generic-test-setup/","text":"Dasharo Compatibility: Generic test setup Test setup Test setup is a set of procedures to be executed before the test execution. Typically, the same setup can be reused by multiple test cases, so there is no need to execute the setup actions before each independent case. Generic test setup Firmware Obtain FIRMWARE binary: you can download it from release document dedicated for platform which is used by you. or you can build one yourself as shown in the building document dedicated for platform which is used by you. Flash FIRMWARE binary to the DUT. Device flashing procedure should be carried out in accordance with the guidelines in Flashing doucment dedicated for platform which is in use. OS installer Download OPERATING_SYSTEM installer image. Attach USB stick to the PC. Flash OPERATING_SYSTEM image to the USB stick. Attach the USB stick to the DUT . OS installation Power on the DUT Enter the boot menu using the BIOS_SETUP_KEY . Select the Boot Menu and press Enter . Select the USB stick and press Enter . In case of the Ubuntu 20.04 , select the Ubuntu (safe graphics) in the GRUB menu. Wait for the OPERATING_SYSTEM installer to start. Install OPERATING_SYSTEM on the disk. Power off the DUT. Remove the installation media (USB stick with installer). NVIDIA drivers - Ubuntu 20.04 Power on the DUT. Wait until the OPERATING_SYSTEM boots from disk. Login into the OPERATING_SYSTEM . Open a terminal window and execute the following commands: sudo apt update sudo apt install nvidia-driver-470 A password prompt for secure boot configuration will appear. Choose a password (you can use your system password) and press Enter . Reboot the DUT. Upon entry into MOKUtil, select Enroll MOK and enter the password you chose during driver installation. Select the option Continue boot . Wait until the OPERATING_SYSTEM boots from disk. Login into the OPERATING_SYSTEM . Open the NVIDIA X Server Settings application. Open the PRIME Profiles section. Select NVIDIA On-demand and apply. Enter the OPERATING_SYSTEM password when prompted. OS boot from disk Power on the DUT. Wait until the OPERATING_SYSTEM boots from disk. Login into the OPERATING_SYSTEM .","title":"Generic Test Setup"},{"location":"unified-test-documentation/generic-test-setup/#dasharo-compatibility-generic-test-setup","text":"","title":"Dasharo Compatibility: Generic test setup"},{"location":"unified-test-documentation/generic-test-setup/#test-setup","text":"Test setup is a set of procedures to be executed before the test execution. Typically, the same setup can be reused by multiple test cases, so there is no need to execute the setup actions before each independent case.","title":"Test setup"},{"location":"unified-test-documentation/overview/","text":"Dasharo Test Specifiaction - overview The release procedure is always preceded by validation procedure. It is done on the basis of the test documentation, which can be found in this submenu. To properly use the documentation, it is advisable to read the following brief description of its components. Test Matrix Test Matrix is the document which shows platform-dedicated test suites and test cases. Based on it, the customer may scope the checks performed by the validation team each time before firmware release. Generic test setup Generic test setup is the document which describes all the steps that are performed before testing the various functionalities. Dasharo modules Tests preformed during validation procedure can be divided into test modules, test suites and test cases. Test cases are the smallest component of validation procedure. Their task is to check, that the given functionallity works properly under a certain conditions. Test suites group test cases related to the given functionality, while test modules groups test cases related to the similar functionalities (i. e. test suites which task is to check if differently OS boot properly on the platform). Currently in Dasharo test specification the following test modules can be distinguished: Dasharo Compatibility which contains test suites related to the basic functionailited of the device. Dasharo Security which contains test suites related to the platform security and supporting security modules. Dasharo Performance which contains test suites related to the platform booting performance.","title":"Overview"},{"location":"unified-test-documentation/overview/#dasharo-test-specifiaction-overview","text":"The release procedure is always preceded by validation procedure. It is done on the basis of the test documentation, which can be found in this submenu. To properly use the documentation, it is advisable to read the following brief description of its components.","title":"Dasharo Test Specifiaction - overview"},{"location":"unified-test-documentation/overview/#test-matrix","text":"Test Matrix is the document which shows platform-dedicated test suites and test cases. Based on it, the customer may scope the checks performed by the validation team each time before firmware release.","title":"Test Matrix"},{"location":"unified-test-documentation/overview/#generic-test-setup","text":"Generic test setup is the document which describes all the steps that are performed before testing the various functionalities.","title":"Generic test setup"},{"location":"unified-test-documentation/overview/#dasharo-modules","text":"Tests preformed during validation procedure can be divided into test modules, test suites and test cases. Test cases are the smallest component of validation procedure. Their task is to check, that the given functionallity works properly under a certain conditions. Test suites group test cases related to the given functionality, while test modules groups test cases related to the similar functionalities (i. e. test suites which task is to check if differently OS boot properly on the platform). Currently in Dasharo test specification the following test modules can be distinguished: Dasharo Compatibility which contains test suites related to the basic functionailited of the device. Dasharo Security which contains test suites related to the platform security and supporting security modules. Dasharo Performance which contains test suites related to the platform booting performance.","title":"Dasharo modules"},{"location":"unified-test-documentation/dasharo-compatibility/100-coreboot-base-port/","text":"Dasharo: coreboot base port Test cases Common Test setup Proceed with the Generic test setup: firmware . Connect to the UART debug interface and open a serial console. CBP001.001 Boot into coreboot stage bootblock Test description This test aims to verify that DUT during booting procedure reaches stage bootblock. The bootblock is the first stage executed after CPU reset, its main task is to set up everything for a C-environment. Test setup Proceed with the Common section. Test steps Power ON the DUT. By using the serial console read the booting procedure stage. Test steps Power on the DUT. Read the booting procedure stage. Expected result The console output should contain string with the phrase: bootblock starting CBP002.001 Boot into coreboot stage romstage Test description This test aims to verify that DUT during booting procedure reaches stage romstage. The romstage initializes the DRAM and prepares everything for device init. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Common section. Test steps Power ON the DUT. By using the serial console read the booting procedure stage. Expected result The console output should contain string with the phrase: romstage starting CBP003.001 Boot into coreboot stage postcar Test description This test aims to verify that DUT during booting procedure reaches stage postcar. The postcar tears down CAR and loads the ramstage. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Common section. Test steps Power ON the DUT. By using the serial console read the booting procedure stage. Expected result The console output should contain string with the phrase: postcar starting CBP004.001 Boot into coreboot stage ramstage Test description This test aims to verify that DUT during booting procedure reaches stage ramstage. The ramstage does the main device init. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Common section. Test steps Power ON the DUT. By using the serial console read the booting procedure stage. Expected result The console output should contain string the with phrase: ramstage starting CBP005.001 Resource allocator v4 - gathering requirements Test description This test aims to verify that DUT reaches the gathering requirements stage for Resource Allocator v4 during booting procedure. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Common section. Test steps Power ON the DUT. By using the serial console read the booting procedure stage. Expected result The console output should contain a string with the phrase: Pass 1 ( gathering requirements ) CBP006.001 Resource allocator v4 - allocating resources Test description This test aims to verify that DUT reaches the allocating resources stage for Resource Allocator v4 during booting procedure. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Common section. Test steps Power ON the DUT. By using the serial console read the booting procedure stage. Expected result The console output should contain a string with the phrase: Pass 2 ( allocating resources )","title":"Coreboot Base Port"},{"location":"unified-test-documentation/dasharo-compatibility/100-coreboot-base-port/#dasharo-coreboot-base-port","text":"","title":"Dasharo: coreboot base port"},{"location":"unified-test-documentation/dasharo-compatibility/100-coreboot-base-port/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/301-memory-hcl/","text":"Dasharo compatibility: Memory HCL Test cases HCL001.001 Memory HCL - boot into OS (Ubuntu 20.04) Test description This test aims to verify that the DUT can boot with the memory module combinations specified in the HCL. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Prepare the memory modules specified in the HCL. Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Test steps Insert the memory module into the DUT's memory port, starting with the first position from the HCL. Power on the DUT. Boot into the system. Power off the DUT. Repeat the test steps for all positions in the HCL. Expected result The expected result is that the OS boots successfully with all memory combinations specified in the HCL If the OPERATING_SYSTEM boots, note the success and power the DUT OFF If the OPERATING_SYSTEM doesn't boot, check the logs (optional - if connected over serial console) for the FSP Memory Init has returned an error and note the failure","title":"Memory HCL"},{"location":"unified-test-documentation/dasharo-compatibility/301-memory-hcl/#dasharo-compatibility-memory-hcl","text":"","title":"Dasharo compatibility: Memory HCL"},{"location":"unified-test-documentation/dasharo-compatibility/301-memory-hcl/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/303-custom-boot-menu-key/","text":"Dasharo compatibility: Custom Boot Keys Test cases CBK001.001 Custom Boot Menu Key Test description This test aims to verify that the DUT is configured to use custom Boot Menu hotkey (if it exists). Test configuration data FIRMWARE = coreboot Test setup Proceed with the Generic test setup: firmware . Test steps Power on the DUT. Hold the BOOT_MENU_KEY to enter the Boot Menu. Expected result The DUT boots into the Boot Menu after using the specified hotkey. CBK002.001 Custom BIOS Menu Key Test description This test aims to verify that the DUT is configured to use custom BIOS Menu hotkey. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Generic test setup: firmware . Test steps Power on the DUT. Hold the BIOS_MENU_KEY to enter the BIOS menu. Expected result The DUT boots into the BIOS menu after using the specified hotkey.","title":"Custom Boot Keys"},{"location":"unified-test-documentation/dasharo-compatibility/303-custom-boot-menu-key/#dasharo-compatibility-custom-boot-keys","text":"","title":"Dasharo compatibility: Custom Boot Keys"},{"location":"unified-test-documentation/dasharo-compatibility/303-custom-boot-menu-key/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/304-custom-logo/","text":"Dasharo compatibility: Custom Logo Test cases CLG001.001 Custom boot logo Test description This test aims to verify that the DUT is configured to display the specified (customized) logo at boot. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Generic test setup: firmware . Test steps Power on the DUT. Wait for the boot logo to appear. Expected result The logo that is displayed should be in accordance with [custom logo] documentation.","title":"Custom Logo"},{"location":"unified-test-documentation/dasharo-compatibility/304-custom-logo/#dasharo-compatibility-custom-logo","text":"","title":"Dasharo compatibility: Custom Logo"},{"location":"unified-test-documentation/dasharo-compatibility/304-custom-logo/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/306-usb-hid-and-msc-support/","text":"Dasharo compatibility: USB HID and MSC Support Test cases Common Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . USB001.001 USB devices detection (firmware) Test description This test aims to verify that the external USB devices are detected correctly by the firmware and all basic keys work according to their labels. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Connect the flash drive using the USB port. Test steps Power on the DUT. Enter the boot menu using the BIOS_SETUP_KEY . Select the Boot Menu , press Enter and note the result. Expected result Flash drive entry is listed in the boot menu. USB001.002 USB devices detection in OS (Ubuntu 20.04) Test description This test aims to verify that the external USB devices are detected correctly by the OPERATING_SYSTEM and all basic keys work according to their labels. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and run the follwing command: watch -n1 lsusb Connect external USB devices to DUT USB A port and note the result. Expected result After each device is connected to the USB port, a new USB device entry in lsusb command output should appear. USB001.003 USB devices detection in OS (Windows 11) Test description This test aims to verify that the external USB devices are detected correctly by the OPERATING_SYSTEM and all basic keys work according to their labels. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open PowerShell and and run the follwing command: Get-PnpDevice -PresentOnly | Where-Object { $_ .InstanceId -match '^USB' } Note the results. Expected result After executing the command, a list containing all USB devices should be displayed. All devices' status should be OK . Example output: Status Class FriendlyName ------ ----- ------------ OK DiskDrive Mass Storage Device USB Device OK USB Generic USB Hub OK HIDClass USB Input Device OK Bluetooth Intel ( R ) Wireless Bluetooth ( R ) OK USB USB Root Hub ( USB 3 .0 ) OK Net TP-LINK Gigabit Ethernet USB Adapter OK USB Generic USB Hub OK USB USB Mass Storage Device USB002.001 USB keyboard detection (firmware) Test description This test aims to verify that the external USB keyboard is detected correctly by the firmware and all basic keys work according to their labels. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Generic test setup: firmware . Connect the external USB keyboard using the USB port. Test steps Power on the DUT Enter the boot menu using the BIOS_SETUP_KEY . Use the arrow keys, Esc key and the Enter key to navigate the menus. Expected result All menus can be entered using the external USB keyboard. USB002.002 USB keyboard detection (Ubuntu 20.04) Test description This test aims to verify that the external USB keyboard is detected correctly by the OPERATING_SYSTEM and all basic keys work according to their labels. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Install libinput-tools on the DUT. Connect the external USB keyboard using the USB port. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and run the follwing command: lsusb Run the follwing command in the terminal: libinput debug-events --show-keycodes Test the alphanumeric keys and note the generated keycodes. Test non-alphanumeric keys and verify that they generate the correct keycodes. Test key combinations with the Shift , Ctrl and Alt modifier keys (this tests 2-key rollover). Expected result The extarnal USB keyboard is detected in OS. All standard keyboard keys generate the correct keycodes and events as per their labels. Key combinations are detected correctly. USB002.003 USB keyboard detection (Windows 11) Test description This test aims to verify that the external USB keyboard is detected correctly by the OPERATING_SYSTEM and all basic keys work according to their labels. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Connect the external USB keyboard using the USB port. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open PowerShell and and run the follwing command: Get-CimInstance win32_KEYBOARD Note the results. Open notepad . Test the alphanumeric keys and note the generated characters. Test non-alphanumeric keys and verify that they generate the signs. Test key combinations with the Shift , and Alt modifier keys. Open On-Screen Keyboard and press Ctrl key on the hardware keyboard. Check if On-Screen Keyboard correctly highlights it. Open Start menu and press Esc . Check if Start menu is properly closed. Expected result After running the PowerShell command information about connected keyboard should be displayed. Example output: Caption : Enhanced ( 101 - or 102 -key ) Description : USB Input Device InstallDate : Name : Enhanced ( 101 - or 102 -key ) Status : OK Availability : ConfigManagerErrorCode : 0 ConfigManagerUserConfig : False CreationClassName : Win32_Keyboard DeviceID : USB \\V ID_046D & PID_C31C & MI_00 \\6 & 26C21341 & 0 & 0000 ErrorCleared : ErrorDescription : LastErrorCode : PNPDeviceID : USB \\V ID_046D & PID_C31C & MI_00 \\6 & 26C21341 & 0 & 0000 PowerManagementCapabilities : PowerManagementSupported : False StatusInfo : SystemCreationClassName : Win32_ComputerSystem SystemName : DESKTOP-CUR9H2J IsLocked : Layout : 00000409 NumberOfFunctionKeys : 12 Password : PSComputerName : All standard keyboard keys generate correct characters or actions when pressed. Key combinations are detected correctly.","title":"USB HID and MSC support"},{"location":"unified-test-documentation/dasharo-compatibility/306-usb-hid-and-msc-support/#dasharo-compatibility-usb-hid-and-msc-support","text":"","title":"Dasharo compatibility: USB HID and MSC Support"},{"location":"unified-test-documentation/dasharo-compatibility/306-usb-hid-and-msc-support/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/307-freebsd-support/","text":"Dasharo Compatibility: FreeBSD support Test cases Common Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installation . BSD001.001 FreeBSD installation and boot Test description This test verifies that FreeBSD distribution could be installed on the DUT and works properly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = FreeBSD 13 Test setup Proceed with the Common section. Test steps Power on the DUT. Wait for the OPERATING_SYSTEM to boot and note the result. Expected result The OPERATING_SYSTEM login screen should be displayed.","title":"FreeBSD support"},{"location":"unified-test-documentation/dasharo-compatibility/307-freebsd-support/#dasharo-compatibility-freebsd-support","text":"","title":"Dasharo Compatibility: FreeBSD support"},{"location":"unified-test-documentation/dasharo-compatibility/307-freebsd-support/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/308-debian-stable-and-ubuntu-lts-support/","text":"Dasharo Compatibility: Debian Stable and Ubuntu LTS support Test cases Common Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installation . LBT001.001 Debian Stable installation and boot Test description This test verifies that Debian stable distribution could be installed on the DUT and works properly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Debian 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Wait for the OPERATING_SYSTEM to boot and note the result. Expected result The OPERATING_SYSTEM login screen should be displayed. LBT002.001 Ubuntu LTS installation and boot Test description This test verifies that Ubuntu LTS modern ditribution could be installed on the DUT and works properly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Wait for the OPERATING_SYSTEM to boot and note the result. Expected result The OPERATING_SYSTEM login screen should be displayed.","title":"Debian Stable and Ubuntu LTS support"},{"location":"unified-test-documentation/dasharo-compatibility/308-debian-stable-and-ubuntu-lts-support/#dasharo-compatibility-debian-stable-and-ubuntu-lts-support","text":"","title":"Dasharo Compatibility: Debian Stable and Ubuntu LTS support"},{"location":"unified-test-documentation/dasharo-compatibility/308-debian-stable-and-ubuntu-lts-support/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/30A-custom-network-boot-entries/","text":"Dasharo Compatibility: Custom Network Boot entries Test cases CNB001.002 Only one iPXE in boot menu Test description This test aims to verify that thenetwork boot option with iPXE appears only once in the boot option list. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Generic test setup: firmware . Test steps Power on the DUT. Hold the BOOT_MENU_KEY to enter the UEFI Boot Menu. Check the iPXE is listed only once on the boot option list. Expected result There is only one iPXE entry on the boot option list.","title":"Custom Network Boot entries"},{"location":"unified-test-documentation/dasharo-compatibility/30A-custom-network-boot-entries/#dasharo-compatibility-custom-network-boot-entries","text":"","title":"Dasharo Compatibility: Custom Network Boot entries"},{"location":"unified-test-documentation/dasharo-compatibility/30A-custom-network-boot-entries/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/30L-memtest-payload-support/","text":"Dasharo Compatibility: Memtest payload support Test cases MEM001.001 Memtest availability Test description This test aims to verify that the Memtest entry is available in DUT boot menu. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Generic test setup: firmware . Test steps Power on the DUT. Wait until BOOT_MENU_STRING appears. Press BOOT_MENU_KEY to enter the boot menu. Check if Payload [memtest] is available in the boot menu. Expected result The Payload [memtest] option should be visible as the one of boot menu options. MEM002.001 Enter Memtest Test description This test aims to verify that the DUT enters the Memtestboot option. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Generic test setup: firmware . Test steps Power on the DUT. Wait for boot until BOOT_MENU_STRING appears. Press BOOT_MENU_KEY to enter the boot menu. Select the key with a proper number for Payload [memtest] . Check if Memtest86+ is available. Expected result The Memtest86+ is visible at the top of the output. MEM003.001 Memtest stability Test description This test aims to verify that the Memtest starts does not hang under DUT. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Generic test setup: firmware . Test steps Power on the DUT. Wait for boot until BOOT_MENU_STRING appears. Press BOOT_MENU_KEY to enter the boot menu. Select the key with a proper number for Payload [memtest] . Check if State: - Running... is available. Expected result The State: - Running... is visible after a few seconds and confirms that the the test is in progress. MEM004.001 Memtest refreshing by 'L' key Test description This test aims to verify that DUT refreshes Memtest properly. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Generic test setup: firmware . Test steps Power on the DUT. Wait for boot until BOOT_MENU_STRING appears. Press BOOT_MENU_KEY to enter the boot menu. Select the key with a proper number for BOOT_MENU_ENTRY . Press the L key. Check if L refreshes output. Expected result The Memtest86+ is visible before and after pressing L . MEM005.001 Memtest refreshing by 'l' key Test description This test aims to verify that DUT refreshes Memtest properly. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Generic test setup: firmware . Test steps Power on the DUT. Wait for boot until BOOT_MENU_STRING appears. Press BOOT_MENU_KEY to enter the boot menu. Select the key with a proper number for BOOT_MENU_ENTRY . Press the l key. Check if l refreshes output. Expected result The Memtest86+ is visible before and after pressing l . MEM006.001 Memtest completing Test description This test aims to verify that DUT completes Memtest. FIRMWARE = coreboot Test setup Proceed with the Generic test setup: firmware . Test steps Power on the DUT. Wait for boot until BOOT_MENU_STRING appears. Press BOOT_MENU_KEY to enter the boot menu. Select the key with a proper number for Payload [memtest] . Make sure that State: - Running... is available. Wait until ** Pass complete, no errors, press Esc to exit ** appears. Expected result After the test completes without any errors ** Pass complete, no errors, press Esc to exit ** message is visible on the bottom of the screen.","title":"Memtest payload support"},{"location":"unified-test-documentation/dasharo-compatibility/30L-memtest-payload-support/#dasharo-compatibility-memtest-payload-support","text":"","title":"Dasharo Compatibility: Memtest payload support"},{"location":"unified-test-documentation/dasharo-compatibility/30L-memtest-payload-support/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/30M-uefi-compatible-interface/","text":"Dasharo Compatibility: UEFI compatible interface Test cases EFI001.001 Boot into UEFI OS (Ubuntu 20.04) Test description This test verifies the presence of UEFI compatible interface by booting UEFI-aware Operating System. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Test steps Power on the DUT. Enter the boot menu using the BIOS_SETUP_KEY . Select the Boot Menu and press Enter . Select the USB stick and press Enter . Select the Ubuntu (safe graphics) in the GRUB menu. Wait for the OPERATING_SYSTEM to boot finalize booting, by either of the: OPERATING_SYSTEM installer initialization, login form initialization. Power OFF the DUT. Expected result Either the login screen or the OPERATING_SYSTEM installer appears on the internal LCD. EFI001.002 Boot into UEFI OS (Windows 11) Test description This test aims to verify the presence of UEFI compatible interface by booting UEFI-aware Operating System. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Test steps Power on the DUT. Enter the boot menu using the BIOS_SETUP_KEY . Select the Boot Menu and press Enter . Select the USB stick and press Enter . Wait for the OPERATING_SYSTEM to boot finalize booting, by either of the: OPERATING_SYSTEM installer initialization, login form initialization. Power OFF the DUT. Expected result Either the login screen or the OPERATING_SYSTEM installer appears on the internal LCD.","title":"UEFI compatible interface"},{"location":"unified-test-documentation/dasharo-compatibility/30M-uefi-compatible-interface/#dasharo-compatibility-uefi-compatible-interface","text":"","title":"Dasharo Compatibility: UEFI compatible interface"},{"location":"unified-test-documentation/dasharo-compatibility/30M-uefi-compatible-interface/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/30P-uefi-shell/","text":"Dasharo Compatibility: UEFI Shell Test cases USH001.001 UEFI Shell Test description This test aims to verify that the DUT has the ability to boot into an integrated UEFI Shell application. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Generic test setup: Firmware . Test steps Power on the DUT. While the DUT is booting, hold the BOOT_MENU_KEY to enter the UEFI Boot Menu. Select the UEFI Shell option using the arrow keys and press Enter . Expected result The DUT boots into an UEFI Shell successfully, as indicated by the example console output shown on the screen: UEFI Interactive Shell v2.2 EDK II UEFI v2.70 (EDK II, 0x00010000) Mapping table FS0: Alias(s):HD1b:;BLK2: PciRoot(0x0)/Pci(0x6,0x0)/Pci(0x0,0x0)/NVMe(0x1,9C-BB-50-01-BB-38-25-5 -4BB4-4FDD-9534-B097CD497222,0x800,0x100000) FS1: Alias(s):HD1c:;BLK3: PciRoot(0x0)/Pci(0x6,0x0)/Pci(0x0,0x0)/NVMe(0x1,9C-BB-50-01-BB-38-25-1 -C6AB-4400-AE03-0BF2960DD525,0x100800,0x1D0C5000) BLK1: Alias(s): PciRoot(0x0)/Pci(0x6,0x0)/Pci(0x0,0x0)/NVMe(0x1,9C-BB-50-01-BB-38-25-) BLK0: Alias(s): PciRoot(0x0)/Pci(0x14,0x0)/USB(0x0,0x2) Press ESC in 1 seconds to skip startup.nsh or any other key to continue.","title":"UEFI Shell"},{"location":"unified-test-documentation/dasharo-compatibility/30P-uefi-shell/#dasharo-compatibility-uefi-shell","text":"","title":"Dasharo Compatibility: UEFI Shell"},{"location":"unified-test-documentation/dasharo-compatibility/30P-uefi-shell/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/312-nvme-support/","text":"Dasharo Compatibility: NVMe support Test cases NVM001.001 NVMe support (firmware) Test description This test aims to verify that firmware is able to correctly detect NVMe disk in the M.2 slot. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Generic test setup: firmware . Test steps Insert a NVMe disk into the M.2 slot on the DUT. Power on the DUT. While the DUT is booting, hold the BOOT_MENU_KEY to enter the UEFI Boot Menu and note the result. Expected result The NVMe disk should be listed on the bootable devices list. NVM001.002 NVMe support (Ubuntu 20.04) Test description This test aims to verify booting the Operating System from NVMe disk in the M.2 slot. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Generic test setup: firmware . Insert a NVMe disk into the M.2 slot on the DUT. Proceed with the Generic test setup: OS installer . Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and execute the follwing command: sudo mount | grep 'on / ' Expected result The OPERATING_SYSTEM has been booted from the NVMe disk correctly. Output in Terminal indicates that system partition is installed on the NVMe disk: /dev/nvme* on / tpe ext4 ( rw,relatime,errors = remount-ro ) NVM001.003 NVMe support in OS (Windows 11) Test description This test aims to verify booting the Operating System from NVMe disk in the M.2 slot. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Generic test setup: firmware . Insert a NVMe disk into the M.2 slot on the DUT. Proceed with the Generic test setup: OS installer . Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open PowerShell as administrator. Run below command and note the result: Get-PnpDevice -Status \"OK\" | where { $_ . InstanceId -like \"SCSI\\DISK&VEN_NVME&*\" } Expected result The OPERATING_SYSTEM booting from the NVMe disk Command should output at least one NVMe drive. Similar as below: Status Class FriendlyName ------ ----- ------------ OK DiskDrive Samsung SSD 980 PRO 500GB","title":"NVME support"},{"location":"unified-test-documentation/dasharo-compatibility/312-nvme-support/#dasharo-compatibility-nvme-support","text":"","title":"Dasharo Compatibility: NVMe support"},{"location":"unified-test-documentation/dasharo-compatibility/312-nvme-support/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/315-network-boot/","text":"Dasharo Compatibility: Network Boot Test cases PXE001.001 iPXE network boot Test description This test aims to verify that the DUT is capable of network booting from a PXE server. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Generic test setup: firmware . Test steps Power on the DUT. Hold the BOOT_MENU_KEY to enter the UEFI Boot Menu. Select the iPXE Network boot option using the arrow keys and press Enter . Press Ctrl+B when prompted to stop iPXE from booting automatically. Type in dhcp to obtain an IP address. Type in chain --autofree http://boot.netboot.xyz/ to load a boot menu Enter the \"Live CDs\" submenu using the arrow keys and Enter. Select Debian -> Debian Live 11 (bullseye) -> Debian 11 Gnome and press Enter. Expected result The iPXE application boots successfully. iPXE obtains an IP address. iPXE boots an Debian 11 from netboot.xyz.","title":"Network boot"},{"location":"unified-test-documentation/dasharo-compatibility/315-network-boot/#dasharo-compatibility-network-boot","text":"","title":"Dasharo Compatibility: Network Boot"},{"location":"unified-test-documentation/dasharo-compatibility/315-network-boot/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/316-sdcard-reader/","text":"Dasharo Compatibility: SD Card Reader Test cases Common Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . Insert an SD card into the SD Card reader. SDC001.001 SD Card reader detection (Ubuntu 20.04) Test description This test aims to verify that the SD Card reader is enumerated correctly and can be detected from the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and execute the follwing command: lspci | grep RTS522A Expected result The output from the command should contain the line: 2d:00.0 Unassigned class [ ff00 ] : Realtek Semiconductor Co., Ltd. RTS522A PCI Express Card Reader ( rev 01 ) SDC001.002 SD Card reader detection (Windows 11) Test description This test aims to verify that the SD Card reader is enumerated correctly and can be detected from the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open PowerShell as administrator. Run below command and note result: Get-PnpDevice -Status \"OK\" -Class \"MTD\" Expected result The output of the command should contain basic information about mounted SD card reader. Output example: Status Class FriendlyName ------ ----- ------------ OK MTD Realtek PCIE CardReader SDC002.001 SD Card read/write (Ubuntu 20.04) Test description This test aims to verify that the SD Card reader is initialized correctly and can be used from the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and execute the following commands as root: dd if = /dev/urandom of = /tmp/in.bin bs = 4K count = 100 dd if = /tmp/in.bin of = /dev/mmcblk0 bs = 4K count = 100 dd if = /dev/mmcblk0 of = /tmp/out.bin bs = 4K count = 100 sha256sum /tmp/in.bin /tmp/out.bin Expected result The output from the last command should contain 2 indentical checksums: 2083776668ed0c8095a9ac42188153c02f360e116c14b36d2ef5c98665d75dcb /tmp/in.bin 2083776668ed0c8095a9ac42188153c02f360e116c14b36d2ef5c98665d75dcb /tmp/out.bin SDC002.002 SD Card read/write (Windows 11) Test description This test aims to verify that the SD Card reader is initialized correctly and can be used from the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Determine the localisation of the mounted SD card. Open PowerShell as administrator. Run below commands and note results: New-Item -Path \"${drive_lacation}:\\\" -Name \"testfile.txt\" -ItemType \"file\" -Value \"This is a test string.\" Get-Content -Path \"${drive_lacation}:\\testfile.txt\" Expected result Last command should return This is a test string.","title":"SD card reader"},{"location":"unified-test-documentation/dasharo-compatibility/316-sdcard-reader/#dasharo-compatibility-sd-card-reader","text":"","title":"Dasharo Compatibility: SD Card Reader"},{"location":"unified-test-documentation/dasharo-compatibility/316-sdcard-reader/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/317-usb-camera/","text":"Dasharo Compatibility: USB Camera Test cases CAM001.001 USB Camera (Ubuntu 20.04) Test description This test aims to verify that the integrated USB camera is initialized correctly and can be accessed from the operating system Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . Install ffprobe: sudo apt install ffmpeg . Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and run the following commands: ffprobe /dev/video0 ffprobe /dev/video2 Expected result The output from the first command should contain the lines: Input #0, video4linux2,v4l2, from '/dev/video0': Stream #0:0: Video: rawvideo (YUY2 / 0x32595559), yuyv422, 640x480, 147456 kb/s, 30 fps, 30 tbr, 1000k tbn, 1000k tbc The output from the second command should contain the lines: Input #0, video4linux2,v4l2, from '/dev/video2': Stream #0:0: Video: rawvideo (Y800 / 0x30303859), gray, 640x360, 55296 kb/s, 30 fps, 30 tbr, 1000k tbn, 1000k tbc CAM001.002 USB Camera (Windows 11) Test description This test aims to verify that the integrated USB camera is initialized correctly and can be accessed from the operating system Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Run PowerShell as administrator. Execute below command and note the result: Get-PnpDevice -PresentOnly | Where-Object { $_ . InstanceId -match '^USB' } Expected result Output should contain Chicony USB2.0 Camera . Example output: Status Class FriendlyName ------ ----- ------------ OK Camera Chicony USB2 . 0 Camera OK Bluetooth Intel ( R ) Wireless Bluetooth ( R ) OK Camera IR Camera OK USB USB Root Hub ( USB 3 . 0 ) OK USB USB Root Hub ( USB 3 . 0 ) OK USB USB Composite Device","title":"USB camera"},{"location":"unified-test-documentation/dasharo-compatibility/317-usb-camera/#dasharo-compatibility-usb-camera","text":"","title":"Dasharo Compatibility: USB Camera"},{"location":"unified-test-documentation/dasharo-compatibility/317-usb-camera/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/318-m2-wifi-bluetooth/","text":"Dasharo Compatibility: M.2 WiFi/Bluetooth Test cases Common Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . WLE001.001 Wireless card detection (Ubuntu 20.04) Test description This test aims to verify that the Wi-Fi/Bluetooth card is enumerated correctly and can be detected from the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and execute the following command: lspci | grep AX20 Expected result The output of the command should contain the line: 2f:00.0 Network controller: Intel Corporation Wi-Fi 6 AX200 ( rev 1a ) The exact name and revision may be different depending on hardware configuration. WLE001.002 Wireless card detection (Windows 11) Test description This test aims to verify that the Wi-Fi/Bluetooth card is enumerated correctly and can be detected from the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open PowerShell and execute following command: Get-PnpDevice -PresentOnly | Select-String -Pattern \"Wi-Fi\" Note the result. Expected result The output of the command should contain the line with Wi-Fi device, which has been phisically mounted in the device. Output example: Intel ( R ) Wi-Fi 6AX200 160MHz WLE002.001 Wi-Fi scanning (Ubuntu 20.04) Test description This test aims to verify that the Wi-Fi functionality of card is initialized correctly and can be used from within the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Make sure to have any Wi-Fi signal available. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and execute the following commands as root: nmcli radio wifi on nmcli device wifi rescan # Wait ~5 seconds nmcli device wifi list Expected result The output of the last command should return a list of available Wi-Fi networks, for example: IN-USE BSSID SSID MODE CHAN RATE SIGNAL BARS SECURITY XX:XX:XX:XX:XX:XX DIRECT-ny Infra 6 65 Mbit/s 75 \u2582\u2584\u2586_ WPA2 * XX:XX:XX:XX:XX:XX 3mdeb_abr_5GHz Infra 48 405 Mbit/s 72 \u2582\u2584\u2586_ WPA2 XX:XX:XX:XX:XX:XX 3mdeb_abr Infra 11 54 Mbit/s 69 \u2582\u2584\u2586_ WPA2 XX:XX:XX:XX:XX:XX FunBox2-F9BF_2.4GHz Infra 1 130 Mbit/s 50 \u2582\u2584__ WPA1 WPA2 XX:XX:XX:XX:XX:XX H_Office Infra 2 270 Mbit/s 35 \u2582\u2584__ WPA2 XX:XX:XX:XX:XX:XX DIRECT-xpPhaser 3330 Infra 1 65 Mbit/s 34 \u2582\u2584__ WPA2 XX:XX:XX:XX:XX:XX Orange_Swiatlowod_A79A Infra 108 540 Mbit/s 32 \u2582\u2584__ WPA2 XX:XX:XX:XX:XX:XX DIRECT-KRM288x Series Infra 11 54 Mbit/s 22 \u2582___ WPA2 XX:XX:XX:XX:XX:XX Orange_Swiatlowod_A79A Infra 11 130 Mbit/s 20 \u2582___ WPA2 XX:XX:XX:XX:XX:XX DIRECT-ejPhaser 3330 Infra 1 65 Mbit/s 17 \u2582___ WPA2 XX:XX:XX:XX:XX:XX NED-WIFI Infra 11 270 Mbit/s 17 \u2582___ WPA2 WLE002.002 Wi-Fi scanning (Windows 11) Test description This test aims to verify that the Wi-Fi functionality of card is initialized correctly and can be used from within the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Make sure to have any Wi-Fi signal available Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open PowerShell and execute following command: netsh wlan show network Note the result. Expected result The output of the command should return a list of available Wi-Fi networks. Output example: SSID 1 : Orange_Swiatlowod_A79A Network type : Infrastructure Authentication : WPA2-Personal Encryption : CCMP SSID 2 : DIRECT-Y9Phaser 3330 Network type : Infrastructure Authentication : WPA2-Personal Encryption : CCMP SSID 3 : 3mdeb_abr_5GHz Network type : Infrastructure Authentication : WPA2-Personal Encryption : CCMP SSID 4 : 3mdeb_abr Network type : Infrastructure Authentication : WPA2-Personal Encryption : CCMP WLE003.001 Bluetooth scanning (Ubuntu 20.04) Test description This test aims to verify that the Bluetooth functionality of card is initialized correctly and can be used from within the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Enable Bluetooth and make it discoverable in any device nearby DUT. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and execute the following commands: bluetoothctl power on scan on # Wait ~5 seconds devices Expected result The output of the last command should return a list of detectable Bluetooth devices, for example: Device XX:XX:XX:XX:XX:XX Device 1 Device XX:XX:XX:XX:XX:XX Wojtek N Device XX:XX:XX:XX:XX:XX Mi Smart Band 4 Device XX:XX:XX:XX:XX:XX Galaxy Watch4 Classic ( PHLM ) Device XX:XX:XX:XX:XX:XX Galaxy Watch4 Classic ( PHLM ) Device XX:XX:XX:XX:XX:XX Device 2 Device XX:XX:XX:XX:XX:XX [ Signage ] Samsung QMR Series Device XX:XX:XX:XX:XX:XX [ Signage ] Samsung QMR Series Device XX:XX:XX:XX:XX:XX Device 3 Device XX:XX:XX:XX:XX:XX Device 4 Device XX:XX:XX:XX:XX:XX Device 5 Device XX:XX:XX:XX:XX:XX Device 6 WLE003.002 Bluetooth scanning (Windows 11) Test description This test aims to verify that the Bluetooth functionality of card is initialized correctly and can be used from within the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Enable Bluetooth and make it discoverable in any device nearby DUT Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Enter Notification Center in the bottom right part of the screen. Using right mouse button click on the Bluetooth icon. In shown drop-down menu click Go to settings . Click the + icon described as Add Bluetooth or other device . In the Add a device menu click Bluetooth . Wait a few moments until DUT scans for nearby Bluetooth devices and note the result. Expected result Available Bluetooth devices should appear in the Add a device window.","title":"Wi-Fi and Bluetooth support"},{"location":"unified-test-documentation/dasharo-compatibility/318-m2-wifi-bluetooth/#dasharo-compatibility-m2-wifibluetooth","text":"","title":"Dasharo Compatibility: M.2 WiFi/Bluetooth"},{"location":"unified-test-documentation/dasharo-compatibility/318-m2-wifi-bluetooth/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/319-nvidia-graphics/","text":"Dasharo Compatibility: NVIDIA Graphics support Test cases Common Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . NVI001.001 NVIDIA Graphics detect (Ubuntu 20.04) Test description This test aims to verify that the NVIDIA graphics card is correctly initialized and can be detected by the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Open a terminal window and execute the following command: lspci | grep -i nvidia Expected result The command should return one line containing the name of the graphics card, e.g: 2d:00.0 3D controller: NVIDIA Corporation TU117M ( rev a1 ) NVI001.002 NVIDIA Graphics detect (Windows 11) Test description This test aims to verify that the NVIDIA graphics card is correctly initialized and can be detected by the operating system Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Install the driver for the graphics card (GTX 1650) from the official page . Test steps Run PowerShell as administrator and execute following command: Get-WmiObject -Class Win32_VideoController | Select Description , Name , Status Expected result The output should contain the information about installed Nvidia Graphics card. Example output: Description Name Status ----------- ---- ------ Intel ( R ) Iris ( R ) Xe Graphics Intel ( R ) Iris ( R ) Xe Graphics OK NVIDIA GeForce GTX 1650 NVIDIA GeForce GTX 1650 OK NVI002.001 NVIDIA Graphics power management (Ubuntu 20.04) Test description This test aims to verify that the NVIDIA graphics power management is functional and the card powers on only while it's used. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Install the package mesa-utils with the following command: sudo apt install mesa-utils Test steps Open a terminal window. Run the following command to see whether the card is off: cat /sys/class/drm/card1/device/power/runtime_status Launch a test application on the discrete graphics card using the following command: __NV_PRIME_RENDER_OFFLOAD = 1 __GLX_VENDOR_LIBRARY_NAME = nvidia glxgears Run the following command to see whether the card has turned on: cat /sys/class/drm/card1/device/power/runtime_status Close the test application and wait ~20 seconds to let the graphics card shut itself down. Run the following command to see whether the card has turned off again: cat /sys/class/drm/card1/device/power/runtime_status Expected result The output from the first command should be the word suspended . The output from the second command should be the word active . The output from the third command should be the word suspended . NVI002.002 NVIDIA Graphics power management (Windows 11) Test description This test aims to verify that the NVIDIA graphics power management is functional and the card powers on only while it's used. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Install the driver for the graphics card (GTX 1650) from the official page . Download and extract gputest from Geeks3D . Test steps Open the NVIDIA Control Panel window. In the menu bar, open the Desktop menu. Enable the Display GPU Activity Icon in Notification Area option. Open the system tray located in the bottom right corner of the screen and locate the GPU activity icon: Open the previously extracted gputest directory and open the GPUTest_GUI application. Click on the Run stress test button to start the test application. Locate the GPU activity icon and check that it indicates that the GPU has powered on. Close the test application. Locate the GPU activity icon and check that it indicates that the GPU has powered off again. Expected result The GPU activity icon should indicate that the GPU is OFF when no application is using the GPU. The GPU activity icon should indicate that the GPU is ON when an application is using the GPU. The GPU activity icon should indicate that the GPU is OFF again after the test application is closed.","title":"Nvidia Graphics support"},{"location":"unified-test-documentation/dasharo-compatibility/319-nvidia-graphics/#dasharo-compatibility-nvidia-graphics-support","text":"","title":"Dasharo Compatibility: NVIDIA Graphics support"},{"location":"unified-test-documentation/dasharo-compatibility/319-nvidia-graphics/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/31A-windows-booting/","text":"Dasharo Compatibility: Windows booting Test cases Common Test setup Proceed with the Generic test setup: Firmware . Proceed with the Generic test setup: OS installation . WBT001.001 Windows 11 installation and boot Test description This test aims to verify that Windows 11 OS could be installed on the DUT and works properly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Wait for the OPERATING_SYSTEM to boot and note the result. Expected result The Windows 11 login screen should be displayed. WBT002.001 Windows 10 installation and boot Test description This test aims to verify that Windows 10 OS could be installed on the DUT and works properly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 10 Test setup Proceed with the Common section. Test steps Power on the DUT. Wait for the OPERATING_SYSTEM to boot and note the result. Expected result The Windows 10 login screen should be displayed.","title":"Windows booting"},{"location":"unified-test-documentation/dasharo-compatibility/31A-windows-booting/#dasharo-compatibility-windows-booting","text":"","title":"Dasharo Compatibility: Windows booting"},{"location":"unified-test-documentation/dasharo-compatibility/31A-windows-booting/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/31E-display-ports-and-lcd/","text":"Dasharo Compatibility: Display ports and LCD support Test cases Common Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . DSP001.001 Internal LCD in firmware Test description This test aims to verify initialization of the laptop's embedded LCD screen during firmware execution phase. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Generic test setup: firmware . Test steps Power on the DUT. Observe the internal LCD during firmware execution phase. Power off the DUT. Expected result Logo appears on the screen during firmware execution phase. DSP001.002 Internal LCD in OS (Ubuntu 20.04) Test description This test aims to verify initialization of the laptop's embedded LCD in the OS. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Observe the internal LCD after the OPERATING_SYSTEM has booted. Expected result Either the login screen or the OPERATING_SYSTEM installer appears on the internal LCD. DSP001.003 Internal LCD in OS (Windows 11) Test description This test aims to verify initialization of the laptop's embedded LCD in the OS. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log the by using the proper login and password. Observe the internal LCD after the OPERATING_SYSTEM has booted. Expected result Either the login screen or the OPERATING_SYSTEM installer appears on the internal LCD. DSP002.001 External HDMI display in OS (Ubuntu 20.04) Test description This test aims to verify initialization of the external HDMI display in the OS. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Connect a HDMI cable to the DUT and a display. Test steps Power on the DUT. Boot into the system. Log the by using the proper login and password. If using more than one display, switch the display mode between Mirror and Join Displays . Expected result The image should be displayed on the external HDMI display in Mirror and Join Displays modes. DSP002.002 External HDMI display in OS (Windows 11) Test description This test aims to verify initialization of the external HDMI display in the OS. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Connect a HDMI cable to the DUT and a display. Test steps Power on the DUT. Boot into the system. Log the by using the proper login and password. If using more than one display, switch the display mode between Duplicate and Extend . Expected result The image should be displayed on the external HDMI display in Duplicate and Extend modes. DSP002.003 External HDMI display in firmware This test aims to verify initialization of the external HDMI display during firmware execution phase. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Generic test setup: firmware . Connect a HDMI cable to the DUT and a display. Test steps Power on the DUT. Observe the external HDMI display during firmware execution phase. Power off the DUT. Expected result Logo appears on the screen during firmware execution phase. DSP003.001 External DP display in OS (Ubuntu 20.04) Test description This test aims to verify initialization of the external Display Port connected in the OS. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Connect a Display Port cable to the DUT and a display. Test steps Power on the DUT. Boot into the system. Log the by using the proper login and password. If using more than one display, switch the display mode between Mirror and Join Displays . Expected result The image should be displayed on the external Display Port connected display in Mirror and Join Displays modes. DSP003.002 External DP display in OS (Windows 11) Test description This test aims to verify initialization of the external Display Port connected display in the OS. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Connect a Display Port cable to the DUT and a display. Test steps Power on the DUT. Boot into the system. Log the by using the proper login and password. If using more than one display, switch the display mode between Duplicate and Extend . Expected result The image should be displayed on the external Display Port connected display in Duplicate and Extend modes. DSP003.003 External DP display in firmware This test aims to verify initialization of the external Display Port connected display during firmware execution phase. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Generic test setup: firmware . Connect a Display Port cable to the DUT and a display. Test steps Power on the DUT. Observe the external Display Port connected display during firmware execution phase. Power off the DUT. Expected result Logo appears on the screen during firmware execution phase. DSP004.001 External VGA display in OS (Ubuntu 20.04) Test description This test aims to verify initialization of the external VGA in the OS. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Connect a video input connector to the VGA and a display. Test steps Power on the DUT. Boot into the system. Log the by using the proper login and password. If using more than one display, switch the display mode between Mirror and Join Displays . Expected result The image should be displayed on the external VGA connected display in Mirror and Join Displays modes. DSP004.002 External VGA display in OS (Windows 11) Test description This test aims to verify initialization of the external VGA in the OS. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Connect a video input connector to the VGA and a display. Test steps Power on the DUT. Boot into the system. Log the by using the proper login and password. If using more than one display, switch the display mode between Duplicate and Extend . Expected result The image should be displayed on the external Display Port connected display in Duplicate and Extend modes. DSP004.003 External VGA display in firmware This test aims to verify initialization of the external VGA during firmware execution phase. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Generic test setup: firmware . Connect a video input connector to the VGA and a display. Test steps Power on the DUT. During boot, press BOOT MENU KEY . Observe the external VGA connected display during firmware execution phase. Power off the DUT. Expected result Boot menu appears on the screen during firmware execution phase.","title":"Display ports and LCD"},{"location":"unified-test-documentation/dasharo-compatibility/31E-display-ports-and-lcd/#dasharo-compatibility-display-ports-and-lcd-support","text":"","title":"Dasharo Compatibility: Display ports and LCD support"},{"location":"unified-test-documentation/dasharo-compatibility/31E-display-ports-and-lcd/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/31F-audio-subsystem/","text":"Dasharo Compatibility: Audio subsystem Test cases Common Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . Install the alsa-utils package: sudo apt install alsa-utils . AUD001.001 Audio subsystem detection (Ubuntu 20.04) Test description This test aims to verify that the audio subsystem is initialized correctly and can be detected from the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and execute the following command: cat /sys/class/sound/card0/hwC0D*/chip_name Expected result The output of the command should return a list of detected audio devices: ALC293 Tigerlake HDMI AUD001.002 Audio subsystem detection (Windows 11) Test description This test aims to verify that the audio subsystem is initialized correctly and can be detected from the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Install package AudioDeviceCmdlets : Install-PackageProvider -Name NuGet -Force Install-Module -Name AudioDeviceCmdlets -Force Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Run PowerShell as administrator and execute following command: Get-AudioDevice -list | ft Index , Default , Type , Name Expected result Microphone (Realtek(R) Audio) and Speakers (Realtek(R) Audio) should be listed in the output: Index Default Type Name ----- ------- ---- ---- 1 True Playback Speakers ( Realtek ( R ) Audio ) 2 True Recording Microphone ( Realtek ( R ) Audio ) AUD002.001 Audio playback (Ubuntu 20.04) Test description This test aims to verify that the audio subsystem is able to playback audio recordings. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and execute the following command: pactl set-sink-mute alsa_output.pci-0000_00_1f.3.analog-stereo 0 pactl set-sink-volume alsa_output.pci-0000_00_1f.3.analog-stereo 65535 speaker-test Expected result Sound should be played from the integrated speakers. AUD002.002 Audio playback (Windows 11) Test description This test aims to verify that the audio subsystem is able to playback audio recordings. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Find the Speakers icon in the bottom right part of the screen and click it using the left mouse button to open volume menu. In the volume menu, click the rightmost part of it and note the reult. Expected result Sound should be played from the integrated speakers. AUD003.001 Audio capture (Ubuntu 20.04) Test description This test aims to verify that the audio subsystem is able to capture audio. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and execute the following command: arecord -f S16_LE -d 10 -r 16000 /tmp/test-mic.wav Make some noise aroud DUT. For example, say something. Execute the following command: aplay /tmp/test-mic.wav Expected result Recorded audio clip is recorded correctly and played back. AUD003.002 Audio capture (Windows 11) Test description This test aims to verify that the audio subsystem is able to capture audio. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Find the Speakers icon in the bottom right part of the screen and click it using the right mouse button and then using the left mouse button click Open Sound Settings . Locate the Test your microphone section and observe it. Create some noise for the DUT to capture and note the result. For example, say something. Expected result Audio level bar located in the Test your microphone should raise when some noise is being created. AUD004.001 External headset recognition (Ubuntu 20.04) Test description This test aims to verify that the external headset is properly recognized after plugging in the 3.5 mm jack into the slot. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Plug in a headset jack into micro jack slot located on the right side of the laptop. When the Select Audio Device menu appears, select what type of external device has been connected to the laptop (headset). Open a terminal window and execute the following command: amixer -c 0 contents | grep -A 2 'Front Headphone Jack' Disconnect the headset from the laptop. Execute the following command again: amixer -c 0 contents | grep -A 2 'Front Headphone Jack' Expected result The output of the first command should not be empty and contains the line: : values=on The output of the second command should not be empty and contains the line: : values=off AUD004.002 External headset recognition (Windows 11) Test description This test aims to verify that the external headset is properly recognized after plugging in the 3.5 mm jack into the slot. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Plug in a headset jack into micro jack slot located on the right side of the laptop. After the Which device did you plug in menu appearing, select what type of external device has been connected to the laptop (headset). Find the Speakers icon in the bottom right part of the screen and click it using the right mouse button and then using the left mouse button click Open Sound Settings . Locate Input section and click on the Device properties option. In Device properties window select option Additional device properties . Locate in General the section field named Jack Information . Close the window Microphone properties . Disconnect a headset from the laptop. Select again the Addtional device properties option and locate again field named Jack information . Expected result Jack Information field in the first case should show the position Front Panel 3.5 mm Jack . After disconnecting a headset from the laptop and checking again option Addtional device properties field Jack Information should not contain the phrase Front Panel 3.5 mm Jack . AUD005.001 External headset audio playback (Ubuntu 20.04) Test description This test aims to verify that the audio subsystem is able to playback audio recordings by using the external headset speakers. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Plug in a headset jack into micro jack slot located on the right side of the laptop. Open a terminal window and execute the following command: pactl set-sink-mute alsa_output.pci-0000_00_1f.3.analog-stereo 0 pactl set-sink-volume alsa_output.pci-0000_00_1f.3.analog-stereo 65535 speaker-test Expected result Sound should be played from the external speakers. AUD005.002 External headset audio playback (Windows 11) Test description This test aims to verify that the audio subsystem is able to playback audio recordings by using the external headset speakers. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Plug in a headset jack into micro jack slot located on the right side of the laptop. Find the Speakers icon in the bottom right part of the screen and click it using the left mouse button to open volume menu. In the volume menu, click the rightmost part of it and note the reult. Expected result Sound should be played from the external speakers. AUD006.001 External headset audio capture (Ubuntu 20.04) Test description This test aims to verify that the audio subsystem is able to capture audio from external headset. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Plug in a headset jack into micro jack slot located on the right side of the laptop. Open a terminal window and execute the following command: arecord -f S16_LE -d 10 -r 16000 /tmp/test-mic.wav Make some noise for the headset. For example, say something. Execute the following command: aplay /tmp/test-mic.wav Execute the following command: arecord -f S16_LE -d 10 -r 16000 /tmp/test-mic-1.wav Make some noise for the DUT. For example tap a few times in the laptop casing. Execute the following command: aplay /tmp/test-mic.wav Expected result During playback of the first recording, all noise that was made for headset should be clearly heard. During playback of the second recording, all noise that was made for DUT should be quiet or not heard. AUD006.002 External headset audio capture (Windows 11) Test description This test aims to verify that the audio subsystem is able to capture audio from external headset. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Plug in a headset jack into micro jack slot located on the right side of the laptop. Find the Speakers icon in the bottom right part of the screen and click it using the right mouse button and then using the left mouse button click Open Sound Settings . Locate the Test your microphone section and observe it. Create some noise for the headset to capture and note the result. For example, say something. Create some noise for the DUT. For example tap a few times in the laptop casing. Expected result Audio level bar located in the Test your microphone should raise when some noise have been created for the headset. Audio level bar located in the Test your microphone should not raise when some noise have been created for the DUT.","title":"Audio Subsystem"},{"location":"unified-test-documentation/dasharo-compatibility/31F-audio-subsystem/#dasharo-compatibility-audio-subsystem","text":"","title":"Dasharo Compatibility: Audio subsystem"},{"location":"unified-test-documentation/dasharo-compatibility/31F-audio-subsystem/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/31G-ec-and-superio/","text":"Dasharo Compatibility: Embedded Controller and Super I/O initialization Test cases Common Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . ECR001.001 Battery monitoring - charge level in OS (Ubuntu 20.04) Test description This test verifies whether the battery charge level is reported in the OS. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Locate the power menu in the upper right corner of the screen. Open the power menu and locate the battery status indicator. Expected result The battery status indicator should show the current charge level (percentage left). ECR001.002 Battery monitoring - charge level in OS (Windows 11) Test description This test verifies whether the battery charge level is reported in the OS. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Locate the power menu in the lower right corner of the screen. Expected result The battery status indicator should show the current charge level (percentage left). ECR002.001 Battery monitoring - charging state in OS (Ubuntu 20.04) Test description This test verifies that the power supply state is detected correctly in the OS. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Locate the power menu in the upper right corner of the screen. Open the power menu and locate the battery status indicator. Note the current state. Unplug the power supply and wait for the battery charge state to change to Discharging . Plug in the power supply and wait for the battery charge state to change to Charging . Expected result The battery charge indicator should correctly show whether the power supply is plugged in or not. The battery charge indicator should detect the AC adapter state change within seconds of the adapter being plugged in/out. ECR002.002 Battery monitoring - charging state in OS (Windows 11) Test description This test verifies that the power supply state is detected correctly in the OS. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Locate the power menu in the lower right corner of the screen. Open the power menu and locate the battery status indicator. Note the current state. Unplug the power supply and wait for the battery charge state to change to on battery . Plug in the power supply and wait for the battery charge state to change to plugged in . Expected result The battery charge indicator should correctly show whether the power supply is plugged in or not. The battery charge indicator should detect the AC adapter state change within seconds of the adapter being plugged in / out. ECR003.001 Touchpad in OS - (Ubuntu 20.04) Test description This test verifies that the touchpad is initialized correctly and is detected by the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Install libinput-tools on the DUT. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Verify that the cursor can be moved with the touchpad and that clicking works (test both clicking and tapping). Run sudo libinput debug-events in the terminal: Verify that scrolling with 2 fingers generates a POINTER_AXIS event, Verify that pinching with 2 fingers generates a GESTURE_PINCH_UPDATE event. Press Ctrl + C to terminate the libinput program. Expected result Moving the cursor, clicking, zooming and scrolling are detected correctly by the operating system. ECR003.002 Touchpad in OS - (Windows 11) Test description This test verifies that the touchpad is initialized correctly and is detected by the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Verify that the cursor can be moved with the touchpad and that clicking works (test both clicking and tapping). Open C:\\Windows in Windows Explorer Verify that scrolling with 2 fingers moves the content of the window, Verify that pinching with 2 fingers zooms in and zooms out the content. Expected result Moving the cursor, clicking, zooming and scrolling are detected correctly by the operating system. ECR004.001 Keyboard (standard keypad) in firmware Test description This test verifies that the keyboard is detected correctly by the firmware and all basic keys work according to their labels. Test configuration data FIRMWARE = coreboot BIOS_SETUP_KEY = F2 Test setup Proceed with the Generic test setup: firmware Test steps Power on the DUT and press the BIOS_SETUP_KEY to enter the setup menu. Use the arrow keys and the Enter key to navigate the menus. Expected result All menus can be entered using the internal keyboard. ECR004.002 Keyboard (standard keypad) in OS (Ubuntu 20.04) Test description This test verifies that the keyboard is detected correctly by the operating system and all basic keys work according to their labels. Test configuration data FIRMWARE = coreboot BIOS_SETUP_KEY = F2 OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Install libinput-tools on the DUT. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Run sudo libinput debug-events --show-keycodes in the terminal. Press each keyboard key and check the generated keycode. Expected result All standard keyboard keys generate the correct keycodes and events as per their labels. Key combinations are detected correctly. ECR004.003 Keyboard (standard keypad) in OS (Windows 11) Test description This test verifies that the keyboard is detected correctly by the operating system and all basic keys work according to their labels. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open notepad Test the alphanumeric keys and note the generated characters Test non-alphanumeric keys and verify that they generate the signs Test key combinations with the Shift , and Alt modifier keys Open On-Screen Keyboard and press Ctrl key on the hardware keyboard. Check if On-Screen Keyboard correctly highlights it. Open Start menu and press Esc . Check if Start menu is properly closed. Expected result All standard keyboard keys generate correct characters or actions when pressed. Key combinations are detected correctly. ECR005.001 Keyboard (function key: play/pause) in OS (Ubuntu 20.04) Test description This test verifies that the play/pause hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Install libinput-tools on the DUT. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Run sudo libinput debug-events --show-keycodes in the terminal. Verify that pressing the play/pause key generates a KEY_PLAYPAUSE event. Expected result Pressing the play/pause hotkey generates a KEY_PLAYPAUSE event. ECR005.002 Keyboard (function key: play/pause) in OS (Windows 11) Test description This test verifies that the play/pause hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Start Groove Music Verify that when pressing the play/pause button, player menu apperars in the upper left part of the screen for a few seconds. Expected result Pressing the play/pause hotkey is proreply detected by the OS ECR006.001 Keyboard (function key: cooling mode) in OS (Ubuntu 20.04) Test description This test verifies that the cooling mode hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the cooling mode hotkey (Fn + 1) once and note the effect. Press the cooling mode hotkey once again and note the effect. Expected result Pressing the hotkey once should activate the cooling mode (fans should spin up to their maximum speed). Pressing the hotkey again should deactivate the cooling mode (fans should return to normal). ECR006.002 Keyboard (function key: cooling mode) in OS (Windows 11) Test description This test verifies that the cooling mode hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the cooling mode hotkey (Fn + 1) once and note the effect. Press the cooling mode hotkey once again and note the effect. Expected result Pressing the hotkey once should activate the cooling mode (fans should spin up to their maximum speed). Pressing the hotkey again should deactivate the cooling mode (fans should return to normal). ECR007.001 Keyboard (function key: touchpad on/off) in OS (Ubuntu 20.04) Test description This test verifies that the touchpad on/off hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Proceed with the Common section. Create a file /etc/udev/hwdb.d/60-keyboard.hwdb with the following contents: evdev:atkbd:dmi:bvn*:bvr*:svnNotebook:pnNV4XMB,ME,MZ:* KEYBOARD_KEY_f7 = 191 KEYBOARD_KEY_f8 = 191 Execute the following commands: sudo systemd-hwdb update sudo udevadm trigger Test steps Press the touchpad on/off key and try to use the touchpad. Press the touchpad on/off key once again and try to use the touchpad again. Expected result Pressing the hotkey once should deactivate the touchpad (touchpad should be completely inoperable). Pressing the hotkey again should reactivate the touchpad. ECR007.002 Keyboard (function key: touchpad on/off) in OS (Windows 11) Test description This test verifies that the touchpad on/off hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the touchpad on/off key and try to use the touchpad. Press the touchpad on/off key once again and try to use the touchpad again. Expected result Pressing the hotkey once should deactivate the touchpad (touchpad should be completely inoperable). Pressing the hotkey again should reactivate the touchpad. ECR008.001 Keyboard (function key: display on/off) in OS (Ubuntu 20.04) Test description This test verifies that the display on/off hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the display on/off hotkey once and note the effect. Press any key on the keyboard and note the effect. Expected result Pressing the hotkey once should turn the internal LCD panel off. Pressing any key on the keyboard should power the internal LCD panel back on. ECR008.002 Keyboard (function key: display on/off) in OS (Windows 11) Test description This test verifies that the display on/off hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the display on/off hotkey once and note the effect. Press any key on the keyboard and note the effect. Expected result Pressing the hotkey once should turn the internal LCD panel off. Pressing any key on the keyboard should power the internal LCD panel back on. ECR009.001 Keyboard (function key: mute) in OS (Ubuntu 20.04) Test description This test verifies that the volume mute hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the volume mute hotkey twice and note the effect each keypress has. Expected result Pressing the hotkey should mute or unmute the currently enabled audio output. Each keypress should cause a mute/unmute notification to appear in the middle of the screen. ECR009.002 Keyboard (function key: mute) in OS (Windows 11) Test description This test verifies that the mute hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the mute hotkey once and check the volume indicator in the bottom right part of the screen. Press the mute hotkey once and check the volume indicator again. Expected result Pressing the hotkey once should mute the device Pressing the hotkey again should reenable the sound ECR010.001 Keyboard (function key: keyboard backlight) in OS (Ubuntu 20.04) Test description This test verifies that the keyboard backlight hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the keyboard backlight hotkey 6 times and note the effect on the keyboard backlight after each keypress. Expected result The keyboard has 6 backlight settings from 0% to 100% Each keypress should set the keyboard to the next mode, with the last mode wrapping back around to the first. ECR010.002 Keyboard (function key: keyboard backlight) in OS (Windows 11) Test description This test verifies that the keyboard backlight hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the keyboard backlight hotkey 6 times and note the effect on the keyboard backlight after each keypress. Expected result The keyboard has 6 backlight settings from 0% to 100% Each keypress should set the keyboard to the next mode, with the last mode wrapping back around to the first. ECR011.001 Keyboard (function key: volume down) in OS (Ubuntu 20.04) Test description This test verifies that the volume down hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the volume down hotkey once and note the effects. Expected result Pressing the hotkey should decrease the volume of the currently enabled audio output. Each keypress should cause a volume down notification to appear in the middle of the screen. ECR011.002 Keyboard (function key: volume down) in OS (Windows 11) Test description This test verifies that the volume down hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the volume down hotkey once and note the effects. Expected result Pressing the hotkey should decrease the volume of the currently enabled audio output. Each keypress should cause a volume down notification to appear in the upper left part of the screen. ECR012.001 Keyboard (function key: volume up) in OS (Ubuntu 20.04) Test description This test verifies that the volume up hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the volume up hotkey once and note the effects. Expected result Pressing the hotkey should increase the volume of the currently enabled audio output. Each keypress should cause a volume up notification to appear in the middle of the screen. ECR012.002 Keyboard (function key: volume up) in OS (Windows 11) Test description This test verifies that the volume up hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the volume down hotkey once and note the effects. Expected result Pressing the hotkey should increase the volume of the currently enabled audio output. Each keypress should cause a volume up notification to appear in the upper left part of the screen. ECR013.001 Keyboard (function key: display switch) in OS (Ubuntu 20.04) Test description This test verifies that the display switch hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Install libinput-tools on the DUT. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Run sudo libinput debug-events --show-keycodes in the terminal. Press the display switch hotkey once and note the effect. Expected result Pressing the hotkey should yield the following output in the terminal: -event3 KEYBOARD_KEY +0.000s KEY_LEFTMETA ( 125 ) pressed event3 KEYBOARD_KEY +0.004s KEY_P ( 25 ) pressed event3 KEYBOARD_KEY +0.010s KEY_P ( 25 ) released event3 KEYBOARD_KEY +0.015s KEY_LEFTMETA ( 125 ) released ECR013.002 Keyboard (function key: display switch) in OS (Windows 11) Test description This test verifies that the display switch hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the display switch hotkey once and note the effect. Expected result Pressing the hotkey should cause the display settings bar to appear on the right part of the screen. ECR014.001 Keyboard (function key: brightness down) in OS (Ubuntu 20.04) Test description This test verifies that the brightness down hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test steps Press the brightness down hotkey once and note the effects. Expected result Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Pressing the hotkey should decrease the brightness of the internal LCD display. Each keypress should cause a brightness down notification to appear in the middle of the screen. ECR014.002 Keyboard (function key: brightness down) in OS (Windows 11) Test description This test verifies that the brightness down hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the brightness down hotkey once and note the effects. Expected result Pressing the hotkey should decrease the brightness of the internal LCD display. Each keypress should cause a brightness down notification to appear in the top left of the screen. ECR015.001 Keyboard (function key: brightness up) in OS (Ubuntu 20.04) Test description This test verifies that the brightness up hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the brightness up hotkey once and note the effects. Expected result Pressing the hotkey should increase the brightness of the internal LCD display. Each keypress should cause a brightness up notification to appear in the middle of the screen. ECR015.002 Keyboard (function key: brightness up) in OS (Windows 11) Test description This test verifies that the brightness down hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the brightness up hotkey once and note the effects. Expected result Pressing the hotkey should increase the brightness of the internal LCD display. Each keypress should cause a brightness up notification to appear in the top left of the screen. ECR016.001 Keyboard (function key: camera on/off) in OS (Ubuntu 20.04) Test description This test verifies that the camera on/off hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open the terminal and run the command: watch -n1 lsusb . Press the camera on/off hotkey twice and note the effect after each keypress. Expected result Pressing the hotkey once should make the Chicony Electronics Co., Ltd Chicony USB2.0 Camera device disappear from the output of lsusb . Pressing the hotkey again should make the USB device reappear. ECR016.002 Keyboard (function key: camera on/off) in OS (Windows 11) Test description This test verifies that the camera on/off hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open the Camera app. Press the camera on/off hotkey twice and note the effect after a few seconds after the keypress. Expected result Pressing the hotkey once should make the camera image to disappear. Pressing the hotkey again should make camera image to appear again after a few seconds. ECR017.001 Keyboard (function key: flight mode) in OS (Ubuntu 20.04) Test description This test verifies that the flight mode hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Locate and open the power menu in the upper right corner of the screen. Enter Settings and navigate to the Wi-Fi panel. Note the current state of the Airplane Mode switch. Press the flight mode hotkey twice and note the result of each keypress. Expected result Pressing the hotkey once should enable airplane mode. Pressing the hotkey again should disable airplane mode. ECR017.002 Keyboard (function key: flight mode) in OS (Windows 11) Test description This test verifies that the flight mode hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the camera on/off hotkey twice and note the effect after the keypress. Expected result Pressing the hotkey once should enable airplane mode and cause airplane mode on notification to appear in the top right part of the screen. Pressing the hotkey again should disable airplane mode and cause airplane mode off notification to appear in the top right part of the screen. ECR018.001 Keyboard (function key: sleep) in OS (Ubuntu 20.04) Test description This test verifies that the sleep hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the sleep hotkey once and note the result. Look at the power LED located next to the AC adapter plug, towards the front end of the laptop. Expected result The laptop should go to sleep within seconds of the hotkey being pressed. The power LED should be blinking green, indicating the laptop is sleeping. ECR018.002 Keyboard (function key: sleep) in OS (Windows 11) Test description This test verifies that the sleep hotkey works correctly. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the sleep hotkey once and note the result. Look at the power LED located next to the AC adapter plug, towards the front end of the laptop. Expected result The laptop should go to sleep within seconds of the hotkey being pressed. The power LED should be blinking green, indicating the laptop is sleeping. ECR019.001 Buttons (button: power) in OS (Ubuntu 20.04) Test description This test verifies that the power button is detected correctly by the operating system. In Ubuntu 20.04 OS the default function assigned to this key is suspend mode. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open the terminal and run the following command to check the power button action: gsettings get org.gnome.settings-daemon.plugins.power power-button-action If the status is other than suspend run the following command to change the power button action: gsettings set org.gnome.settings-daemon.plugins.power power-button-action \"suspend\" Check the power button action again by running the following command: gsettings get org.gnome.settings-daemon.plugins.power power-button-action Press the power button once and note the result. Press Enter and note the result. Run the following command to check last finished operation: journalctl | grep systemd-logind | tail -1 Expected result Pressing the button once should make laptop enter sleep mode. The power LED should be blinking green, indicating the laptop is sleeping. After completing the 5th step device should wake up. The output of the last command should contain the line: Operation 'sleep' finished ECR019.002 Buttons (button: power) in OS (Windows 11) Test description This test verifies that the power button is detected correctly by the operating system. In Windows 11 OS the default function assigned to this key is sleep mode. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the power button once and note the result. Expected result Pressing the button once should make laptop enter sleep mode. The power LED should be blinking green, indicating the laptop is sleeping. ECR020.001 Buttons (button: lid switch) in OS (Ubuntu 20.04) Test description This test verifies that the lid switch is detected correctly by the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open one terminal window and run the following command: sudo systemd-inhibit --what handle-lid-switch --mode block watch echo \"Inhibiting lid switch\" Open another terminal and run the command sleep 5 && cat /proc/acpi/button/lid/LID0/state to read the state of the lid while it is closed. Close the lid and wait 5 seconds. Open the lid and note the output of the command. Run the command cat /proc/acpi/button/lid/LID0/state while the lid is open and note the output. Expected result The output of the second command should report that the lid is closed. The output of the third command should report that the lid is open. ECR020.002 Buttons (button: lid switch) in OS (Windows 11) Test description This test verifies that the lid switch is detected correctly by the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Close the lid and note the effect on the power LED. Expected result Pressing the button once should make laptop enter sleep mode. The power LED should be blinking green, indicating the laptop is sleeping. ECR021.001 Keyboard (function key: RGB keyboard toggle) in OS (Ubuntu 20.04) Test description This test verifies that the RGB keyboard toggle hotkey is handled properly by the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the RGB keyboard toggle hotkey twice and note the result each time. Expected result Pressing the button once should disable the keyboard backlight. Pressing the button again should re-enable the keyboard backlight. ECR021.002 Keyboard (function key: RGB keyboard toggle) in OS (Windows 11) Test description This test verifies that the RGB keyboard toggle hotkey is handled properly by the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the RGB keyboard toggle hotkey twice and note the result each time. Expected result Pressing the button once should disable the keyboard backlight. Pressing the button again should re-enable the keyboard backlight. ECR022.001 RGB keyboard next color FN key in OS (Ubuntu 20.04) Test description This test verifies that the RGB keyboard next color hotkey is handled properly by the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the RGB keyboard color hotkey repeatedly until the keyboard cycles through all color modes. Expected result Pressing the button once should switch the keyboard color. All color modes according to product documentation should be accessible. ECR022.002 RGB keyboard next color FN key in OS (Windows 11) Test description This test verifies that the RGB keyboard next color hotkey is handled properly by the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the RGB keyboard color hotkey repeatedly until the keyboard cycles through all color modes. Expected result Pressing the button once should switch the keyboard color. All color modes according to product documentation should be accessible. ECR023.001 RGB keyboard brightness down FN key in OS (Ubuntu 20.04) Test description This test verifies that the RGB keyboard brightness down hotkey is handled properly by the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the RGB keyboard brightness down hotkey and note the result. Expected result Pressing the button once should lower the keyboard backlight ECR023.002 RGB keyboard brightness down FN key in OS (Windows 11) Test description This test verifies that the RGB keyboard brightness down hotkey is handled properly by the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the RGB keyboard brightness down hotkey and note the result. Expected result Pressing the button once should lower the keyboard backlight. ECR024.001 RGB keyboard brightness up FN key in OS (Ubuntu 20.04) Test description This test verifies that the RGB keyboard brightness up hotkey is handled properly by the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the RGB keyboard brightness up hotkey and note the result. Expected result Pressing the button once should increase the keyboard backlight. ECR024.002 RGB keyboard keyboard brightness up FN key in OS (Windows 11) Test description This test verifies that the RGB keyboard brightness up hotkey is handled properly by the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Press the RGB keyboard brightness up hotkey and note the result. Expected result Pressing the button once should increase the keyboard backlight.","title":"Embedded Controller and Super I/O initialization "},{"location":"unified-test-documentation/dasharo-compatibility/31G-ec-and-superio/#dasharo-compatibility-embedded-controller-and-super-io-initialization","text":"","title":"Dasharo Compatibility: Embedded Controller and Super I/O initialization"},{"location":"unified-test-documentation/dasharo-compatibility/31G-ec-and-superio/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/31H-usb-type-c/","text":"Dasharo Compatibility: USB-C/Thunderbolt support with charging and display Test cases Common Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . UTC001.001 USB Type-A charging capability Test description This test verifies that the USB-A ports are able to provide charging to a connected smartphone. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Connect a phone to the USB Type-A port located on the left side of the laptop using a USB cable. Note the charging status on the phone screen. Connect a phone to the USB Type-A port located on the right side of the laptop using a USB cable. Note the charging status on the phone screen. Expected result The smartphone should indicate that it's charging when connected to either USB Type-A port. UTC002.001 Thunderbolt 4 USB Type-C charging capability Test description This test verifies that the Thunderbolt 4 port is able to provide charging to a connected smartphone. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Connect a phone to the Thunderbolt 4 USB Type-C port located on the left side of the laptop using a USB cable. Note the charging status on the phone screen. Expected result The smartphone should indicate that it's charging. UTC003.001 USB Type-C PD laptop charging (Ubuntu 20.04) Test description This test verifies that the laptop can be charged using a USB Type-C PD power supply connected to the Thunderbolt 4 port. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Connect the charger plug to the Thunderbolt 4 USB Type-C port located on the left side of the laptop. Observe the battery indicator located in the top right corner of the screen. Expected result The battery indicator should indicate that the laptop is currently charging. UTC003.002 USB Type-C PD laptop charging (Windows 11) Test description This test verifies that the laptop can be charged using a USB Type-C PD power supply connected to the Thunderbolt 4 port. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Boot into the system. Log into the system by using the proper login and password. Connect the charger plug to the Thunderbolt 4 USB Type-C port located on the left side of the laptop. Observe the battery indicator located in the bottom right corner of the screen. Expected result The battery indicator should indicate that the laptop is currently charging. UTC004.001 USB Type-C Display output (Ubuntu 20.04) Test description This test verifies that the laptop can output video to a display connected via the Thunderbolt 4 USB Type-C port. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Connect a display to the Thunderbolt 4 USB Type-C port located on the left side of the laptop using the USB Type-C hub. Open the Settings application and select the Displays panel in the left menu. Verify that the attached external monitor can be selected. Select and enable the monitor. Expected result The monitor connected to the laptop via the Thunderbolt 4 port should power on and display video from the laptop. UTC004.002 USB Type-C Display output (Windows 11) Test description This test verifies that the laptop can output video to a display connected via the Thunderbolt 4 USB Type-C port. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Connect a display to the Thunderbolt 4 USB Type-C port located on the left. side of the laptop using a USB Type-C hub. Right click on the desktop to open the desktop context menu. Select Display Settings to open the display settings window. Verify that the attached external monitor can be selected. Select and enable the monitor. Expected result The monitor connected to the laptop via the Thunderbolt 4 port should power on and display video from the laptop.","title":"USB type C support"},{"location":"unified-test-documentation/dasharo-compatibility/31H-usb-type-c/#dasharo-compatibility-usb-cthunderbolt-support-with-charging-and-display","text":"","title":"Dasharo Compatibility: USB-C/Thunderbolt support with charging and display"},{"location":"unified-test-documentation/dasharo-compatibility/31H-usb-type-c/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/31I-nvme-switching/","text":"Dasharo Compatibility: M.2 automatic SATA/NVMe switching support Test cases MSS001.001 M.2 automatic SATA/NVMe switching support (Ubuntu 20.04) Test description This test aims to verify detection of the NVMe and SATA disk in M.2 hybrid slot via the Operating System slot. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Generic test setup: firmware . Insert a NVMe disk into the M.2 slot on the DUT. Proceed with the Generic test setup: OS installer . Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and execute sudo parted -l . Check if the connected disk is present on the list. Power off the DUT. Replace the NVMe disk with SATA M.2 disk. Repeat steps 1-5. Expected result The NVMe M.2 disk is detected in OS: Model: SAMSUNG MZVLB256HBHQ-00000 ( nvme ) Disk /dev/nvme0n1: 256GB Sector size ( logical/physical ) : 512B/512B Partition Table: gpt Disk Flags: Number Start End Size File system Name Flags 1 1049kB 2097kB 1049kB 2 2097kB 540MB 538MB fat32 EFI System Partition boot, esp 3 540MB 67 ,6GB 67 ,1GB ext4 6 67 ,6GB 126GB 57 ,9GB ext4 4 126GB 193GB 67 ,7GB ext4 5 193GB 256GB 62 ,9GB ext4 The SATA M.2 disk is detected in OS: Model: ATA Hoodisk SSD ( scsi ) Disk /dev/sda: 32 ,0GB Sector size ( logical/physical ) : 512B/512B Partition Table: gpt Disk Flags: Number Start End Size File system Name Flags 1 1049kB 538MB 537MB fat32 EFI System Partition boot, esp 2 538MB 32 ,0GB 31 ,5GB ext4","title":"M.2 automatic SATA/NVMe switching support"},{"location":"unified-test-documentation/dasharo-compatibility/31I-nvme-switching/#dasharo-compatibility-m2-automatic-satanvme-switching-support","text":"","title":"Dasharo Compatibility: M.2 automatic SATA/NVMe switching support"},{"location":"unified-test-documentation/dasharo-compatibility/31I-nvme-switching/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/31J-sleep-mode/","text":"Dasharo Compatibility: Sleep mode Test cases Common Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . SLM001.001 Sleep mode - battery monitoring (Ubuntu 20.04) Test description This test verifies how quickly the battery discharges while in sleep mode in the OS. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Charge the battery fully (note: due to the manufacturer's settings the maximum battery charge level is limited to 90%; also, the battery charging process can only be started if the current battery level is less than 80%). Disconnect the power supply. Close the lid. Wake up the DUT in the following timestamps and note the battery level: 1 hour from fully charging, 2 hours from fully charging, 3 hours from fully charging, 6 hours from fully charging, (optional) 24 hours from fully charging. Expected result The battery should discharge at a similar rate as in the table below (take the battery wear into account). Time Battery level 0h 90% 1h 88% 2h 86% 3h 84% 6h 80% 24h (optional) 57% SLM000.002 Sleep mode - battery monitoring (Windows 11) Test description This test verifies how quickly the battery discharges while in sleep mode in the OS. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Charge the battery fully (note: due to the manufacturer's settings the maximum battery charge level is limited to 90%; also, the battery charging process can only be started if the current battery level is less than 80%). Disconnect the power supply. Close the lid. Wake up the DUT in the following timestamps and note the battery level: 1 hour from fully charging, 2 hours from fully charging, 3 hours from fully charging, 6 hours from fully charging, Expected result The battery should discharge at a similar rate as in the table below (take the battery wear into account). Time Battery level 0h 90% 1h 79% 2h 69% 3h 58% 6h 26%","title":"Sleep mode"},{"location":"unified-test-documentation/dasharo-compatibility/31J-sleep-mode/#dasharo-compatibility-sleep-mode","text":"","title":"Dasharo Compatibility: Sleep mode"},{"location":"unified-test-documentation/dasharo-compatibility/31J-sleep-mode/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/31K-minipcie-verification/","text":"Dasharo Compatibility: miniPCIe slot verification Test cases Common Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . MWL001.001 Wireless card detection (Ubuntu 20.04) Test description This test aims to verify that the Wi-Fi/Bluetooth card is enumerated correctly and can be detected from the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and execute the following command: lspci | grep Network controller Expected result The output of the command should contain the line: 2f:00.0 Network controller: Intel Corporation Wi-Fi 6 AX200 ( rev 1a ) The exact name and revision may be different depending on hardware configuration. MWL001.002 Wireless card detection (Windows 11) Test description This test aims to verify that the Wi-Fi/Bluetooth card is enumerated correctly and can be detected from the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open PowerShell and execute following command: Get-PnpDevice -PresentOnly | Select-String -Pattern \"Wi-Fi\" Note the result. Expected result The output of the command should contain a line starting with: Intel ( R ) Wi-Fi 6AX200 160MHz or a line starting with: Intel ( R ) Wi-Fi 6AX201 160MHz MWL002.001 Wi-Fi scanning (Ubuntu 20.04) Test description This test aims to verify that the Wi-Fi functionality of card is initialized correctly and can be used from within the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Make sure to have any Wi-Fi signal available. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and execute the following commands as root: nmcli radio wifi on nmcli device wifi rescan # Wait ~5 seconds nmcli device wifi list Expected result The output of the last command should return a list of available Wi-Fi networks, for example: IN-USE BSSID SSID MODE CHAN RATE SIGNAL BARS SECURITY XX:XX:XX:XX:XX:XX DIRECT-ny Infra 6 65 Mbit/s 75 \u2582\u2584\u2586_ WPA2 * XX:XX:XX:XX:XX:XX 3mdeb_abr_5GHz Infra 48 405 Mbit/s 72 \u2582\u2584\u2586_ WPA2 XX:XX:XX:XX:XX:XX 3mdeb_abr Infra 11 54 Mbit/s 69 \u2582\u2584\u2586_ WPA2 XX:XX:XX:XX:XX:XX FunBox2-F9BF_2.4GHz Infra 1 130 Mbit/s 50 \u2582\u2584__ WPA1 WPA2 XX:XX:XX:XX:XX:XX H_Office Infra 2 270 Mbit/s 35 \u2582\u2584__ WPA2 XX:XX:XX:XX:XX:XX DIRECT-xpPhaser 3330 Infra 1 65 Mbit/s 34 \u2582\u2584__ WPA2 XX:XX:XX:XX:XX:XX Orange_Swiatlowod_A79A Infra 108 540 Mbit/s 32 \u2582\u2584__ WPA2 XX:XX:XX:XX:XX:XX DIRECT-KRM288x Series Infra 11 54 Mbit/s 22 \u2582___ WPA2 XX:XX:XX:XX:XX:XX Orange_Swiatlowod_A79A Infra 11 130 Mbit/s 20 \u2582___ WPA2 XX:XX:XX:XX:XX:XX DIRECT-ejPhaser 3330 Infra 1 65 Mbit/s 17 \u2582___ WPA2 XX:XX:XX:XX:XX:XX NED-WIFI Infra 11 270 Mbit/s 17 \u2582___ WPA2 MWL002.002 Wi-Fi scanning (Windows 11) Test description This test aims to verify that the Wi-Fi functionality of card is initialized correctly and can be used from within the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Make sure to have any Wi-Fi signal available Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open PowerShell and execute following command: netsh wlan show network Note the result. Expected result Output should contain 3mdeb_abr and/or 3mdeb_abr_5GHz . Example output: SSID 1 : 3mdeb_abr Network type : Infrastructure Authentication : WPA2-Personal Encryption : CCMP SSID 2 : Sonoff1 192 . 168 . 4 . 208 Hotspot Network type : Infrastructure Authentication : WPA2-Personal Encryption : CCMP SSID 3 : Orange_Swiatlowod_F1A0 Network type : Infrastructure Authentication : WPA2-Personal Encryption : CCMP SSID 4 : Sonoff1 Fallback Hotspot Network type : Infrastructure Authentication : WPA2-Personal Encryption : CCMP SSID 5 : DIRECT-KRM288x Series Network type : Infrastructure Authentication : WPA2-Personal Encryption : CCMP MWL003.001 Bluetooth scanning (Ubuntu 20.04) Test description This test aims to verify that the Bluetooth functionality of card is initialized correctly and can be used from within the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Enable Bluetooth and make it discoverable in any device nearby DUT. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and execute the following commands: bluetoothctl power on scan on # Wait ~5 seconds devices Expected result The output of the last command should return a list of detectable Bluetooth devices, for example: Device XX:XX:XX:XX:XX:XX Device 1 Device XX:XX:XX:XX:XX:XX Wojtek N Device XX:XX:XX:XX:XX:XX Mi Smart Band 4 Device XX:XX:XX:XX:XX:XX Galaxy Watch4 Classic ( PHLM ) Device XX:XX:XX:XX:XX:XX Galaxy Watch4 Classic ( PHLM ) Device XX:XX:XX:XX:XX:XX Device 2 Device XX:XX:XX:XX:XX:XX [ Signage ] Samsung QMR Series Device XX:XX:XX:XX:XX:XX [ Signage ] Samsung QMR Series Device XX:XX:XX:XX:XX:XX Device 3 Device XX:XX:XX:XX:XX:XX Device 4 Device XX:XX:XX:XX:XX:XX Device 5 Device XX:XX:XX:XX:XX:XX Device 6 MWL003.002 Bluetooth scanning (Windows 11) Test description This test aims to verify that the Bluetooth functionality of card is initialized correctly and can be used from within the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Enable Bluetooth and make it discoverable in any device nearby DUT Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Enter Notification Center in the bottom right part of the screen. Using right mouse button click on the Bluetooth icon. In shown drop-down menu click Go to settings . Click the + icon described as Add Bluetooth or other device . In the Add a device menu click Bluetooth . Wait a few moments until DUT scans for nearby Bluetooth devices and note the result. Expected result Available Bluetooth devices should appear in the Add a device window. MWL004.001 LTE card detection (Ubuntu 20.04) Test description This test aims to verify that the LTE card is detected correctly in the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Plug the LTE card into miniPCIe slot. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and execute lsusb Expected result The output of the command should return a list of USB devices including LTE module, for example: Bus 001 Device 004 : ID 05c6:9215 Qualcomm, Inc. Quectel EC20 LTE modem","title":"miniPCIe slot verification"},{"location":"unified-test-documentation/dasharo-compatibility/31K-minipcie-verification/#dasharo-compatibility-minipcie-slot-verification","text":"","title":"Dasharo Compatibility: miniPCIe slot verification"},{"location":"unified-test-documentation/dasharo-compatibility/31K-minipcie-verification/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/31L-smbios/","text":"Dasharo compatibility: SMBIOS Test cases Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . Install the dmidecode package: sudo apt-get install dmidecode . DMI001.001 Verify the serial number Test description This test aims to verify that the serial number field is filled in correctly according to the Dasharo SMBIOS guidelines . Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Open a terminal window and execute the following command: dmidecode -t system In the BIOS Information section, check the Serial number field against the Dasharo SMBIOS guidelines . Expected result The fields should be filled in according to the Dasharo SMBIOS guidelines. DMI002.001 Verify the firmware version Test description This test aims to verify that the firmware version field is filled in correctly according to the Dasharo SMBIOS guidelines . Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Open a terminal window and execute the following command: dmidecode -t bios In the BIOS Information section, check the Version field against the Dasharo SMBIOS guidelines . Expected result The fields should be filled in according to the Dasharo SMBIOS guidelines. DMI003.001 Verify the firmware product name Test description This test aims to verify that the firmware product name fields are filled in correctly according to the Dasharo SMBIOS guidelines . Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Open a terminal window and execute the following command: dmidecode -t system In the System Information section, check the Product Name field against the Dasharo SMBIOS guidelines . Execute the following command in the terminal: dmidecode -t baseboard In the Base Board Information section, check the Product Name field against the Dasharo SMBIOS guidelines . Expected result The fields should be filled in according to the Dasharo SMBIOS guidelines. DMI004.001 Verify the firmware release date Test description This test aims to verify that the firmware release date field are filled in correctly according to the Dasharo SMBIOS guidelines . Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Open a terminal window and execute the following command: dmidecode -t bios In the System Information section, check the Release Date field against the Dasharo SMBIOS guidelines . Expected result The field should be filled in according to the Dasharo SMBIOS guidelines. DMI005.001 Verify the firmware manufacturer Test description This test aims to verify that the firmware manufacturer fields are filled in correctly according to the Dasharo SMBIOS guidelines . Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Open a terminal window and execute the following command: dmidecode -t system In the System Information section, check the Manufacturer field against the Dasharo SMBIOS guidelines . Execute the following command in the terminal: dmidecode -t baseboard In the Base Board Information section, check the Manufacturer field against the Dasharo SMBIOS guidelines . Expected result The fields should be filled in according to the Dasharo SMBIOS guidelines. DMI006.001 Verify the firmware vendor Test description This test aims to verify that the firmware vendor field is filled in correctly according to the Dasharo SMBIOS guidelines . Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Open a terminal window and execute the following command: dmidecode -t bios In the BIOS Information section, check the Vendor field against the Dasharo SMBIOS guidelines . Expected result The field should be filled in according to the Dasharo SMBIOS guidelines. DMI007.001 Verify the firmware family Test description This test aims to verify that the firmware family field is filled in correctly according to the Dasharo SMBIOS guidelines . Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Open a terminal window and execute the following command: dmidecode -t system In the System Information section, check the Family field against the Dasharo SMBIOS guidelines . Expected result The field should be filled in according to the Dasharo SMBIOS guidelines. DMI008.001 Verify the firmware type Test description This test aims to verify that the firmware type field is filled in correctly according to the Dasharo SMBIOS guidelines . Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Test steps Open a terminal window and execute the following command: dmidecode -t chassis In the Chassis Information section, check the Type field against the Dasharo SMBIOS guidelines . Expected result The field should be filled in according to the Dasharo SMBIOS guidelines.","title":"SMBIOS"},{"location":"unified-test-documentation/dasharo-compatibility/31L-smbios/#dasharo-compatibility-smbios","text":"","title":"Dasharo compatibility: SMBIOS"},{"location":"unified-test-documentation/dasharo-compatibility/31L-smbios/#test-cases","text":"Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . Install the dmidecode package: sudo apt-get install dmidecode .","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/31M-emmc-support/","text":"Dasharo Compatibility: eMMC support Test cases MMC001.001 eMMC support (Ubuntu 20.04) Test description This test aims to verify detection of the eMMC driver via the Operating System. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and execute sudo parted -l . Check if the eMMC is present on the list. Expected result The eMMC disk is detected in OS: Model: MMC 8GTF4R ( sd/mmc ) Disk /dev/mmcblk0: 7818MB Sector size ( logical/physical ) : 512B/512B Partition Table: msdos Disk Flags: Number Start End Size Type File system Flags 1 1049kB 538MB 537MB primary fat32 2 538MB 1076MB 538MB primary fat32 boot, esp 3 1077MB 7817MB 6740MB extended 5 1077MB 7817MB 6740MB logical ext4","title":"eMMC support"},{"location":"unified-test-documentation/dasharo-compatibility/31M-emmc-support/#dasharo-compatibility-emmc-support","text":"","title":"Dasharo Compatibility: eMMC support"},{"location":"unified-test-documentation/dasharo-compatibility/31M-emmc-support/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/31M-platform-suspend-and-resume/","text":"Dasharo Compatibility: Platform suspend and resume Test cases SUSP001.001 Platform suspend and resume Test description This test verifies whether the DUT might be put into suspend mode and then, by using the power button, might be properly resumed. This test case may be re-done several times to specify the platform stability. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Debian 11.0 Test setup Proceed with the Generic test setup: firmware . Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and execute the following command: date Write down the output of the above-mentioned command. Execute the following command in the terminal: systemctl suspend -i Check the status of the platform. Press the power button once and note the result. Execute the following command in the terminal: journalctl | grep suspend Expected result After running suspend command the platform should enter the suspend mode. After pressing power button the platform should initiate the resume procedure. Output of the last command should contains the line with the following statement: systemd-suspend.service: Succeeded Date of the above-described event should be later than date from command date from the test steps' fourth point.","title":"Platform suspend and resume"},{"location":"unified-test-documentation/dasharo-compatibility/31M-platform-suspend-and-resume/#dasharo-compatibility-platform-suspend-and-resume","text":"","title":"Dasharo Compatibility: Platform suspend and resume"},{"location":"unified-test-documentation/dasharo-compatibility/31M-platform-suspend-and-resume/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/31N-usb-boot/","text":"Dasharo Compatibility: USB Boot Test cases UBB001.001 USB detect and boot after coldboot Test description This test aims to verify that the DUT properly detects USB device and boots into the operating system after coldboot (reboot realized by power supply cutting off then restoring back). This test case may be re-done several times to specify the platform and connection stability. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Debian 11.0 Test setup Proceed with the Generic test setup: firmware . Test steps Cut the power off. Restore power to the DUT. Wait for boot until BOOT_MENU_STRING appears. Press BOOT_MENU_KEY to enter the boot menu. Check if USB_STICK entry is available. Select the proper number for USB_STICK option. Wait for Debian GNU/Linux . Expected result The Debian GNU/Linux is visible and confirms successful boot into OS after coldboot. UBB002.001 USB detect and boot after warmboot Test description This test aims to verify that the DUT properly detects USB device and boots into the operating system after warmboot (reboot realized by device turning off then turning on). This test case may be re-done several times to specify the platform and connection stability. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Debian 11.0 Test setup Proceed with the Generic test setup: firmware . Test steps Power on the DUT. Wait for boot until BOOT_MENU_STRING appears. Press BOOT_MENU_KEY to enter the boot menu. Check if USB_STICK entry is available. Select the proper number for USB_STICK option. Wait for Debian GNU/Linux . Expected result The Debian GNU/Linux is visible and confirms successful boot into OS after warmboot. UBB003.001 USB detect and boot after system reboot Test description This test aims to verify that the DUT properly detects USB device and boots into the operating system after system reboot (reboot performed by relevant command). This test case may be re-done several times to specify the platform and connection stability. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Debian 11.0 Test setup Proceed with the Generic test setup: firmware . Test steps Power on the DUT. Wait for boot until BOOT_MENU_STRING appears. Press BOOT_MENU_KEY to enter the boot menu. Check if USB_STICK entry is available. Select the proper number for USB_STICK option. Wait for Debian GNU/Linux . Wait for debian login: . Type the root login. Wait for Password: . Type the proper password. Wait for root@debian:~# . Execute reboot command. Wait for boot until BOOT_MENU_STRING appears. Press BOOT_MENU_KEY to enter the boot menu. Check if USB_STICK entry is available. Select the proper number for USB_STICK option. Wait for Debian GNU/Linux . Expected result The Debian GNU/Linux is visible and confirms successful boot into OS after system reboot.","title":"USB booting"},{"location":"unified-test-documentation/dasharo-compatibility/31N-usb-boot/#dasharo-compatibility-usb-boot","text":"","title":"Dasharo Compatibility: USB Boot"},{"location":"unified-test-documentation/dasharo-compatibility/31N-usb-boot/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/31O-usb-detect/","text":"Dasharo Compatibility: USB Detection Test cases USB001.001 USB detection after coldboot Test description This test aims to verify that the DUT properly detects USB device after coldboot (reboot realized by power supply cutting off then restoring back). This test case may be re-done several times to specify the platform and connection stability. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Debian 11.0 Test setup Proceed with the Generic test setup: firmware . Test steps Cut the power off. Restore power to the DUT. Wait for boot until BOOT_MENU_STRING appears. Press BOOT_MENU_KEY to enter the boot menu. Check if USB_STICK entry is available. Expected result The USB_STICK entry is visible which confirms successful detection after coldboot. USB002.001 USB detect and boot after warmboot Test description This test aims to verify that the DUT properly detects USB device after warmboot (reboot realized by device turning off then turning on). This test case may be re-done several times to specify the platform and connection stability. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Debian 11.0 Test setup Proceed with the Generic test setup: firmware . Test steps Power on the DUT. Wait for boot until BOOT_MENU_STRING appears. Press BOOT_MENU_KEY to enter the boot menu. Check if USB_STICK entry is available. Expected result The USB_STICK entry is visible which confirms successful detection after warmboot. USB003.001 USB detect and boot after system reboot Test description This test aims to verify that the DUT properly detects USB device after system reboot (reboot performed by relevant command). This test case may be re-done several times to specify the platform and connection stability. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Debian 11.0 Test setup Proceed with the Generic test setup: firmware . Test steps Power on the DUT. Wait for boot until BOOT_MENU_STRING appears. Press BOOT_MENU_KEY to enter the boot menu. Check if USB_STICK entry is available. Select the key with a proper number for iPXE . Press Ctrl+B when prompted to stop iPXE from booting automatically. Wait until iPXE> prompt appears. Type in dhcp to obtain an IP address. Type in chain and local iPXE address after a single space to load a network boot menu. Select Debian stable netboot 4.14.y option below iPXE boot menu header. Wait for debian login: . Type the root login. Wait for Password: . Type the proper password. Wait for root@debian:~# . Execute reboot command. Wait for boot until BOOT_MENU_STRING appears. Press BOOT_MENU_KEY to enter the boot menu. Check if USB_STICK entry is available. Expected result The USB_STICK entry is visible which confirms successful detection after system reboot.","title":"USB detection"},{"location":"unified-test-documentation/dasharo-compatibility/31O-usb-detect/#dasharo-compatibility-usb-detection","text":"","title":"Dasharo Compatibility: USB Detection"},{"location":"unified-test-documentation/dasharo-compatibility/31O-usb-detect/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/31P-flash-write-protection/","text":"Dasharo Security: Flash write protection Test cases Common Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Make yourself familiar with SPI hardware write protection . HWP001.001 Hardware flash write protection support Test description This test aims to verify whether the DUT supports hardware write protection mechanism. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Debian 11.0 Test setup Proceed with the Common section. Test steps Open a terminal window and execute the following command: sudo ./flashrom -p internal --wp-list Expected result The output of the command should contain the information about lst of available write protection ranges, exmaple has been shown below: Available write protection ranges: start = 0x00000000 length = 0x00000000 ( none ) start = 0x00000000 length = 0x00001000 ( lower 1 /2048 ) start = 0x007ff000 length = 0x00001000 ( upper 1 /2048 ) start = 0x00000000 length = 0x00002000 ( lower 1 /1024 ) start = 0x007fe000 length = 0x00002000 ( upper 1 /1024 ) start = 0x00000000 length = 0x00004000 ( lower 1 /512 ) start = 0x007fc000 length = 0x00004000 ( upper 1 /512 ) start = 0x00000000 length = 0x00008000 ( lower 1 /256 ) start = 0x007f8000 length = 0x00008000 ( upper 1 /256 ) start = 0x00000000 length = 0x00020000 ( lower 1 /64 ) start = 0x007e0000 length = 0x00020000 ( upper 1 /64 ) start = 0x00000000 length = 0x00040000 ( lower 1 /32 ) start = 0x007c0000 length = 0x00040000 ( upper 1 /32 ) start = 0x00000000 length = 0x00080000 ( lower 1 /16 ) start = 0x00780000 length = 0x00080000 ( upper 1 /16 ) start = 0x00000000 length = 0x00100000 ( lower 1 /8 ) start = 0x00700000 length = 0x00100000 ( upper 1 /8 ) start = 0x00000000 length = 0x00200000 ( lower 1 /4 ) start = 0x00600000 length = 0x00200000 ( upper 1 /4 ) start = 0x00000000 length = 0x00400000 ( lower 1 /2 ) start = 0x00400000 length = 0x00400000 ( upper 1 /2 ) start = 0x00000000 length = 0x00600000 ( lower 3 /4 ) start = 0x00200000 length = 0x00600000 ( upper 3 /4 ) start = 0x00000000 length = 0x00700000 ( lower 7 /8 ) start = 0x00100000 length = 0x00700000 ( upper 7 /8 ) start = 0x00000000 length = 0x00780000 ( lower 15 /16 ) start = 0x00080000 length = 0x00780000 ( upper 15 /16 ) start = 0x00000000 length = 0x007c0000 ( lower 31 /32 ) start = 0x00040000 length = 0x007c0000 ( upper 31 /32 ) start = 0x00000000 length = 0x007e0000 ( lower 63 /64 ) start = 0x00020000 length = 0x007e0000 ( upper 63 /64 ) start = 0x00000000 length = 0x007f8000 ( lower 255 /256 ) start = 0x00008000 length = 0x007f8000 ( upper 255 /256 ) start = 0x00000000 length = 0x007fc000 ( lower 511 /512 ) start = 0x00004000 length = 0x007fc000 ( upper 511 /512 ) start = 0x00000000 length = 0x007fe000 ( lower 1023 /1024 ) start = 0x00002000 length = 0x007fe000 ( upper 1023 /1024 ) start = 0x00000000 length = 0x007ff000 ( lower 2047 /2048 ) start = 0x00001000 length = 0x007ff000 ( upper 2047 /2048 ) start = 0x00000000 length = 0x00800000 ( all ) HWP002.001 Hardware flash write protection enable / disable Test description This test aims to verify whether there is a possibility to set and erase hardware write protection on the DUT. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Debian 11.0 Test setup Proceed with the Common section. Test steps Based on the documentation erase current write protection. Based on the documentation set write protection for a specific range. Execute the following command in the terminal to check the status and the range of write protection: sudo ./flashrom -p internal --wp-status Expected result The output of the command should contain the information about protection mode: Protection mode: hardware Protection range: read from the command output and set before should be the same. CBMEM003.001 Serial boot measure: coreboot booting time after system reboot Test description This test aims to verify whether the DUT boots after system reboot and how long this process takes. This test case may be re-done several times to to average the results and specify the platform stability. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Debian 11.0 Test setup Proceed with the Common section. Test steps Open a terminal window and execute the following command: sudo ./cbmem -T Expected result The output of the command should contain the information about duration of all boot stages.","title":"Flash write protection"},{"location":"unified-test-documentation/dasharo-compatibility/31P-flash-write-protection/#dasharo-security-flash-write-protection","text":"","title":"Dasharo Security: Flash write protection"},{"location":"unified-test-documentation/dasharo-compatibility/31P-flash-write-protection/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/31T-cpu-status/","text":"Dasharo Compatibility: CPU Status Test cases Common Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . CPU001.001 CPU works Test description Check whether the mounted on the DUT CPU works. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Debian 11.0 Test setup Proceed with the Common section. Test steps Power on the DUT. Wait for the OPERATING_SYSTEM to boot and note the result. Expected result The OPERATING_SYSTEM screen should be displayed. CPU002.001 CPU cache enabled Test description Check whether all declared for the DUT cache levels are enabled. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Debian 11.0 Test setup Proceed with the Common section. Test steps Power on the DUT. Wait for the OPERATING_SYSTEM to boot. Execute below command in terminal: getconf -a | grep CACHE Note the result. Expected result The utput of the command should contain information about all cache levels, their size and association. Example output: LEVEL1_ICACHE_SIZE 32768 LEVEL1_ICACHE_ASSOC 32 LEVEL1_ICACHE_LINESIZE 128 LEVEL1_DCACHE_SIZE 32768 LEVEL1_DCACHE_ASSOC 32 LEVEL1_DCACHE_LINESIZE 128 LEVEL2_CACHE_SIZE 524288 LEVEL2_CACHE_ASSOC 2048 LEVEL2_CACHE_LINESIZE 32 LEVEL3_CACHE_SIZE 10485760 LEVEL3_CACHE_ASSOC 40960 LEVEL3_CACHE_LINESIZE 32 LEVEL4_CACHE_SIZE 0 LEVEL4_CACHE_ASSOC 0 LEVEL4_CACHE_LINESIZE 0 CPU003.001 Multiple CPU support Test description Check whether the DUT has multiple CPU support. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Debian 11.0 Test setup Proceed with the Common section. Test steps Power on the DUT. Wait for the OPERATING_SYSTEM to boot. Execute below command in terminal: lscpu Note the result. Expected result The output of the command should contain basic information about the CPU, including the number of the CPU (s) . If CPU(s) are more than 1, the DUT has multiple CPU support. Example results: Architecture: ppc64le Byte Order: Little Endian CPU ( s ) : 32 On-line CPU ( s ) list: 0 -31 Thread ( s ) per core: 4 Core ( s ) per socket: 4 Socket ( s ) : 2 NUMA node ( s ) : 2 CPU004.001 Multiple-core support Test description Check whether the DUT has multi-core support. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Debian 11.0 Test setup Proceed with the Common section. Test steps Power on the DUT. Wait for the OPERATING_SYSTEM to boot. Execute below command in terminal: lscpu Note the result. Expected result The output of the command should contain basic information about the CPU, including the number of the Core(s) per socket . If Core(s) per socket are more than 1, the DUT has multi-core support. Example results: Architecture: ppc64le Byte Order: Little Endian CPU ( s ) : 32 On-line CPU ( s ) list: 0 -31 Thread ( s ) per core: 4 Core ( s ) per socket: 4 Socket ( s ) : 2 NUMA node ( s ) : 2","title":"CPU status"},{"location":"unified-test-documentation/dasharo-compatibility/31T-cpu-status/#dasharo-compatibility-cpu-status","text":"","title":"Dasharo Compatibility: CPU Status"},{"location":"unified-test-documentation/dasharo-compatibility/31T-cpu-status/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/31U-heads-bootloader-support/","text":"Dasharo Compatibility: Heads bootloader support Test cases Common Test setup Proceed with the Generic test setup: firmware . Make yourself familiar with Heads installation . HDS001.001 Boot into Heads Test description This test verifies that the DUT during booting procedure reaches Heads bootloader. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Common section. Test steps Flash bootkernel partition in accordance with the documentation . Power on the DUT. Wait for the Heads to boot and note the result. Expected result The Heads bootloader screen should be displayed.","title":"Heads bootloader support"},{"location":"unified-test-documentation/dasharo-compatibility/31U-heads-bootloader-support/#dasharo-compatibility-heads-bootloader-support","text":"","title":"Dasharo Compatibility: Heads bootloader support"},{"location":"unified-test-documentation/dasharo-compatibility/31U-heads-bootloader-support/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/31V-petitboot-payload-support/","text":"Dasharo Compatibility: Petitboot payload support Test cases Common Test setup Proceed with the Generic test setup: firmware . PBT001.001 Boot into Petitboot Test description This test verifies that the DUT during booting procedure reaches Petitboot menu. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Common section. Test steps Power on the DUT. Wait for the Petitboot to boot and note the result. Expected result The Petitbooot menu screen should be displayed. PBT002.001 Read System Information from Petitboot Test description This test verifies that Petitboot System Information option is available and works correctly. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Common section. Test steps Power on the DUT. Wait for the Petitboot to boot. Select the System Information option using the arrow keys and press Enter . Note the result. Expected result After select System Information option, device information tree should be displayed. PBT003.001 Rescan Devices by Petitboot Test description This test verifies that Petitboot Rescan Device option is available and works correctly. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Common section. Test steps Power on the DUT. Wait for the Petitboot to boot. Select the Rescan Devices option using the arrow keys and press Enter . Note the results. Attach USB Stick with bootable system to USB port in DUT. Select the Rescan Devices again and note the results. Expected result Information about the attached USB Stick should be displayed after the second use of the Rescan Devices option.","title":"Petitboot payload support"},{"location":"unified-test-documentation/dasharo-compatibility/31V-petitboot-payload-support/#dasharo-compatibility-petitboot-payload-support","text":"","title":"Dasharo Compatibility: Petitboot payload support"},{"location":"unified-test-documentation/dasharo-compatibility/31V-petitboot-payload-support/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/31W-device-tree/","text":"Dasharo compatibility: Device tree Test cases Common Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . DVT001.001 Node with coreboot exists Test description This test aims to verify whether the node with the coreboot exists in Device Tree. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Debian 11.0 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and run the follwing command: xxd /sys/firmware/devicetree/base/firmware/coreboot/compatible Note the result. Expected result The output of the command should contain information about memory sectors dedicated for coreboot. Example output: 00000000 : 636f 7265 626f 6f74 00 coreboot DVT002.001 Memory for coreboot is reserved (Ubuntu 20.04) Test description This test aims to verify that in the system exists reserved memory for coreboot. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Debian 11.0 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and run the follwing command: xxd /sys/firmware/devicetree/base/firmware/coreboot/reg Note the results. Run the following command in the terminal: xxd /sys/firmware/devicetree/base/reserved-memory/ranges Expected result Output of the first command should contain information about memory ranges for corebotot. Output of the second command should contain information about reserved ranges. All memory range for coreboot (output from command 1) should be reserved (output from command 2).","title":"Device Tree"},{"location":"unified-test-documentation/dasharo-compatibility/31W-device-tree/#dasharo-compatibility-device-tree","text":"","title":"Dasharo compatibility: Device tree"},{"location":"unified-test-documentation/dasharo-compatibility/31W-device-tree/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/320-fwupd-firmware-update/","text":"Dasharo Compatibility: Firmware update using fwupd Test cases Common Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . Install the dmidecode package: sudo apt install dmidecode . Make yourself familiar with Updating firmware using fwupd FFW001.001 Firmware update by using fwupd Test description This test verify whether it is possible to update the firmware on the DUT by using fwupd demon. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Common section. Disable Secure Boot . Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Configure environment in accordance with the documentation Start firmware updating procedure by executing the following command in the terminal: sudo fwupdmgr update Reboot the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and run the following command to verify results: sudo dmidecode -t bios Expected result The output of dmidecode command should contain information about current firmware. The current firmware version should be equal to the latest released firmware version. Example output: BIOS Information Vendor: 3mdeb Version: Dasharo ( coreboot+UEFI ) v1.1.0 Release Date: 03 /24/2022 ROM Size: 16 MB Characteristics: PCI is supported PC Card ( PCMCIA ) is supported BIOS is upgradeable BIOS shadowing is allowed Selectable boot is supported ACPI is supported USB legacy is supported Targeted content distribution is supported UEFI is supported BIOS Revision: 1 .1 Firmware Revision: 0 .0","title":"Firmware update using fwupd"},{"location":"unified-test-documentation/dasharo-compatibility/320-fwupd-firmware-update/#dasharo-compatibility-firmware-update-using-fwupd","text":"","title":"Dasharo Compatibility: Firmware update using fwupd"},{"location":"unified-test-documentation/dasharo-compatibility/320-fwupd-firmware-update/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/321-docking-station-usb-c/","text":"Dasharo Compatibility: Docking station USB-C Test cases Common Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . DUC001.001 USB Type-C laptop charging (Ubuntu 22.04) Test description This test aims to verify whether the DUT can be charged using a USB Type-C PD power supply connected to the docking station, which is connected to the Thunderbolt 4 port. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 22.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Disconnect any charger from the DUT. Connect the docking station to the Thunderbolt 4 port located on the casing of the DUT. Connect the charger plug to the docking station. Open a terminal window and run the follwing command: cat /sys/class/power_supply/BAT0/status Note the results Expected result Output of the command should show one of this: Charging or Full . That means laptop is charged properly. Example output: Charging DUC001.002 USB Type-C laptop charging (Windows 11) Test description This test aims to verify whether the DUT can be charged using a USB Type-C PD power supply connected to the docking station, which is connected to the Thunderbolt 4 port. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Connect the docking station to the Thunderbolt 4 port located on the left side of the laptop. Connect the charger plug to the docking station. Open PowerShell and and run the follwing command: Get-WmiObject win32_battery Note the results Expected result If BatteryStatus is equal 2, that means laptop is charged properly. Example part of output: BatteryStatus : 2","title":"Docking station USB-C"},{"location":"unified-test-documentation/dasharo-compatibility/321-docking-station-usb-c/#dasharo-compatibility-docking-station-usb-c","text":"","title":"Dasharo Compatibility: Docking station USB-C"},{"location":"unified-test-documentation/dasharo-compatibility/321-docking-station-usb-c/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/322-docking-station-audio/","text":"Dasharo Compatibility: Docking station audio Test cases Common Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . The docking station connected to the USB-C port. DAU001.001 Audio recognition (Ubuntu 22.04) Test description This test aims to verify that the external headset is properly recognized after plugging in the 3.5 mm jack into the docking station. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 22.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Plug in a headset jack into the docking station. When the Select Audio Device menu appears, select what type of external device has been connected to the laptop (headset). Open a terminal window and execute the following command: amixer -c 0 contents | grep -A 2 'Front Headphone Jack' Disconnect the headset from the laptop. Execute the following command again: amixer -c 0 contents | grep -A 2 'Front Headphone Jack' Expected result The output of the first command should not be empty and contains the line: : values=on The output of the second command should not be empty and contains the line: : values=off DAU001.002 Audio recognition (Windows 11) Test description This test aims to verify that the external headset is properly recognized after plugging in the 3.5 mm jack into the docking station. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Plug in a headset jack into the docking station After the Which device did you plug in menu appearing, select what type of external device has been connected to the laptop (headset). Find the Speakers icon in the bottom right part of the screen and click it using the right mouse button and then using the left mouse button click Open Sound Settings . Locate Input section and click on the Device properties option. In Device properties window select option Additional device properties . Locate in General the section field named Jack Information . Close the window Microphone properties . Disconnect a headset from the laptop. Select again the Addtional device properties option and locate again field named Jack information . Expected result Jack Information field in the first case should show the position Front Panel 3.5 mm Jack . After disconnecting a headset from the laptop and checking again option Addtional device properties field Jack Information should not contain the phrase Front Panel 3.5 mm Jack . DAU002.001 Audio playback (Ubuntu 22.04) Test description This test aims to verify that the audio subsystem is able to playback audio recordings by using the external headset speakers connected to the docking station. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 22.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Plug in a headset jack into the docking station. Open a terminal window and execute the following command: pactl set-sink-mute alsa_output.pci-0000_00_1f.3.analog-stereo 0 pactl set-sink-volume alsa_output.pci-0000_00_1f.3.analog-stereo 65535 speaker-test Expected result Sound should be played from the external speakers. DAU002.002 Audio playback (Windows 11) Test description This test aims to verify that the audio subsystem is able to playback audio recordings by using the external headset speakers connected to the docking station. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Plug in a headset jack into the docking station. Find the Speakers icon in the bottom right part of the screen and click it using the left mouse button to open volume menu. In the volume menu, click the rightmost part of it and note the reult. Expected result Sound should be played from the external speakers. DAU003.001 Audio capture (Ubuntu 22.04) Test description This test aims to verify that the audio subsystem is able to capture audio from external headset connected to the docking station. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 22.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Plug in a headset jack into the docking station. Open a terminal window and execute the following command: arecord -f S16_LE -d 10 -r 16000 /tmp/test-mic.wav Make some noise for the headset. For example, say something. Execute the following command: aplay /tmp/test-mic.wav Execute the following command: arecord -f S16_LE -d 10 -r 16000 /tmp/test-mic-1.wav Make some noise for the DUT. For example tap a few times in the laptop casing. Execute the following command: aplay /tmp/test-mic.wav Expected result During playback of the first recording, all noise that was made for headset should be clearly heard. During playback of the second recording, all noise that was made for DUT should be quiet or not heard. DAU003.002 Audio capture (Windows 11) Test description This test aims to verify that the audio subsystem is able to capture audio from external headset connected to the docking station. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Plug in a headset jack into the docking station. Find the Speakers icon in the bottom right part of the screen and click it using the right mouse button and then using the left mouse button click Open Sound Settings . Locate the Test your microphone section and observe it. Create some noise for the headset to capture and note the result. For example, say something. Create some noise for the DUT. For example tap a few times in the laptop casing. Expected result Audio level bar located in the Test your microphone should raise when some noise have been created for the headset. Audio level bar located in the Test your microphone should not raise when some noise have been created for the DUT.","title":"Docking station audio"},{"location":"unified-test-documentation/dasharo-compatibility/322-docking-station-audio/#dasharo-compatibility-docking-station-audio","text":"","title":"Dasharo Compatibility: Docking station audio"},{"location":"unified-test-documentation/dasharo-compatibility/322-docking-station-audio/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/323-docking-station-detect/","text":"Dasharo compatibility: Docking station detect Test cases Common Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . The docking station connected to the USB-C port. DUD001.001 Docking station detection after coldboot (Ubuntu 22.04) Test description This test aims to verify that the DUT properly detects the docking station after coldboot (realized by power supply cutting off then restoring back). This test case may be re-done several times to specify the platform and connection stability. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 22.04 Test setup Proceed with the Common section. Test steps Cut the power off while DUT is turned on. Restore power and power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and run the follwing command: lsusb Note the results. Expected result After lsusb command the docking station entries should be displayed, but output can be different depending on the model of the docking station. Example entries signifing the docking station: Bus 002 Device 010 : Realtek Semiconductor Corp. RTL8153 Gigabit Ethernet Adapter Bus 002 Device 009 : Prolific Technology, Inc. USB SD Card Reader Bus 002 Device 008 : VIA Labs, Inc. USB3.0 Hub DUD002.001 Docking station detection after warmboot (Ubuntu 22.04) Test description This test aims to verify that the DUT properly detects the docking station after warmboot (realized by device turning off then turning on). This test case may be re-done several times to specify the platform and connection stability. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 22.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and run the follwing command: lsusb Note the results. Expected result After lsusb command the docking station entries should be displayed, but output can be different depending on the model of the docking station. Example entries signifing the docking station: Bus 002 Device 010 : Realtek Semiconductor Corp. RTL8153 Gigabit Ethernet Adapter Bus 002 Device 009 : Prolific Technology, Inc. USB SD Card Reader Bus 002 Device 008 : VIA Labs, Inc. USB3.0 Hub DUD003.001 Docking station detection after reboot (Ubuntu 22.04) Test description This test aims to verify that the DUT properly detects the docking station after system reboot (performed by relevant command). This test case may be re-done several times to specify the platform and connection stability. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 22.04 Test setup Proceed with the Generic test setup: firmware . Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and run the follwing command: sudo reboot Boot into the system. Log into the system by using the proper login and password. Open a terminal window and run the follwing command: lsusb Note the results. Expected result After lsusb command the docking station entries should be displayed, but output can be different depending on the model of the docking station. Example entries signifing the docking station: Bus 002 Device 010 : Realtek Semiconductor Corp. RTL8153 Gigabit Ethernet Adapter Bus 002 Device 009 : Prolific Technology, Inc. USB SD Card Reader Bus 002 Device 008 : VIA Labs, Inc. USB3.0 Hub","title":"Docking station detect"},{"location":"unified-test-documentation/dasharo-compatibility/323-docking-station-detect/#dasharo-compatibility-docking-station-detect","text":"","title":"Dasharo compatibility: Docking station detect"},{"location":"unified-test-documentation/dasharo-compatibility/323-docking-station-detect/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/324-docking-station-usb-devices/","text":"Dasharo compatibility: Docking station USB devices Test cases Common Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . The docking station connected to the USB-C port. The USB_STICK connected to the docking station. DUB001.001 USB devices recognition (firmware) Test description This test aims to verify that the external USB devices connected to the docking station are recognized correctly by the FIRMWARE . Test configuration data FIRMWARE = coreboot Test setup Proceed with the Common section. Test steps Power on the DUT. Hold the BIOS_MENU_KEY to enter the BIOS Menu. Check if the USB_STICK is available on the list. Expected result The USB_STICK is available which confirms successful recognition. DUB001.002 USB devices recognition (Ubuntu 22.04) Test description This test aims to verify that the external USB devices connected to the docking station are recognized correctly by the OPERATING_SYSTEM . Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 22.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and run the follwing command: watch -n1 lsusb Connect(or Disconnect) external USB devices to the USB ports on the docking station and note the result. Expected result After each device is connected to the USB port, a new USB device entry in lsusb command output should appear. After each device is disconnected from the USB port, a USB device entry in lsusb command output should disappear. DUB001.003 USB devices recognition (Windows 11) Test description This test aims to verify that the external USB devices connected to the docking station are recognized correctly by the OPERATING_SYSTEM . Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open PowerShell and and run the follwing command: Get-PnpDevice -PresentOnly | Where-Object { $_ . InstanceId -match '^USB' } Note the results. Expected result After executing the command, a list containing all USB devices should be displayed. The list should contain the USB_STICK , which is plug in. Example output: Status Class FriendlyName ------ ----- ------------ OK DiskDrive Mass Storage Device USB Device OK USB Generic USB Hub OK HIDClass USB Input Device OK Bluetooth Intel ( R ) Wireless Bluetooth ( R ) OK DiskDrive USB SanDisk 3 .2Gen1 USB Device OK USB USB Root Hub ( USB 3 .0 ) OK Net TP-LINK Gigabit Ethernet USB Adapter OK USB Generic USB Hub OK USB USB Mass Storage Device DUB002.001 USB keyboard recognition (firmware) Test description This test aims to verify that the external USB keyboard connected to the docking station is detected correctly by the FIRMWARE and all basic keys work according to their labels. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Common section. The external USB keyboard connected to the docking station. Test steps Power on the DUT Hold the BIOS_MENU_KEY to enter the Bios Menu. Use the arrow keys, Esc key and the Enter key to navigate the menus. Expected result All menus can be entered using the external USB keyboard. DUB002.002 USB keyboard detection (Ubuntu 22.04) Test description This test aims to verify that the external USB keyboard connected to the docking station is detected correctly by the OPERATING_SYSTEM and all basic keys work according to their labels. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 22.04 Test setup Proceed with the Common section. Install the libinput-tools package: sudo apt install libinput-tools . Connect the external USB keyboard using the USB port. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and run the follwing command: lsusb Run the follwing command in the terminal: libinput debug-events --show-keycodes Test the alphanumeric keys and note the generated keycodes. Test non-alphanumeric keys and verify that they generate the correct keycodes. Test key combinations with the Shift , Ctrl and Alt modifier keys (this tests 2-key rollover). Expected result The extarnal USB keyboard is detected in OS. All standard keyboard keys generate the correct keycodes and events as per their labels. Key combinations are detected correctly. DUB002.003 USB keyboard recognition (Windows 11) Test description This test aims to verify that the external USB keyboard is detected correctly by the OPERATING_SYSTEM and all basic keys work according to their labels. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Connect the external USB keyboard using the USB port. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open PowerShell and and run the follwing command: Get-CimInstance win32_KEYBOARD Note the results. Open notepad . Test the alphanumeric keys and note the generated characters. Test non-alphanumeric keys and verify that they generate the signs. Test key combinations with the Shift , and Alt modifier keys. Open On-Screen Keyboard and press Ctrl key on the hardware keyboard. Check if On-Screen Keyboard correctly highlights it. Open Start menu and press Esc . Check if Start menu is properly closed. Expected result After running the PowerShell command information about connected keyboards should be displayed. One of keyboard should have identical part of output: Description : USB Input Device All standard keyboard keys generate correct characters or actions when pressed. Key combinations are detected correctly.","title":"Docking station USB devices"},{"location":"unified-test-documentation/dasharo-compatibility/324-docking-station-usb-devices/#dasharo-compatibility-docking-station-usb-devices","text":"","title":"Dasharo compatibility: Docking station USB devices"},{"location":"unified-test-documentation/dasharo-compatibility/324-docking-station-usb-devices/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/325-custom-boot-order/","text":"Dasharo Compatibility: Custom Boot Order Test cases Common Test setup Proceed with the Generic test setup: firmware . CBO001.001 Custom boot order (SeaBIOS) Test description This test aims to verify that the DUT boot from the suitable source, with the posibility to boot from other sources. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Common section. Test steps Power on the DUT Press BOOT_MENU_KEY key to display boot menu. Compare the listed devices with the desired boot order. Expected result When there is a possibility for the platform to boot from different sources: Priority will be given to the system booted from SSD connected by mSATA. If above-mentioned SSD does not include system, it will be booted from USB. If it either not include system, it will be booted from SSD connected by SATA 2.5 If there is only one bootable medium the platform shall boot from it. Example boot menu: Select boot device: 1 . AHCI/0: SATA SSD ATA-11 Hard-Disk ( 15272 MiBytes ) 2 . USB MSC Drive USB Flash Memory PMAP 3 . USB MSC Drive SanDisk Ultra 1 .00 4 . USB MSC Drive Generic Flash Disk 8 .07 5 . AHCI/1: TOSHIBA MK2561GSYN ATA-8 Hard-Disk ( 232 GiBytes ) 6 . iPXE 7 . Payload [ memtest ] CBO001.002 Custom boot order (edk2) Test description This test aims to verify that the DUT boot from the suitable source, with the posibility to boot from other sources. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Common section. Test steps Power on the DUT Press SETUP MENU key to display boot menu. Select Boot Maintenance Manager and press ENTER . In Boot Maintenance Manager menu select Boot Options and press ENTER . In Change Boot Order menu select Change the order option and press ENTER . Set the desired boot order. Reboot the device. Press BOOT_MENU_KEY key to display boot menu. Compare the listed devices with the desired boot order. Expected result Current boot order option list should correspond to the desired boot order.","title":"Custom Boot Order"},{"location":"unified-test-documentation/dasharo-compatibility/325-custom-boot-order/#dasharo-compatibility-custom-boot-order","text":"","title":"Dasharo Compatibility: Custom Boot Order"},{"location":"unified-test-documentation/dasharo-compatibility/325-custom-boot-order/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/326-DTS-firmware-update/","text":"Dasharo Compatibility: Firmware update using Dasharo Tools Suite Test cases Common Test setup Proceed with the Generic test setup: firmware . Wired network connection. Make yourself familiar with Bootable over network FDT001.001 Firmware update by using Dasharo Tools Suite Test description This test aims to verify whether there is the possibility to update the DUT firmware by using Dasharo Tools Suite (DTS). Test configuration data FIRMWARE = coreboot Test setup Proceed with the Common section. Disable Secure Boot . Test steps Power on the DUT. Press BOOT_MENU_KEY to enter the boot menu. In the Boot Menu , select the iPXE Network Boot option. In the Network Boot menu , select the Dasharo Tools Suite option. Login as root (no password required). Run the following commands to update firmware to the latest version: fwupdmgr refresh fwupdmgr update Reboot the DUT. Press SETUP_MENU_KEY to enter the setup menu. Note the results. Expected result In the Setup menu information about the current firmware version should be displayed. Example output: Dasharo ( coreboot+UEFI ) v1.2.0","title":"Firmware update using Dasharo Tools Suite"},{"location":"unified-test-documentation/dasharo-compatibility/326-DTS-firmware-update/#dasharo-compatibility-firmware-update-using-dasharo-tools-suite","text":"","title":"Dasharo Compatibility: Firmware update using Dasharo Tools Suite"},{"location":"unified-test-documentation/dasharo-compatibility/326-DTS-firmware-update/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/S30-fan-control/","text":"Dasharo Compatibility: custom fan curve Test cases FAN001.001 Custom fan curve: CPU fan Test description The fan has been configured to follow a custom curve. This test aims to verify that the fan curve is configured correctly and the fan spins up and down according to the defined values. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . Install lm-sensors and stress-ng on the DUT. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open the terminal window and execute the following command: sensors | grep 'Package id 0' Verify using sensors that the temperature is below 40\u00b0C If the temperature is above 40, enable fan turbo mode (Fn + 1) until it cools down Flip the laptop over and check if the CPU fan (located under the Backspace key) is spinning In the terminal window, run following command: stress-ng -c 8 Verify using sensors that the temperature increases above 40 Flip the laptop over and check if the CPU fan is spinning Expected result The fan should not be spinning while the temperature is below 40 degrees The fan should be spinning while the temperature is above 40 degrees FAN002.001 Custom fan curve: GPU fan (NV41MB) Test description The fan has been configured to follow a custom curve. This test aims to verify that the fan curve is configured correctly and the fan spins up and down according to the defined values. Test configuration data FIRMWARE = coreboot BOOT_MENU_KEY = F7 Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . Install nvidia-smi and mesa-utils on the DUT. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open the terminal window and execute the following command: watch -n1 nvidia-smi Verify using that the temperature is below 40\u00b0C If the temperature is above 40, enable fan turbo mode (Fn + 1) until it cools down Flip the laptop over and check if the GPU fan (located under the Escape key) is spinning In another terminal window, run following command: _NV_PRIME_RENDER_OFFLOAD = 1 __GLX_VENDOR_LIBRARY_NAME = nvidia __GL_SYNC_TO_VBLANK = 0 glxgears Verify that the temperature increases above 40 Flip the laptop over and check if the GPU fan is spinning Expected result The fan should not be spinning while the temperature is below 40 degrees The fan should be spinning while the temperature is above 40 degrees","title":"Custom Fan Curve"},{"location":"unified-test-documentation/dasharo-compatibility/S30-fan-control/#dasharo-compatibility-custom-fan-curve","text":"","title":"Dasharo Compatibility: custom fan curve"},{"location":"unified-test-documentation/dasharo-compatibility/S30-fan-control/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-compatibility/S31-coreboot-fan-control/","text":"Dasharo Compatibility: coreboot Fan Control Test cases FAN001.001 Check CPU entry temperature and CPU fan speed Test description This test aims to verify that data for CPU temperature and CPU fan speed is available. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . Test steps Power on the DUT. Wait for boot until BOOT_MENU_STRING appears. Press BOOT_MENU_KEY to enter the boot menu. Select the proper number for USB_STICK option. Wait for debian login: . Type proper login. Wait for Password: . Type the proper password. Wait for root@debian:~# . Execute watch -n 1 \"sensors w83795g-i2c-1-2f |grep fan1 -A 16\" . Expected result There are visible data for fan1 and temp7 which represents CPU fan speed and CPU temperature. FAN001.002 Check if increasing CPU temperature increases CPU fan speed Test description This test aims to verify that CPU fan speed responds properly to increasing CPU temperature. Test configuration data FIRMWARE = coreboot Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . Test steps Power on the DUT. Wait for boot until BOOT_MENU_STRING appears. Press BOOT_MENU_KEY to enter the boot menu. Select the proper number for USB_STICK option. Wait for debian login: . Type proper login. Wait for Password: . Type the proper password. Wait for root@debian:~# . Install stress-ng package by executing: sudo apt install stress-ng . Confirm installation by typing Y and pressing Enter when asked. Execute command: watch -n 1 \"sensors w83795g-i2c-1-2f |grep fan1 -A 16\" and check current CPU temperature and CPU fan speed. Execute command: stress-ng --cpu 16 --io 8 --vm 4 --vm-bytes 4G --timeout 30s --metrics . Wait 2 minutes. Execute command: watch -n 1 \"sensors w83795g-i2c-1-2f |grep fan1 -A 16\" and check current CPU temperature and CPU fan speed. Expected result The CPU temperature after the second check is higher at least 20 degrees. The CPU fan speed after the second check is higher at least 1000 RPM.","title":"coreboot Fan control"},{"location":"unified-test-documentation/dasharo-compatibility/S31-coreboot-fan-control/#dasharo-compatibility-coreboot-fan-control","text":"","title":"Dasharo Compatibility: coreboot Fan Control"},{"location":"unified-test-documentation/dasharo-compatibility/S31-coreboot-fan-control/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-performance/400-coreboot-boot-measure/","text":"Dasharo Performance: coreboot boot measure Test cases Common Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Download cbmem from https://cloud.3mdeb.com/index.php/s/zTqkJQdNtJDo5Nd to the DUT. CBMEM001.001 Serial boot measure: coreboot booting time after coldboot Test description This test aims to verify whether the DUT boots after coldboot and how long this process takes. This test case may be re-done several times to to average the results and specify the platform stability. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Debian 11.0 Test setup Proceed with the Common section. Test steps Open a terminal window and execute the following command: sudo ./cbmem -T Expected result The output of the command should contain the information about duration of all boot stages. CBMEM002.001 Serial boot measure: coreboot booting time after warmboot Test description This test aims to verify whether the DUT boots after warmboot and how long this process takes. This test case may be re-done several times to to average the results and specify the platform stability. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Debian 11.0 Test setup Proceed with the Common section. Test steps Open a terminal window and execute the following command: sudo ./cbmem -T Expected result The output of the command should contain the information about duration of all boot stages. CBMEM003.001 Serial boot measure: coreboot booting time after system reboot Test description This test aims to verify whether the DUT boots after system reboot and how long this process takes. This test case may be re-done several times to to average the results and specify the platform stability. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Debian 11.0 Test setup Proceed with the Common section. Test steps Open a terminal window and execute the following command: sudo ./cbmem -T Expected result The output of the command should contain the information about duration of all boot stages.","title":"Coreboot boot measure"},{"location":"unified-test-documentation/dasharo-performance/400-coreboot-boot-measure/#dasharo-performance-coreboot-boot-measure","text":"","title":"Dasharo Performance: coreboot boot measure"},{"location":"unified-test-documentation/dasharo-performance/400-coreboot-boot-measure/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-performance/401-cpu-temperature/","text":"Dasharo Performance: CPU temperature measure Test cases Common Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Install lm-sensors package: sudo apt install lm-sensors . CPT001.001 CPU temperature without load (Ubuntu 22.04) Test description This test aims to verify whether the temperature of CPU cores after system booting is not higher than the maximum allowed temperature. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 22.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and run the following command: sensors Note the result. Expected result Example output: coretemp-isa-0000 Adapter: ISA adapter Package id 0 : +34.0\u00b0C ( high = +100.0\u00b0C, crit = +100.0\u00b0C ) Core 0 : +34.0\u00b0C ( high = +100.0\u00b0C, crit = +100.0\u00b0C ) Core 1 : +34.0\u00b0C ( high = +100.0\u00b0C, crit = +100.0\u00b0C ) Core 2 : +32.0\u00b0C ( high = +100.0\u00b0C, crit = +100.0\u00b0C ) Core 3 : +33.0\u00b0C ( high = +100.0\u00b0C, crit = +100.0\u00b0C ) Displayed temperature should be not higher than displayed high and critical temperatures. Also the temperature should be not higher than temperature declared by the DUT producer. CPT002.001 CPU temperature after stress test (Ubuntu 22.04) Test description This test aims to verify whether the temperature of the CPU cores is not higher than the maximum allowed temperature after stress test. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 22.04 Test setup Proceed with the Common section. Install the stress-ng package: sudo apt install stress-ng . Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and run the following command to turn on the stressor: stress-ng --cpu 0 --tz -t 60s Stress test duration time might be changed by change te value of the parameter -t . After end the stress test open a terminal window and run the follwing command: sensors Note the result. Expected result Example output: coretemp-isa-0000 Adapter: ISA adapter Package id 0 : +54.0\u00b0C ( high = +100.0\u00b0C, crit = +100.0\u00b0C ) Core 0 : +50.0\u00b0C ( high = +100.0\u00b0C, crit = +100.0\u00b0C ) Core 1 : +49.0\u00b0C ( high = +100.0\u00b0C, crit = +100.0\u00b0C ) Core 2 : +53.0\u00b0C ( high = +100.0\u00b0C, crit = +100.0\u00b0C ) Core 3 : +51.0\u00b0C ( high = +100.0\u00b0C, crit = +100.0\u00b0C ) The displayed temperature should be not higher than displayed high and critical temperatures. Also the temperature should be not higher than temperature declared by the DUT producer.","title":"CPU temperature measure"},{"location":"unified-test-documentation/dasharo-performance/401-cpu-temperature/#dasharo-performance-cpu-temperature-measure","text":"","title":"Dasharo Performance: CPU temperature measure"},{"location":"unified-test-documentation/dasharo-performance/401-cpu-temperature/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-performance/402-cpu-frequency/","text":"Dasharo Performance: CPU frequency measure Test cases Common Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . CPF001.001 CPU not stuck on initial frequency (Ubuntu 22.04) Test description This test aims to verify whether the mounted CPU does not stuck on the initial frequency after booting into the OS. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 22.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and run the follwing command: cat /proc/cpuinfo | grep -i mhz Note the results. Expected result The output of the command should contain information about the current frequency of each CPU core. If the current frequency for each core is the same as initial frequency, the test should be considered as failed. Example output with unwanted results: cpu MHz : 2800 .000 cpu MHz : 2800 .000 cpu MHz : 2800 .000 cpu MHz : 2800 .000 cpu MHz : 2800 .000 cpu MHz : 2800 .000 cpu MHz : 2800 .000 cpu MHz : 2800 .000 CPF001.002 CPU not stuck on initial frequency (Windows 11) Test description This test aims to verify whether the mounted CPU does not stuck on the initial frequency after booting into the OS. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a powershell as administrator and run the follwing command: while ( 1 ){( Get-CimInstance CIM_Processor ). MaxClockSpeed *(( Get-Counter -Counter \"\\Processor Information(_Total)\\% Processor Performance\" ). CounterSamples . CookedValue )/ 100 } Note the results. Expected result The output of the command should contain information about the current frequency of CPU. If the following frequency values are the same, the test should be considered as failed. Example output with unwanted results: 2800 .00000000000 2800 .00000000000 2800 .00000000000 2800 .00000000000 2800 .00000000000 2800 .00000000000 2800 .00000000000 2800 .00000000000 CPF002.001 CPU runs on expected frequency (Ubuntu 22.04) Test description This test aims to verify whether the mounted CPU is running on expected frequency. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 22.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and run the follwing command: lscpu | grep -i mhz Note the results. Run the following command in the terminal: cat /proc/cpuinfo | grep -i mhz Compare the results. Expected result The result of running the first command should contain the information about current, minimum and maximum CPU frequency. Example output: CPU MHz: 2800 .0000 CPU max MHz: 4700 .0000 CPU min MHz: 400 .0000 The result of running the second command should contain the information about current frequency of each CPU core. Example output: cpu MHz : 2800 .000 cpu MHz : 2800 .000 cpu MHz : 2800 .000 cpu MHz : 2800 .000 cpu MHz : 2800 .000 cpu MHz : 2800 .000 cpu MHz : 900 .542 cpu MHz : 461 .831 None of CPU core frequencies should be higher than maximum frequency or lower than minimum frequency. CPF002.002 CPU runs on expected frequency (Windows 11) Test description This test aims to verify whether the mounted CPU is running on expected frequency. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a powershell as administrator and run the follwing command: ( Get-CimInstance CIM_Processor ). MaxClockSpeed Note the result. Run the following command in the powershell: while ( 1 ){( Get-CimInstance CIM_Processor ). MaxClockSpeed *(( Get-Counter -Counter \"\\Processor Information(_Total)\\% Processor Performance\" ). CounterSamples . CookedValue )/ 100 } Note the results. Expected result The result of running the first command should contain the information about maximum CPU frequency. Example output: 2419 None of displayed values \u200b\u200bthat follow the second command should be higher than maximum frequency. Example output: 1023 .98759600614 1009 .23827168367 940 .831608527132 1201 .62695181908 1140 .59449053201 1021 .87762893503 983 .647614379085 1206 .27777992278 CPF003.001 CPU runs on expected frequency (Ubuntu 22.04, battery) Test description This test aims to verify whether the mounted CPU is running on expected frequency when charger is disconnected. The DUT during test works on battery. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 22.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and run the follwing command: lscpu | grep -i mhz Note the results. Run the following command in the terminal: cat /proc/cpuinfo | grep -i mhz Compare the results. Expected result The result of running the first command should contain the information about current, minimum and maximum CPU frequency. Example output: CPU MHz: 1800 .000 CPU max MHz: 3900 .0000 CPU min MHz: 1600 .0000 The result of running the second command should contain the information about current frequency of each CPU core. Example output: cpu MHz : 1700 .000 cpu MHz : 3719 .954 cpu MHz : 1600 .000 cpu MHz : 1600 .000 cpu MHz : 3778 .321 cpu MHz : 1800 .000 cpu MHz : 1700 .000 cpu MHz : 3806 .530 None of CPU core frequencies should be higher than maximum frequency or lower than minimum frequency. CPF003.002 CPU runs on expected frequency (Windows 11, battery) Test description This test aims to verify whether the mounted CPU is running on expected frequency when charger is disconnected. The DUT during test works on battery. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a powershell as administrator and run the follwing command: ( Get-CimInstance CIM_Processor ). MaxClockSpeed Note the result. Run the following command in the powershell: while ( 1 ){( Get-CimInstance CIM_Processor ). MaxClockSpeed *(( Get-Counter -Counter \"\\Processor Information(_Total)\\% Processor Performance\" ). CounterSamples . CookedValue )/ 100 } Note the results. Expected result The result of running the first command should contain the information about maximum CPU frequency. Example output: 2419 None of displayed values \u200b\u200bthat follow the second command should be higher than maximum frequency. Example output: 1023 .98759600614 1009 .23827168367 940 .831608527132 1201 .62695181908 1140 .59449053201 1021 .87762893503 983 .647614379085 1206 .27777992278 CPF004.001 CPU with load runs on expected frequency (Ubuntu 22.04) Test description This test aims to verify whether the mounted CPU is running on expected frequency after stress test. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 22.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and run the follwing command: lscpu | grep -i mhz Note the results. Run the follwing command in the terminal to start the stress test: stress-ng --cpu 0 --timer 32 --timer-freq 1000000 -t 60s --cpu-load 100 After ending the stress test run the following command in the terminal: cat /proc/cpuinfo | grep -i mhz Compare the output from the first and the third command. Expected result The result of running the first command should contain the information about current, minimum and maximum CPU frequency. Example output: CPU MHz: 1800 .000 CPU max MHz: 3900 .0000 CPU min MHz: 1600 .0000 The result of running the third command should contain the information about current frequency of each CPU core. Example output: cpu MHz : 1900 .000 cpu MHz : 1600 .000 cpu MHz : 2849 .923 cpu MHz : 1700 .000 cpu MHz : 2200 .000 cpu MHz : 3386 .400 cpu MHz : 1600 .000 cpu MHz : 1600 .000 None of CPU core frequencies should be higher than maximum frequency or lower than minimum frequency. CPF004.002 CPU with load runs on expected frequency (Windows 11) Test description This test aims to verify whether the mounted CPU is running on expected frequency after stress test. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a powershell as administrator and run the follwing command: ( Get-CimInstance CIM_Processor ). MaxClockSpeed Note the result. Run the stressor. Run the following command in the powershell: while ( 1 ){( Get-CimInstance CIM_Processor ). MaxClockSpeed *(( Get-Counter -Counter \"\\Processor Information(_Total)\\% Processor Performance\" ). CounterSamples . CookedValue )/ 100 } Note the results. Expected result The result of running the first command should contain the information about maximum CPU frequency. Example output: 2419 None of displayed values \u200b\u200bthat follow the second command should be higher than maximum frequency. Example output: 1023 .98759600614 1009 .23827168367 940 .831608527132 1201 .62695181908 1140 .59449053201 1021 .87762893503 983 .647614379085 1206 .27777992278 CPF005.001 CPU with load runs on expected frequency (Ubuntu 22.04, battery) Test description This test aims to verify whether the mounted CPU is running on expected frequency after stress test. The DUT during test works on battery. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 22.04 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and run the follwing command: lscpu | grep -i mhz Note the results. Run the follwing command in the terminal to start the stress test: stress-ng --cpu 0 --timer 32 --timer-freq 1000000 -t 60s --cpu-load 100 After ending the stress test run the following command in the terminal: cat /proc/cpuinfo | grep -i mhz Compare the output from the first and the third command. Expected result The result of running the first command should contain the information about current, minimum and maximum CPU frequency. Example output: CPU MHz: 1800 .000 CPU max MHz: 3900 .0000 CPU min MHz: 1600 .0000 The result of running the third command should contain the information about current frequency of each CPU core. Example output: cpu MHz : 1900 .000 cpu MHz : 1600 .000 cpu MHz : 2849 .923 cpu MHz : 1700 .000 cpu MHz : 2200 .000 cpu MHz : 3386 .400 cpu MHz : 1600 .000 cpu MHz : 1600 .000 None of CPU core frequencies should be higher than maximum frequency or lower than minimum frequency. CPF005.002 CPU with load runs on expected frequency (Windows 11, battery) Test description This test aims to verify whether the mounted CPU is running on expected frequency after stress test. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Common section. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a powershell as administrator and run the follwing command: ( Get-CimInstance CIM_Processor ). MaxClockSpeed Note the result. Run the stressor. Run the following command in the powershell: while ( 1 ){( Get-CimInstance CIM_Processor ). MaxClockSpeed *(( Get-Counter -Counter \"\\Processor Information(_Total)\\% Processor Performance\" ). CounterSamples . CookedValue )/ 100 } Note the results. Expected result The result of running the first command should contain the information about maximum CPU frequency. Example output: 2419 None of displayed values \u200b\u200bthat follow the second command should be higher than maximum frequency. Example output: 1023 .98759600614 1009 .23827168367 940 .831608527132 1201 .62695181908 1140 .59449053201 1021 .87762893503 983 .647614379085 1206 .27777992278","title":"CPU frequency measure"},{"location":"unified-test-documentation/dasharo-performance/402-cpu-frequency/#dasharo-performance-cpu-frequency-measure","text":"","title":"Dasharo Performance: CPU frequency measure"},{"location":"unified-test-documentation/dasharo-performance/402-cpu-frequency/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-security/200-tpm-support/","text":"Dasharo Security: TPM Support Test cases TPM001.001 TPM Support (Ubuntu 20.04) Test description This test aims to verify that the TPM is initialized correctly and the PCRs can be accessed from the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . Install the tpm2-tools package: sudo apt install tpm2-tools . Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Check the version of installed tpm2-tools - execute the following command in the terminal: dpkg --list tpm2-tools If your device is equipped with TPM2.0 and the version of tpm2-tools is 4.0 or higher - execute the following command in terminal: tpm2_pcrread If your device is equipped with TPM2.0 and the version of tpm2-tools is lower than 4.0 - execute the following command in terminal: tpm2_pcrlist If your device is equipped with TPM1.2 - execute the following command in terminal: cat /sys/class/tpm/tpm0/pcrs Expected result The command should return a list of PCRs and their contents. Output example for TPM2.0: sha1 : 0 : 3a3f780f11a4b49969fcaa80cd6e3957c33b2275 1 : 8a074fdf65a11e5dbf02d25e7f26b00c26c98b41 2 : c36c2509d636c9cfa075d6d0a03b7a37bec14ee9 3 : 3a3f780f11a4b49969fcaa80cd6e3957c33b2275 4 : 2d247bb671ec17ded623ca45967df5482517291b 5 : 49d543eb1d1df3439d9fca695ee47b8cdf4b9e2f 6 : 3a3f780f11a4b49969fcaa80cd6e3957c33b2275 7 : 3a3f780f11a4b49969fcaa80cd6e3957c33b2275 8 : 0000000000000000000000000000000000000000 9 : 0000000000000000000000000000000000000000 10 : 0000000000000000000000000000000000000000 11 : 0000000000000000000000000000000000000000 12 : 0000000000000000000000000000000000000000 13 : 0000000000000000000000000000000000000000 14 : 0000000000000000000000000000000000000000 15 : 0000000000000000000000000000000000000000 16 : 0000000000000000000000000000000000000000 17 : ffffffffffffffffffffffffffffffffffffffff 18 : ffffffffffffffffffffffffffffffffffffffff 19 : ffffffffffffffffffffffffffffffffffffffff 20 : ffffffffffffffffffffffffffffffffffffffff 21 : ffffffffffffffffffffffffffffffffffffffff 22 : ffffffffffffffffffffffffffffffffffffffff 23 : 0000000000000000000000000000000000000000 sha256 : 0 : d27cc12614b5f4ff85ed109495e320fb1e5495eb28d507e952d51091e7ae2a72 1 : b29a64bd6895966b777eb803f45e6bbffade81cc1b996a34f7cbd26f1d04028b 2 : 3122422e43b9fbfc0cb70eb467b55e99ec61462370e6b15c515484f821e1d4d9 3 : 909e4261938378c0556a4c335c38718d1c313bd151fdf222df674aabb7aeee97 4 : 984763b42633ee11e5167e2f67c2e6879bd6efac683f1df1ef16d7ce96d4b49b 5 : dab92c45eeb765e29784f8cc33f92d0a39afed173f2b07e0e328586c3c3b19ed 6 : d27cc12614b5f4ff85ed109495e320fb1e5495eb28d507e952d51091e7ae2a72 7 : d27cc12614b5f4ff85ed109495e320fb1e5495eb28d507e952d51091e7ae2a72 8 : 0000000000000000000000000000000000000000000000000000000000000000 9 : 0000000000000000000000000000000000000000000000000000000000000000 10 : 0000000000000000000000000000000000000000000000000000000000000000 11 : 0000000000000000000000000000000000000000000000000000000000000000 12 : 0000000000000000000000000000000000000000000000000000000000000000 13 : 0000000000000000000000000000000000000000000000000000000000000000 14 : 0000000000000000000000000000000000000000000000000000000000000000 15 : 0000000000000000000000000000000000000000000000000000000000000000 16 : 0000000000000000000000000000000000000000000000000000000000000000 17 : ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff 18 : ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff 19 : ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff 20 : ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff 21 : ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff 22 : ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff 23 : 0000000000000000000000000000000000000000000000000000000000000000 Output example for TPM1.2: PCR-00: B3 F3 60 E1 D5 1F 82 D4 62 E6 B9 69 92 2F 65 F4 9F 1A 5F 8E PCR-01: 21 9F 1F 4A C1 AD AD 4D F1 8B 9F AB 98 23 68 B1 73 A6 32 87 PCR-02: 40 CF E3 DC A7 FF 67 FB AA BB 20 85 A4 39 43 D8 54 A7 AB 98 PCR-03: E3 E7 E6 89 CA FB F5 75 38 95 D0 CD 83 96 F6 0C 38 04 DC D5 PCR-04: 01 7A 3D E8 2F 4A 1B 77 FC 33 A9 03 FE F6 AD 27 EE 92 BE 04 PCR-05: 93 6A 12 98 07 73 85 9D 91 27 61 82 E7 11 C5 1D 08 98 C4 28 PCR-06: 3A 3F 78 0F 11 A4 B4 99 69 FC AA 80 CD 6E 39 57 C3 3B 22 75 PCR-07: 3A 3F 78 0F 11 A4 B4 99 69 FC AA 80 CD 6E 39 57 C3 3B 22 75 PCR-08: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 PCR-09: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 PCR-10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 PCR-11: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 PCR-12: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 PCR-13: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 PCR-14: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 PCR-15: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 PCR-16: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 PCR-17: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF PCR-18: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF PCR-19: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF PCR-20: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF PCR-21: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF PCR-22: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF PCR-23: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 TPM001.002 TPM Support (Windows 11) Test description This test aims to verify that the TPM is initialized correctly and the PCRs can be accessed from the operating system. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a PowerShell and execute following command: get-tpm Expected result The command should return informations about TPM state: if the TPM is present, ready and enabled: TpmPresent : True TpmReady : True TpmEnabled : True","title":"TPM support"},{"location":"unified-test-documentation/dasharo-security/200-tpm-support/#dasharo-security-tpm-support","text":"","title":"Dasharo Security: TPM Support"},{"location":"unified-test-documentation/dasharo-security/200-tpm-support/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-security/201-verified-boot/","text":"Dasharo Security: Verified Boot support Test cases VBO001.001 Verified boot support (firmware) Test description Verified Boot is a method of verifying that the firmware components come from a trusted source. This test aims to confirm that verified boot is enabled and functional. Test setup Proceed with the Generic test setup: firmware . Disable Secure Boot. Test steps Power on the DUT. Read coreboot loading logs. Expected result The logs should indicate that vboot is enabled and verstage has been entered: VBOOT: Loading verstage. VBO001.002 Verified boot support (Ubuntu 20.04) Test description Verified Boot is a method of verifying that the firmware components come from a trusted source. This test aims to confirm that verified boot is enabled and functional. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . Download cbmem and flashrom from https://cloud.3mdeb.com/index.php/s/zTqkJQdNtJDo5Nd to the DUT. Disable Secure Boot. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and execute the follwing command: sudo ./cbmem -c | grep VBOOT Expected result The output of the command should indicate that vboot is enabled and verstage has been entered: VBOOT: Loading verstage. TPM: Extending digest for VBOOT: boot mode into PCR 0 TPM: Extending digest for VBOOT: GBB HWID into PCR 1 VBOOT WORK 8. 0x76c05000 0x00014000 PCR-0 2547cc736e951fa4919853c43ae890861a3b3264000000000000000000000000 SHA256 [VBOOT: boot mode] PCR-1 e3324765a25f8a59c7c20cc35c1c33a8ab384159d2b40a269246b0b4491cdf89 SHA256 [VBOOT: GBB HWID] VBO002.001 Verified boot: Booting from Slot A (firmware) Test description If the signatures for firmware stored in vboot Slot A are correct, vboot should proceed to boot from Slot A. Test setup Proceed with the Generic test setup: firmware . Disable Secure Boot. Test steps Power on the DUT. Read coreboot loading logs. Expected result The logs should indicate that vboot has chosen to boot from slot A: Slot A is selected VBO002.002 Verified boot: Booting from Slot A (Ubuntu 20.04) Test description If the signatures for firmware stored in vboot Slot A are correct, vboot should proceed to boot from Slot A. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . Download cbmem and flashrom from https://cloud.3mdeb.com/index.php/s/zTqkJQdNtJDo5Nd to the DUT. Disable Secure Boot. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and execute the follwing command: sudo ./cbmem -c | grep \"Slot A\" Expected result The output of the command should indicate that vboot has chosen to boot from slot A: Slot A is selected VBO003.001 Verified boot: Booting from Recovery (Ubuntu 20.04) Test description If the signatures for firmware stored in vboot Slot A are incorrect, vboot should revert to booting from the recovery slot. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . Download cbmem and flashrom from https://cloud.3mdeb.com/index.php/s/zTqkJQdNtJDo5Nd to the DUT. Disable Secure Boot. Obtain coreboot binary signed with wrong vboot keys. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Flash coreboot signed with wrong vboot keys by executing the following command: flashrom -p internal --fmap -i RW_SECTION_A -w [ coreboot binary ] Power off the DUT Connect to the DUT using the serial port. Power on the DUT Boot into the system. Log into the system by using the proper login and password. Open a terminal window and execute the follwing command: sudo ./cbmem -c | grep -i recovery If booting into the system is impossible, read coreboot loading logs. Expected result The logs should indicate that vboot has chosen to boot from the recovery slot. Example: VB2:vb2_check_recovery () Recovery reason from previous boot: 0x3 / 0x3 VB2:vb2_check_recovery () We have a recovery request: 0x3 / 0x0 Recovery requested ( 1009000e ) VBO004.001 Recovery boot popup (firmware) Test description This test aims to verify whether the recovery mode information is displayed as the popup after rebooting the DUT which is flashed with the firmware with the wrong vboot keys. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . Disable Secure Boot. Obtain coreboot binary signed with wrong vboot keys. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Flash coreboot signed with wrong vboot keys by executing the following command: flashrom -p internal --fmap -i RW_SECTION_A -w [ coreboot binary ] Reboot the DUT. Wait for the popup to appear. Expected result Popup with information about recovery mode should be displayed. VBO005.001 Recovery boot popup confirmation (firmware) Test description This test aims to verify whether the recovery popup might be confirmed which allows to proceed to the next booting stages. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . Disable Secure Boot. Obtain coreboot binary signed with wrong vboot keys. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Flash coreboot signed with wrong vboot keys by executing the following command: flashrom -p internal --fmap -i RW_SECTION_A -w [ coreboot binary ] Reboot the DUT. Wait for the popup to appear. Press ENTER . Expected result After pressing ENTER the DUT should immediately move to the next stages of booting.","title":"Verified Boot"},{"location":"unified-test-documentation/dasharo-security/201-verified-boot/#dasharo-security-verified-boot-support","text":"","title":"Dasharo Security: Verified Boot support"},{"location":"unified-test-documentation/dasharo-security/201-verified-boot/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-security/203-measured-boot/","text":"Dasharo Security: Measured Boot support Test cases MBO001.001 Measured Boot support (Ubuntu 20.04) Test description Measured Boot is a method for detecting changes to firmware by storing hashes of each firmware component into the TPM PCR registers. If a PCR changes value across reboots, a change to the firmware has been made. This test aims to verify that Measured Boot is functional and measurements are stored into the TPM.a. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Proceed with the Generic test setup: OS boot from disk . Download cbmem and flashrom from https://cloud.3mdeb.com/index.php/s/zTqkJQdNtJDo5Nd to the DUT. Disable Secure Boot. Test steps Power on the DUT. Boot into the system. Log into the system by using the proper login and password. Open a terminal window and execute the following command: sudo ./cbmem -c | grep -i PCR Expected result The output of the command should indicate that measurements of the coreboot components have been made: TPM: Digest of FMAP: FW_MAIN_A CBFS: fallback/romstage to PCR 2 measured TPM: Digest of FMAP: FW_MAIN_A CBFS: fspm.bin to PCR 2 measured TPM: Digest of FMAP: FW_MAIN_A CBFS: fallback/postcar to PCR 2 measured TPM: Digest of FMAP: FW_MAIN_A CBFS: fallback/ramstage to PCR 2 measured TPM: Digest of FMAP: FW_MAIN_A CBFS: cpu_microcode_blob.bin to PCR 2 measured TPM: Digest of FMAP: FW_MAIN_A CBFS: fsps.bin to PCR 2 measured TPM: Digest of FMAP: FW_MAIN_A CBFS: vbt.bin to PCR 2 measured TPM: Digest of FMAP: FW_MAIN_A CBFS: fallback/dsdt.aml to PCR 2 measured TPM: Digest of FMAP: FW_MAIN_A CBFS: fallback/payload to PCR 2 measured The output should also not contain the following message: TPM: Extending hash into PCR failed.","title":"Measured Boot"},{"location":"unified-test-documentation/dasharo-security/203-measured-boot/#dasharo-security-measured-boot-support","text":"","title":"Dasharo Security: Measured Boot support"},{"location":"unified-test-documentation/dasharo-security/203-measured-boot/#test-cases","text":"","title":"Test cases"},{"location":"unified-test-documentation/dasharo-security/206-secure-boot/","text":"Dasharo Security: UEFI Secure Boot Test cases SBO001.001 UEFI Secure Boot (Ubuntu 20.04) Test description Secure boot is a verification mechanism for ensuring that code launched by firmware is trusted. This test verifies that secure boot can be enabled from Tianocore and, after the DUT reset, it is seen from the OS. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Ubuntu 20.04 Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Test steps Power on the DUT While the DUT is booting, hold the BIOS_SETUP_KEY to enter the UEFI Setup Menu. Enter the Device Manager menu using the arrow keys and Enter. Enter the Secure Boot Configuration submenu. Verify that the Current Secure Boot State field says Enabled - if not, select the Attempt Secure Boot option below. Go back to the main menu using the ESC key. Select the Reset option to apply the settings and reboot. The DUT will now attempt to boot OPERATING_SYSTEM with Secure Boot enabled. Log in to the default user session. Open a terminal window and execute the following command: sudo dmesg | grep secureboot Expected result The output of the command should contain the line: secureboot: Secure boot enabled SBO001.002 UEFI Secure Boot (Windows 11) Test description Secure boot is a verification mechanism for ensuring that code launched by firmware is trusted. This test verifies that secure boot can be enabled from Tianocore and, after the DUT reset, it is seen from the OS. Test configuration data FIRMWARE = coreboot OPERATING_SYSTEM = Windows 11 Test setup Proceed with the Generic test setup: firmware . Proceed with the Generic test setup: OS installer . Proceed with the Generic test setup: OS installation . Test steps Power on the DUT. While the DUT is booting, hold the BIOS_SETUP_KEY to enter the UEFI Setup Menu. Enter the Device Manager menu using the arrow keys and Enter. Enter the Secure Boot Configuration submenu. Verify that the Current Secure Boot State field says Enabled - if not, select the Attempt Secure Boot option below. Go back to the main menu using the ESC key. Select the Reset option to apply the settings and reboot. The DUT will now attempt to boot OPERATING_SYSTEM with Secure Boot enabled. Log in to the default user session. Press Windows+R to open Run Window. Type msinfo32 and press Enter. In the System Information window, go to System Summary, and in the right pane select the Secure Boot State and check its state. Expected result The Secure Boot State should be enabled.","title":"Secure Boot"},{"location":"unified-test-documentation/dasharo-security/206-secure-boot/#dasharo-security-uefi-secure-boot","text":"","title":"Dasharo Security: UEFI Secure Boot"},{"location":"unified-test-documentation/dasharo-security/206-secure-boot/#test-cases","text":"","title":"Test cases"},{"location":"value-prop/compatibility/","text":"Dasharo Compatibility Module From communication bus standards, through industry specifications like ACPI and ending up with support for Operating Systems, each platform needs set of compatibility criteria which have to be maintained across life cycle of market availability and sometimes even after it. This section describes what compatibility features Dasharo offer and how it make sure their availability in every firmware release.","title":"Compatibility"},{"location":"value-prop/compatibility/#dasharo-compatibility-module","text":"From communication bus standards, through industry specifications like ACPI and ending up with support for Operating Systems, each platform needs set of compatibility criteria which have to be maintained across life cycle of market availability and sometimes even after it. This section describes what compatibility features Dasharo offer and how it make sure their availability in every firmware release.","title":"Dasharo Compatibility Module"},{"location":"value-prop/marketing/","text":"Dasharo Marketing Module We think every advanced piece of software requires correct communication to all users who will interact with it. Marketing module helps in organizing and delivering information required to understand and correctly leverage software produced by Dasharo Ecosystem. Key Embedded Firmware marketing issues Differentiation through firmware Most hardware vendors do not leverage ability to differentiate through firmware features, which is way easier then designing new hardware. Products Embedded Firmware Release Website Newsletter Repository Community and Customer Support Issues repository maintenance Documentation repository maintenance Conference speaking Technical Sales Support","title":"Marketing"},{"location":"value-prop/marketing/#dasharo-marketing-module","text":"We think every advanced piece of software requires correct communication to all users who will interact with it. Marketing module helps in organizing and delivering information required to understand and correctly leverage software produced by Dasharo Ecosystem.","title":"Dasharo Marketing Module"},{"location":"value-prop/marketing/#key-embedded-firmware-marketing-issues","text":"","title":"Key Embedded Firmware marketing issues"},{"location":"value-prop/marketing/#products","text":"Embedded Firmware Release Website Newsletter Repository Community and Customer Support Issues repository maintenance Documentation repository maintenance Conference speaking Technical Sales Support","title":"Products"},{"location":"value-prop/overview/","text":"Dasharo Value Proposition There are multiple reasons why you should choose Dasharo. In this section we will try to structure and present whole value that Dasharo can bring to your hardware. Marketing - Dasharo Marketing Module was created to resolve problems of hardware vendors with communicating Embedded Firmware value. Finally, we agree with John Hennessy and David Patterson that we enter era of New Golden Age of domain specific computing with open architectures and open-source implementations. What eventually will lead to more firmware everywhere . Addressing mentioned areas is just beginning for Dasharo we think following years would need way more firmware expertise then at any other point in time.","title":"Overview"},{"location":"value-prop/overview/#dasharo-value-proposition","text":"There are multiple reasons why you should choose Dasharo. In this section we will try to structure and present whole value that Dasharo can bring to your hardware. Marketing - Dasharo Marketing Module was created to resolve problems of hardware vendors with communicating Embedded Firmware value. Finally, we agree with John Hennessy and David Patterson that we enter era of New Golden Age of domain specific computing with open architectures and open-source implementations. What eventually will lead to more firmware everywhere . Addressing mentioned areas is just beginning for Dasharo we think following years would need way more firmware expertise then at any other point in time.","title":"Dasharo Value Proposition"},{"location":"value-prop/performance/","text":"Dasharo Performance Module TBD: explain what performance improvement features, use cases and success stories this module offer (CPU Performace Boost, CPU Turbo, power consumption optimization etc.)","title":"Dasharo Performance Module"},{"location":"value-prop/performance/#dasharo-performance-module","text":"TBD: explain what performance improvement features, use cases and success stories this module offer (CPU Performace Boost, CPU Turbo, power consumption optimization etc.)","title":"Dasharo Performance Module"},{"location":"value-prop/security/","text":"Dasharo Security Module This module gathers all security features Dasharo Ecosystem can bring to your platform through software. No matter if this is new hardware at design stage, prototype waiting for bring up or well-established platform looking for after-market boost. In this section we will explain what features Dasharo provide in area of security.","title":"Security"},{"location":"value-prop/security/#dasharo-security-module","text":"This module gathers all security features Dasharo Ecosystem can bring to your platform through software. No matter if this is new hardware at design stage, prototype waiting for bring up or well-established platform looking for after-market boost. In this section we will explain what features Dasharo provide in area of security.","title":"Dasharo Security Module"},{"location":"value-prop/certification-program/overview/","text":"Dasharo Certification Program TBD : What this section will consist of: introduction to features covered by Dasharo Certification Program (DCP) per Dasharo module per feature certification requirements issues and proposals on how to address those guidelines how DCP helps fill other certifications and compliance criteria (AWS, Google, Azure, OCP, UEFI, ACPI)","title":"Dasharo Certification Program"},{"location":"value-prop/certification-program/overview/#dasharo-certification-program","text":"TBD : What this section will consist of: introduction to features covered by Dasharo Certification Program (DCP) per Dasharo module per feature certification requirements issues and proposals on how to address those guidelines how DCP helps fill other certifications and compliance criteria (AWS, Google, Azure, OCP, UEFI, ACPI)","title":"Dasharo Certification Program"},{"location":"variants/custom/","text":"Dasharo Custom About Dasharo Custom are generic segment for all boards supported by 3mdeb Embedded Systems Consulting team, but without implicit Dasharo segment branding or set of features tying to given SKU. Following platforms contain all or just some subset of Dasharo qualities. Hardware compatibility Vendor Model Status Roadmap 3mdeb shop Vendor shop PC Engines apu1d Maintanance TBD TBD TBD PC Engines apu1d4 Maintanance TBD TBD TBD PC Engines apu2e0 Maintanance TBD TBD TBD PC Engines apu2e2 Maintanance TBD TBD TBD PC Engines apu2e4 Maintanance TBD TBD TBD PC Engines apu3d2 Maintanance TBD TBD TBD PC Engines apu3d4 Maintanance TBD TBD TBD PC Engines apu4d2 Maintanance TBD TBD TBD PC Engines apu4d4 Maintanance TBD TBD TBD PC Engines apu5 Maintanance TBD TBD TBD PC Engines apu6 Maintanance TBD TBD TBD Protectli FW2B Maintanance TBD TBD TBD Protectli FW4B Maintanance TBD TBD TBD","title":"Dasharo Custom"},{"location":"variants/custom/#dasharo-custom","text":"","title":"Dasharo Custom"},{"location":"variants/custom/#about","text":"Dasharo Custom are generic segment for all boards supported by 3mdeb Embedded Systems Consulting team, but without implicit Dasharo segment branding or set of features tying to given SKU. Following platforms contain all or just some subset of Dasharo qualities.","title":"About"},{"location":"variants/custom/#hardware-compatibility","text":"Vendor Model Status Roadmap 3mdeb shop Vendor shop PC Engines apu1d Maintanance TBD TBD TBD PC Engines apu1d4 Maintanance TBD TBD TBD PC Engines apu2e0 Maintanance TBD TBD TBD PC Engines apu2e2 Maintanance TBD TBD TBD PC Engines apu2e4 Maintanance TBD TBD TBD PC Engines apu3d2 Maintanance TBD TBD TBD PC Engines apu3d4 Maintanance TBD TBD TBD PC Engines apu4d2 Maintanance TBD TBD TBD PC Engines apu4d4 Maintanance TBD TBD TBD PC Engines apu5 Maintanance TBD TBD TBD PC Engines apu6 Maintanance TBD TBD TBD Protectli FW2B Maintanance TBD TBD TBD Protectli FW4B Maintanance TBD TBD TBD","title":"Hardware compatibility"},{"location":"variants/firewall/","text":"Dasharo Firewall About A firewall is a system that aims to secure your network, controlling the traffic flow, that is why Dasharo Firewall aims at securing the connection between applications or devices. It brings the benefits of the Open Source Firmware to the platform: giving you the source code control, updates, and bug fixes at any time for better performance and security. Designed for embedded platforms that are cloud, network-based, or edge computing solutions. Experience the quality of networking firmware closed in a fine binary with constant support, maintenance and transparency. For whom: For people who look for a secure firewall solution based on open-source software and technologies. TBD: we need more precise characteristics of Dasharo Firewall, it should be defined by tests we applying to typical firewall devices e.g. OPNsense compatibility. TBD: maybe also add some picture/diagram of Dasharo Firewall to compliment the text. Hardware compatibility Vendor Model Status Roadmap 3mdeb shop Vendor shop PC Engines apu2e0 Maintanance TBD TBD TBD PC Engines apu2e2 Maintanance TBD TBD TBD PC Engines apu2e4 Maintanance TBD TBD TBD Protectli FW6D Testing and Integration TBD TBD TBD Protectli FW6E Testing and Integration TBD TBD TBD","title":"Dasharo Firewall"},{"location":"variants/firewall/#dasharo-firewall","text":"","title":"Dasharo Firewall"},{"location":"variants/firewall/#about","text":"A firewall is a system that aims to secure your network, controlling the traffic flow, that is why Dasharo Firewall aims at securing the connection between applications or devices. It brings the benefits of the Open Source Firmware to the platform: giving you the source code control, updates, and bug fixes at any time for better performance and security. Designed for embedded platforms that are cloud, network-based, or edge computing solutions. Experience the quality of networking firmware closed in a fine binary with constant support, maintenance and transparency. For whom: For people who look for a secure firewall solution based on open-source software and technologies. TBD: we need more precise characteristics of Dasharo Firewall, it should be defined by tests we applying to typical firewall devices e.g. OPNsense compatibility. TBD: maybe also add some picture/diagram of Dasharo Firewall to compliment the text.","title":"About"},{"location":"variants/firewall/#hardware-compatibility","text":"Vendor Model Status Roadmap 3mdeb shop Vendor shop PC Engines apu2e0 Maintanance TBD TBD TBD PC Engines apu2e2 Maintanance TBD TBD TBD PC Engines apu2e4 Maintanance TBD TBD TBD Protectli FW6D Testing and Integration TBD TBD TBD Protectli FW6E Testing and Integration TBD TBD TBD","title":"Hardware compatibility"},{"location":"variants/hardware-compatibility-list/","text":"Hardware Compatibility List Vendor Model Status Roadmap Shop Documentation Dell OptiPlex 7010 SFF Implementation TBD TBD link Dell OptiPlex 7010 DT Implementation TBD TBD link Dell OptiPlex 9010 SFF Implementation TBD TBD link Possible status: Planning - platform support is planned either through internal, community or commercial sponsorship. Implementation - under active development to provide baseline support. Testing and Integration - under validation to sign-off on baseline quality criteria. Maintenance - under active maintenance release cycle according to schedule presented in Roadmap.","title":"Hardware Compatibility List"},{"location":"variants/hardware-compatibility-list/#hardware-compatibility-list","text":"Vendor Model Status Roadmap Shop Documentation Dell OptiPlex 7010 SFF Implementation TBD TBD link Dell OptiPlex 7010 DT Implementation TBD TBD link Dell OptiPlex 9010 SFF Implementation TBD TBD link Possible status: Planning - platform support is planned either through internal, community or commercial sponsorship. Implementation - under active development to provide baseline support. Testing and Integration - under validation to sign-off on baseline quality criteria. Maintenance - under active maintenance release cycle according to schedule presented in Roadmap.","title":"Hardware Compatibility List"},{"location":"variants/safety-critical/","text":"Dasharo Safety-Critical TBD: add all information we gathered about DFI GH960-BS-R1505G","title":"Dasharo Safety-Critical"},{"location":"variants/safety-critical/#dasharo-safety-critical","text":"TBD: add all information we gathered about DFI GH960-BS-R1505G","title":"Dasharo Safety-Critical"},{"location":"variants/secure-firewall/","text":"Dasharo Secure Firewall About TBD Hardware compatibility TBD Releases TBD Usage TBD","title":"Dasharo Secure Firewall"},{"location":"variants/secure-firewall/#dasharo-secure-firewall","text":"","title":"Dasharo Secure Firewall"},{"location":"variants/secure-firewall/#about","text":"TBD","title":"About"},{"location":"variants/secure-firewall/#hardware-compatibility","text":"TBD","title":"Hardware compatibility"},{"location":"variants/secure-firewall/#releases","text":"TBD","title":"Releases"},{"location":"variants/secure-firewall/#usage","text":"TBD","title":"Usage"},{"location":"variants/server/","text":"Dasharo Server TBD: add all information we have about Supermicro X11SSH","title":"Dasharo Server"},{"location":"variants/server/#dasharo-server","text":"TBD: add all information we have about Supermicro X11SSH","title":"Dasharo Server"},{"location":"variants/skus-overview/","text":"Stock Keeping Units (SKUs) TBD: Explain rules how SKUs are created, what are the naming rules, sponsoring and lifecycle. This section is placeholder for future development.","title":"Stock Keeping Units (SKUs)"},{"location":"variants/skus-overview/#stock-keeping-units-skus","text":"TBD: Explain rules how SKUs are created, what are the naming rules, sponsoring and lifecycle. This section is placeholder for future development.","title":"Stock Keeping Units (SKUs)"},{"location":"variants/trustworthy-computing/","text":"Dasharo Trustworthy Computing TBD: move all information related to Insurgo Dasharo Trustworthy Computing POWER9 support","title":"Dasharo Trustworthy Computing"},{"location":"variants/trustworthy-computing/#dasharo-trustworthy-computing","text":"TBD: move all information related to Insurgo Dasharo Trustworthy Computing POWER9 support","title":"Dasharo Trustworthy Computing"},{"location":"variants/trustworthy-server/","text":"Dasharo Trustworthy Server About TBD Hardware compatibility TBD Releases TBD Usage TBD","title":"Dasharo Trustworthy Server"},{"location":"variants/trustworthy-server/#dasharo-trustworthy-server","text":"","title":"Dasharo Trustworthy Server"},{"location":"variants/trustworthy-server/#about","text":"TBD","title":"About"},{"location":"variants/trustworthy-server/#hardware-compatibility","text":"TBD","title":"Hardware compatibility"},{"location":"variants/trustworthy-server/#releases","text":"TBD","title":"Releases"},{"location":"variants/trustworthy-server/#usage","text":"TBD","title":"Usage"},{"location":"variants/asus_kgpe_d16/building-manual/","text":"Dasharo for Asus KGPE-D16 - building manual Building coreboot To build coreboot image, follow the steps below: Clone the coreboot repository: git clone https://review.coreboot.org/coreboot.git Get the submodules: cd coreboot git submodule update --init --recursive --checkout Checkout Dasharo development branch for KGPE-D16: git remote add dasharo https://github.com/dasharo/coreboot.git git fetch dasharo git checkout asus_kgpe-d16/release Start docker container: docker run --rm -it -u $UID \\ -v $PWD :/home/coreboot/coreboot \\ -w /home/coreboot/coreboot \\ coreboot/coreboot-sdk:0ad5fbd48d /bin/bash Inside of the container, configure and start the build process: ( docker ) cp configs/config.asus_kgpe_d16_<variant> .config ( docker ) make olddefconfig ( docker ) make This will produce a debug binary placed in build/coreboot.rom for a 2MB flash chip. In order to build for 8MB or 16MB chip use the configs/config.asus_kgpe_d16_8M and configs/config.asus_kgpe_d16_16M respectively. Dasharo v0.1.0 for KGPE-D16 supports only 8MB target with configs/config.asus_kgpe_d16 . To flash coreboot refer to Flashing section in the hardware setup page. Other variants Since the Dasharo v0.3.0 release the firmware comes in two more variatns: with TPM 1.2 and TPM 2.0 support. Now the possible confis to use are: configs/config.asus_kgpe_d16_vboot_tpm12 - 2MB target with vboot and TPM 1.2 configs/config.asus_kgpe_d16_vboot_tpm2 - 2MB target with vboot and TPM 2.0 configs/config.asus_kgpe_d16_8M_vboot_tpm12 - 8MB target with vboot and TPM 1.2 configs/config.asus_kgpe_d16_8M_vboot_tpm2 - 8MB target with vboot and TPM 2.0 configs/config.asus_kgpe_d16_16M_vboot_tpm12 - 16MB target with vboot and TPM 1.2 configs/config.asus_kgpe_d16_16M_vboot_tpm2 - 16MB target with vboot and TPM 2.0","title":"Building manual"},{"location":"variants/asus_kgpe_d16/building-manual/#dasharo-for-asus-kgpe-d16-building-manual","text":"","title":"Dasharo for Asus KGPE-D16 - building manual"},{"location":"variants/asus_kgpe_d16/building-manual/#building-coreboot","text":"To build coreboot image, follow the steps below: Clone the coreboot repository: git clone https://review.coreboot.org/coreboot.git Get the submodules: cd coreboot git submodule update --init --recursive --checkout Checkout Dasharo development branch for KGPE-D16: git remote add dasharo https://github.com/dasharo/coreboot.git git fetch dasharo git checkout asus_kgpe-d16/release Start docker container: docker run --rm -it -u $UID \\ -v $PWD :/home/coreboot/coreboot \\ -w /home/coreboot/coreboot \\ coreboot/coreboot-sdk:0ad5fbd48d /bin/bash Inside of the container, configure and start the build process: ( docker ) cp configs/config.asus_kgpe_d16_<variant> .config ( docker ) make olddefconfig ( docker ) make This will produce a debug binary placed in build/coreboot.rom for a 2MB flash chip. In order to build for 8MB or 16MB chip use the configs/config.asus_kgpe_d16_8M and configs/config.asus_kgpe_d16_16M respectively. Dasharo v0.1.0 for KGPE-D16 supports only 8MB target with configs/config.asus_kgpe_d16 . To flash coreboot refer to Flashing section in the hardware setup page.","title":"Building coreboot"},{"location":"variants/asus_kgpe_d16/building-manual/#other-variants","text":"Since the Dasharo v0.3.0 release the firmware comes in two more variatns: with TPM 1.2 and TPM 2.0 support. Now the possible confis to use are: configs/config.asus_kgpe_d16_vboot_tpm12 - 2MB target with vboot and TPM 1.2 configs/config.asus_kgpe_d16_vboot_tpm2 - 2MB target with vboot and TPM 2.0 configs/config.asus_kgpe_d16_8M_vboot_tpm12 - 8MB target with vboot and TPM 1.2 configs/config.asus_kgpe_d16_8M_vboot_tpm2 - 8MB target with vboot and TPM 2.0 configs/config.asus_kgpe_d16_16M_vboot_tpm12 - 16MB target with vboot and TPM 1.2 configs/config.asus_kgpe_d16_16M_vboot_tpm2 - 16MB target with vboot and TPM 2.0","title":"Other variants"},{"location":"variants/asus_kgpe_d16/fan-control/","text":"KGPE-D16 automatic fan control Starting from KGPE-D16 Dasharo release v0.2.0, coreboot implements automatic fan control. The feature is realized on the Nuvoton W83795 hardware monitor. Testing fan control In order to check the monitoring values of W83795, one needs to install some packages: apt-get install lm-sensors Linux kernel by default should come with w83795 module. Load it with the following command: modprobe w83795 The dmesg should contain the following message after loading the module: i2c i2c-1: Found w83795g rev. B at 0x2f w83795 1 -002f: hwmon_device_register () is deprecated. Please convert the driver to use hwmon_device_register_with_info () . To check the monitoring values execute: sensors The output should be similar to the one below: k10temp-pci-00cb Adapter: PCI adapter temp1: +36.5\u00b0C ( high = +70.0\u00b0C ) ( crit = +106.0\u00b0C, hyst = +101.0\u00b0C ) w83795g-i2c-1-2f Adapter: SMBus PIIX4 adapter at 0b20 in0: 910 .00 mV ( min = +0.90 V, max = +1.50 V ) in1: 0 .00 V ( min = +0.90 V, max = +1.50 V ) ALARM in2: 1 .53 V ( min = +1.10 V, max = +1.61 V ) in3: 22 .00 mV ( min = +1.10 V, max = +1.61 V ) ALARM in4: 1 .21 V ( min = +1.14 V, max = +1.25 V ) in5: 0 .00 V ( min = +1.14 V, max = +1.25 V ) ALARM in6: 1 .19 V ( min = +1.05 V, max = +1.25 V ) in7: 1 .82 V ( min = +1.70 V, max = +1.90 V ) in8: 1 .21 V ( min = +1.14 V, max = +1.25 V ) in9: 1 .09 V ( min = +1.05 V, max = +1.15 V ) in10: 1 .60 V ( min = +1.50 V, max = +1.63 V ) in11: 752 .00 mV ( min = +0.00 V, max = +0.01 V ) ALARM +3.3V: 3 .26 V ( min = +2.96 V, max = +3.63 V ) 3VSB: 3 .28 V ( min = +2.96 V, max = +3.63 V ) Vbat: 3 .16 V ( min = +2.70 V, max = +3.63 V ) in15: 1 .02 V ( min = +0.91 V, max = +1.08 V ) in16: 1 .55 V ( min = +1.50 V, max = +1.62 V ) fan1: 1157 RPM ( min = 329 RPM ) fan2: 0 RPM ( min = 329 RPM ) ALARM fan3: 0 RPM ( min = 329 RPM ) ALARM fan4: 0 RPM ( min = 329 RPM ) ALARM fan5: 0 RPM ( min = 329 RPM ) ALARM fan6: 0 RPM ( min = 329 RPM ) ALARM fan7: 0 RPM ( min = 329 RPM ) ALARM fan8: 0 RPM ( min = 329 RPM ) ALARM temp1: +37.2\u00b0C ( high = +70.0\u00b0C, hyst = +65.0\u00b0C ) ( crit = +90.0\u00b0C, hyst = +80.0\u00b0C ) sensor = thermal diode temp2: -62.5\u00b0C ( high = +0.0\u00b0C, hyst = +0.0\u00b0C ) ( crit = +0.0\u00b0C, hyst = +0.0\u00b0C ) sensor = thermistor temp3: -62.5\u00b0C ( high = +0.0\u00b0C, hyst = +0.0\u00b0C ) ( crit = +0.0\u00b0C, hyst = +0.0\u00b0C ) sensor = thermistor temp7: +36.8\u00b0C ( high = +70.0\u00b0C, hyst = +65.0\u00b0C ) ( crit = +90.0\u00b0C, hyst = +80.0\u00b0C ) sensor = AMD AMDSI temp8: +0.0\u00b0C ( high = +70.0\u00b0C, hyst = +65.0\u00b0C ) ( crit = +90.0\u00b0C, hyst = +80.0\u00b0C ) sensor = AMD AMDSI intrusion0: ALARM beep_enable: disabled fam15h_power-pci-00c4 Adapter: PCI adapter power1: 49 .44 W ( crit = 139 .72 W ) k10temp-pci-00c3 Adapter: PCI adapter temp1: +36.8\u00b0C ( high = +70.0\u00b0C ) ( crit = +106.0\u00b0C, hyst = +99.0\u00b0C ) The CPU temperature is indicated with k10temp and w83795g temp7 inputs and the CPU fan speed is indicated by fan1. Alternative automatic fan control If you are using a coreboot for KGPE-D16 built from 4.11 branch or earlier there is also a software option to enable automatic fan control without modifications in coreboot. In order to configure the fan control, one needs to install the following package: apt-get install fancontrol Now we need to configure the fancontrol application by generating a /etc/fancontrol file containing the relation of temperature inputs to fans. Be sure that w83795 module is loaded (you may also add the module to be loaded automatically with echo w38795 >> /etc/modules ). Execute: pwmconfig This application will lead you through the process of identifying the relation of the fans and temperatures. Simply follow the instructions printed on the console. At the end do not select save and ext, just configure all PWMs, e.g.: Select fan output to configure, or other action: 1 ) hwmon0/device/pwm1 3 ) Just quit 5 ) Show configuration 2 ) Change INTERVAL 4 ) Save and quit select ( 1 -n ) : 1 Then set up temperature correlation by selecting either k10temp or hwmon0/device/temp7_input as temperature source for the fan1 (they should report identical temperature). When finished, select Save and quit . For a single CPU - single fan configuration it should result in a file like this: INTERVAL=10 DEVPATH=hwmon0=devices/pci0000:00/0000:00:14.0/i2c-1/1-002f DEVNAME=hwmon0=w83795g FCTEMPS=hwmon0/device/pwm1=hwmon0/device/temp7_input FCFANS= hwmon0/device/pwm1=hwmon0/device/fan1_input MINTEMP=hwmon0/device/pwm1=20 MAXTEMP=hwmon0/device/pwm1=80 MINSTART=hwmon0/device/pwm1=150 MINSTOP=hwmon0/device/pwm1=0 NOTE: hwmonX may be different depending on the order of loaded modules, if loaded automatically via etc/modules it may be hwmon0, if loaded using modprobe it may be hwmon3 or hwmon4. Now that the configuration file is ready, time to start the fancontrol service: systemctl enable fancontrol systemctl start fancontrol systemctl status fancontrol \u25cf fancontrol.service - fan speed regulator Loaded: loaded ( /lib/systemd/system/fancontrol.service ; enabled ; vendor pr> Active: active ( running ) since Wed 2021 -12-08 11 :23:23 CET ; 9min ago Docs: man:fancontrol ( 8 ) man:pwmconfig ( 8 ) Main PID: 1318 ( fancontrol ) Tasks: 2 ( limit: 19153 ) Memory: 1 .3M CPU: 1 .340s CGroup: /system.slice/fancontrol.service \u251c\u25001318 /bin/bash /usr/sbin/fancontrol \u2514\u25002228 sleep 10 Dec 08 11 :23:24 debian fancontrol [ 1318 ] : Controls hwmon0/device/fan1_input Dec 08 11 :23:24 debian fancontrol [ 1318 ] : MINTEMP = 20 Dec 08 11 :23:24 debian fancontrol [ 1318 ] : MAXTEMP = 80 Dec 08 11 :23:24 debian fancontrol [ 1318 ] : MINSTART = 150 Dec 08 11 :23:24 debian fancontrol [ 1318 ] : MINSTOP = 0 Dec 08 11 :23:24 debian fancontrol [ 1318 ] : MINPWM = 0 Dec 08 11 :23:24 debian fancontrol [ 1318 ] : MAXPWM = 255 Dec 08 11 :23:24 debian fancontrol [ 1318 ] : AVERAGE = 1 Dec 08 11 :23:24 debian fancontrol [ 1318 ] : Enabling PWM on fans... Dec 08 11 :23:24 debian fancontrol [ 1318 ] : Starting automatic fan control... It should print the service is running. Now check the fan speed with sensors command from lm-sensors package (install it if you haven't done it yet). For CPU temperature of 40 Celsius degrees the fan1 speed should be a little bit lower than 3000 RPM. Note it is advised to stop and disable the fancontrol service when using Dasharo for KGPE-D16 release v0.2.0 or newer: systemctl disable fancontrol systemctl stop fancontrol Verifying fan speed adaptation To check if the fan speed adapts to the temperature you may install stress-ng : apt-get install stress-ng With the following command you may cause a 2 minutes stress on the CPUs and raise its temperature (it should hit about 70 Celsius degrees with that): stress-ng --cpu 16 --io 8 --vm 4 --vm-bytes 4G --timeout 120s --metrics Simultaneously watch the fan speed with sensors command. Example for fancontrol service: k10temp-pci-00cb Adapter: PCI adapter temp1: +52.4\u00b0C ( high = +70.0\u00b0C ) w83795g-i2c-1-2f Adapter: SMBus PIIX4 adapter at 0b20 in0: 1 .09 V ( min = +0.90 V, max = +1.50 V ) in1: 0 .00 V ( min = +0.90 V, max = +1.50 V ) ALARM in2: 1 .53 V ( min = +1.10 V, max = +1.61 V ) in3: 22 .00 mV ( min = +1.10 V, max = +1.61 V ) ALARM in4: 1 .21 V ( min = +1.14 V, max = +1.25 V ) in5: 0 .00 V ( min = +1.14 V, max = +1.25 V ) ALARM in6: 1 .20 V ( min = +1.05 V, max = +1.25 V ) in7: 1 .82 V ( min = +1.70 V, max = +1.90 V ) in8: 1 .21 V ( min = +1.14 V, max = +1.25 V ) in9: 1 .09 V ( min = +1.05 V, max = +1.15 V ) in10: 1 .59 V ( min = +1.50 V, max = +1.63 V ) +3.3V: 3 .24 V ( min = +2.96 V, max = +3.63 V ) 3VSB: 3 .28 V ( min = +2.96 V, max = +3.63 V ) Vbat: 3 .06 V ( min = +2.70 V, max = +3.63 V ) in15: 1 .01 V ( min = +0.91 V, max = +1.08 V ) in16: 1 .54 V ( min = +1.50 V, max = +1.62 V ) fan1: 4299 RPM ( min = 329 RPM ) fan2: 0 RPM ( min = 329 RPM ) ALARM fan3: 0 RPM ( min = 329 RPM ) ALARM fan4: 0 RPM ( min = 329 RPM ) ALARM fan5: 0 RPM ( min = 329 RPM ) ALARM fan6: 0 RPM ( min = 329 RPM ) ALARM fan7: 0 RPM ( min = 329 RPM ) ALARM fan8: 0 RPM ( min = 329 RPM ) ALARM temp1: +52.5\u00b0C ( high = +70.0\u00b0C, hyst = +65.0\u00b0C ) ( crit = +85.0\u00b0C, hyst = +80.0\u00b0C ) sensor = thermal diode temp7: +52.8\u00b0C ( high = +70.0\u00b0C, hyst = +65.0\u00b0C ) ( crit = +85.0\u00b0C, hyst = +80.0\u00b0C ) sensor = AMD AMDSI temp8: +0.0\u00b0C ( high = +70.0\u00b0C, hyst = +65.0\u00b0C ) ( crit = +85.0\u00b0C, hyst = +80.0\u00b0C ) sensor = AMD AMDSI intrusion0: ALARM beep_enable: disabled fam15h_power-pci-00c4 Adapter: PCI adapter power1: 141 .35 W ( crit = 139 .72 W ) k10temp-pci-00c3 Adapter: PCI adapter temp1: +52.9\u00b0C ( high = +70.0\u00b0C ) For the software method with fancontrol service the fan speed adapts pretty quickly, but when using the automatic fan control from Dasharo release the spin up/down time is longer. coreboot configures the W83795 in Thermal Cruise mode which automatically probes the CPU temperature via AMD SB TSI interface. The target temperature is set to 50 Celsius degrees which means the chip will try to keep the CPU temperature to be around 50 degrees by adapting the fan speed. Summing it up, the longer the CPU temperature exceeds 50 degrees the faster the fan will spin by slowly increasing the RPM. When the temperature is below 50 degrees for a long period of time the fan rotates with a speed of around 1000 RPM. The critical temperature is set to 90 Celsius degrees. When this point is reached the W83795 should spin up to fans to full speed.","title":"Automatic fan control"},{"location":"variants/asus_kgpe_d16/fan-control/#kgpe-d16-automatic-fan-control","text":"Starting from KGPE-D16 Dasharo release v0.2.0, coreboot implements automatic fan control. The feature is realized on the Nuvoton W83795 hardware monitor.","title":"KGPE-D16 automatic fan control"},{"location":"variants/asus_kgpe_d16/fan-control/#testing-fan-control","text":"In order to check the monitoring values of W83795, one needs to install some packages: apt-get install lm-sensors Linux kernel by default should come with w83795 module. Load it with the following command: modprobe w83795 The dmesg should contain the following message after loading the module: i2c i2c-1: Found w83795g rev. B at 0x2f w83795 1 -002f: hwmon_device_register () is deprecated. Please convert the driver to use hwmon_device_register_with_info () . To check the monitoring values execute: sensors The output should be similar to the one below: k10temp-pci-00cb Adapter: PCI adapter temp1: +36.5\u00b0C ( high = +70.0\u00b0C ) ( crit = +106.0\u00b0C, hyst = +101.0\u00b0C ) w83795g-i2c-1-2f Adapter: SMBus PIIX4 adapter at 0b20 in0: 910 .00 mV ( min = +0.90 V, max = +1.50 V ) in1: 0 .00 V ( min = +0.90 V, max = +1.50 V ) ALARM in2: 1 .53 V ( min = +1.10 V, max = +1.61 V ) in3: 22 .00 mV ( min = +1.10 V, max = +1.61 V ) ALARM in4: 1 .21 V ( min = +1.14 V, max = +1.25 V ) in5: 0 .00 V ( min = +1.14 V, max = +1.25 V ) ALARM in6: 1 .19 V ( min = +1.05 V, max = +1.25 V ) in7: 1 .82 V ( min = +1.70 V, max = +1.90 V ) in8: 1 .21 V ( min = +1.14 V, max = +1.25 V ) in9: 1 .09 V ( min = +1.05 V, max = +1.15 V ) in10: 1 .60 V ( min = +1.50 V, max = +1.63 V ) in11: 752 .00 mV ( min = +0.00 V, max = +0.01 V ) ALARM +3.3V: 3 .26 V ( min = +2.96 V, max = +3.63 V ) 3VSB: 3 .28 V ( min = +2.96 V, max = +3.63 V ) Vbat: 3 .16 V ( min = +2.70 V, max = +3.63 V ) in15: 1 .02 V ( min = +0.91 V, max = +1.08 V ) in16: 1 .55 V ( min = +1.50 V, max = +1.62 V ) fan1: 1157 RPM ( min = 329 RPM ) fan2: 0 RPM ( min = 329 RPM ) ALARM fan3: 0 RPM ( min = 329 RPM ) ALARM fan4: 0 RPM ( min = 329 RPM ) ALARM fan5: 0 RPM ( min = 329 RPM ) ALARM fan6: 0 RPM ( min = 329 RPM ) ALARM fan7: 0 RPM ( min = 329 RPM ) ALARM fan8: 0 RPM ( min = 329 RPM ) ALARM temp1: +37.2\u00b0C ( high = +70.0\u00b0C, hyst = +65.0\u00b0C ) ( crit = +90.0\u00b0C, hyst = +80.0\u00b0C ) sensor = thermal diode temp2: -62.5\u00b0C ( high = +0.0\u00b0C, hyst = +0.0\u00b0C ) ( crit = +0.0\u00b0C, hyst = +0.0\u00b0C ) sensor = thermistor temp3: -62.5\u00b0C ( high = +0.0\u00b0C, hyst = +0.0\u00b0C ) ( crit = +0.0\u00b0C, hyst = +0.0\u00b0C ) sensor = thermistor temp7: +36.8\u00b0C ( high = +70.0\u00b0C, hyst = +65.0\u00b0C ) ( crit = +90.0\u00b0C, hyst = +80.0\u00b0C ) sensor = AMD AMDSI temp8: +0.0\u00b0C ( high = +70.0\u00b0C, hyst = +65.0\u00b0C ) ( crit = +90.0\u00b0C, hyst = +80.0\u00b0C ) sensor = AMD AMDSI intrusion0: ALARM beep_enable: disabled fam15h_power-pci-00c4 Adapter: PCI adapter power1: 49 .44 W ( crit = 139 .72 W ) k10temp-pci-00c3 Adapter: PCI adapter temp1: +36.8\u00b0C ( high = +70.0\u00b0C ) ( crit = +106.0\u00b0C, hyst = +99.0\u00b0C ) The CPU temperature is indicated with k10temp and w83795g temp7 inputs and the CPU fan speed is indicated by fan1.","title":"Testing fan control"},{"location":"variants/asus_kgpe_d16/fan-control/#alternative-automatic-fan-control","text":"If you are using a coreboot for KGPE-D16 built from 4.11 branch or earlier there is also a software option to enable automatic fan control without modifications in coreboot. In order to configure the fan control, one needs to install the following package: apt-get install fancontrol Now we need to configure the fancontrol application by generating a /etc/fancontrol file containing the relation of temperature inputs to fans. Be sure that w83795 module is loaded (you may also add the module to be loaded automatically with echo w38795 >> /etc/modules ). Execute: pwmconfig This application will lead you through the process of identifying the relation of the fans and temperatures. Simply follow the instructions printed on the console. At the end do not select save and ext, just configure all PWMs, e.g.: Select fan output to configure, or other action: 1 ) hwmon0/device/pwm1 3 ) Just quit 5 ) Show configuration 2 ) Change INTERVAL 4 ) Save and quit select ( 1 -n ) : 1 Then set up temperature correlation by selecting either k10temp or hwmon0/device/temp7_input as temperature source for the fan1 (they should report identical temperature). When finished, select Save and quit . For a single CPU - single fan configuration it should result in a file like this: INTERVAL=10 DEVPATH=hwmon0=devices/pci0000:00/0000:00:14.0/i2c-1/1-002f DEVNAME=hwmon0=w83795g FCTEMPS=hwmon0/device/pwm1=hwmon0/device/temp7_input FCFANS= hwmon0/device/pwm1=hwmon0/device/fan1_input MINTEMP=hwmon0/device/pwm1=20 MAXTEMP=hwmon0/device/pwm1=80 MINSTART=hwmon0/device/pwm1=150 MINSTOP=hwmon0/device/pwm1=0 NOTE: hwmonX may be different depending on the order of loaded modules, if loaded automatically via etc/modules it may be hwmon0, if loaded using modprobe it may be hwmon3 or hwmon4. Now that the configuration file is ready, time to start the fancontrol service: systemctl enable fancontrol systemctl start fancontrol systemctl status fancontrol \u25cf fancontrol.service - fan speed regulator Loaded: loaded ( /lib/systemd/system/fancontrol.service ; enabled ; vendor pr> Active: active ( running ) since Wed 2021 -12-08 11 :23:23 CET ; 9min ago Docs: man:fancontrol ( 8 ) man:pwmconfig ( 8 ) Main PID: 1318 ( fancontrol ) Tasks: 2 ( limit: 19153 ) Memory: 1 .3M CPU: 1 .340s CGroup: /system.slice/fancontrol.service \u251c\u25001318 /bin/bash /usr/sbin/fancontrol \u2514\u25002228 sleep 10 Dec 08 11 :23:24 debian fancontrol [ 1318 ] : Controls hwmon0/device/fan1_input Dec 08 11 :23:24 debian fancontrol [ 1318 ] : MINTEMP = 20 Dec 08 11 :23:24 debian fancontrol [ 1318 ] : MAXTEMP = 80 Dec 08 11 :23:24 debian fancontrol [ 1318 ] : MINSTART = 150 Dec 08 11 :23:24 debian fancontrol [ 1318 ] : MINSTOP = 0 Dec 08 11 :23:24 debian fancontrol [ 1318 ] : MINPWM = 0 Dec 08 11 :23:24 debian fancontrol [ 1318 ] : MAXPWM = 255 Dec 08 11 :23:24 debian fancontrol [ 1318 ] : AVERAGE = 1 Dec 08 11 :23:24 debian fancontrol [ 1318 ] : Enabling PWM on fans... Dec 08 11 :23:24 debian fancontrol [ 1318 ] : Starting automatic fan control... It should print the service is running. Now check the fan speed with sensors command from lm-sensors package (install it if you haven't done it yet). For CPU temperature of 40 Celsius degrees the fan1 speed should be a little bit lower than 3000 RPM. Note it is advised to stop and disable the fancontrol service when using Dasharo for KGPE-D16 release v0.2.0 or newer: systemctl disable fancontrol systemctl stop fancontrol","title":"Alternative automatic fan control"},{"location":"variants/asus_kgpe_d16/fan-control/#verifying-fan-speed-adaptation","text":"To check if the fan speed adapts to the temperature you may install stress-ng : apt-get install stress-ng With the following command you may cause a 2 minutes stress on the CPUs and raise its temperature (it should hit about 70 Celsius degrees with that): stress-ng --cpu 16 --io 8 --vm 4 --vm-bytes 4G --timeout 120s --metrics Simultaneously watch the fan speed with sensors command. Example for fancontrol service: k10temp-pci-00cb Adapter: PCI adapter temp1: +52.4\u00b0C ( high = +70.0\u00b0C ) w83795g-i2c-1-2f Adapter: SMBus PIIX4 adapter at 0b20 in0: 1 .09 V ( min = +0.90 V, max = +1.50 V ) in1: 0 .00 V ( min = +0.90 V, max = +1.50 V ) ALARM in2: 1 .53 V ( min = +1.10 V, max = +1.61 V ) in3: 22 .00 mV ( min = +1.10 V, max = +1.61 V ) ALARM in4: 1 .21 V ( min = +1.14 V, max = +1.25 V ) in5: 0 .00 V ( min = +1.14 V, max = +1.25 V ) ALARM in6: 1 .20 V ( min = +1.05 V, max = +1.25 V ) in7: 1 .82 V ( min = +1.70 V, max = +1.90 V ) in8: 1 .21 V ( min = +1.14 V, max = +1.25 V ) in9: 1 .09 V ( min = +1.05 V, max = +1.15 V ) in10: 1 .59 V ( min = +1.50 V, max = +1.63 V ) +3.3V: 3 .24 V ( min = +2.96 V, max = +3.63 V ) 3VSB: 3 .28 V ( min = +2.96 V, max = +3.63 V ) Vbat: 3 .06 V ( min = +2.70 V, max = +3.63 V ) in15: 1 .01 V ( min = +0.91 V, max = +1.08 V ) in16: 1 .54 V ( min = +1.50 V, max = +1.62 V ) fan1: 4299 RPM ( min = 329 RPM ) fan2: 0 RPM ( min = 329 RPM ) ALARM fan3: 0 RPM ( min = 329 RPM ) ALARM fan4: 0 RPM ( min = 329 RPM ) ALARM fan5: 0 RPM ( min = 329 RPM ) ALARM fan6: 0 RPM ( min = 329 RPM ) ALARM fan7: 0 RPM ( min = 329 RPM ) ALARM fan8: 0 RPM ( min = 329 RPM ) ALARM temp1: +52.5\u00b0C ( high = +70.0\u00b0C, hyst = +65.0\u00b0C ) ( crit = +85.0\u00b0C, hyst = +80.0\u00b0C ) sensor = thermal diode temp7: +52.8\u00b0C ( high = +70.0\u00b0C, hyst = +65.0\u00b0C ) ( crit = +85.0\u00b0C, hyst = +80.0\u00b0C ) sensor = AMD AMDSI temp8: +0.0\u00b0C ( high = +70.0\u00b0C, hyst = +65.0\u00b0C ) ( crit = +85.0\u00b0C, hyst = +80.0\u00b0C ) sensor = AMD AMDSI intrusion0: ALARM beep_enable: disabled fam15h_power-pci-00c4 Adapter: PCI adapter power1: 141 .35 W ( crit = 139 .72 W ) k10temp-pci-00c3 Adapter: PCI adapter temp1: +52.9\u00b0C ( high = +70.0\u00b0C ) For the software method with fancontrol service the fan speed adapts pretty quickly, but when using the automatic fan control from Dasharo release the spin up/down time is longer. coreboot configures the W83795 in Thermal Cruise mode which automatically probes the CPU temperature via AMD SB TSI interface. The target temperature is set to 50 Celsius degrees which means the chip will try to keep the CPU temperature to be around 50 degrees by adapting the fan speed. Summing it up, the longer the CPU temperature exceeds 50 degrees the faster the fan will spin by slowly increasing the RPM. When the temperature is below 50 degrees for a long period of time the fan rotates with a speed of around 1000 RPM. The critical temperature is set to 90 Celsius degrees. When this point is reached the W83795 should spin up to fans to full speed.","title":"Verifying fan speed adaptation"},{"location":"variants/asus_kgpe_d16/hardware-matrix/","text":"Hardware configuration matrix - ASUS KGPE-D16 This document describes the hardware configurations used for validation of the coreboot port on ASUS KGPE-D16 platforms. ASUS KGPE-D16 8MB Component Description CPU AMD Opteron(TM) Processor 6282 SE CPU Cooler AMD Opteron(TM) Processor 6282 SE CPU Cooler RAM DDR3 16GB Kingston KVR16R11D4/16 DDR3 16GB Kingston KVR16R11D4/16 Flash memory Winbond W25Q64FV 8MB Network Local network wired connection Attached devices 1. Goodram 16GB USB stick 2. ASUS TPM-L R2.0 module (chip Infineon SLB9665 TT2.0) Power Supply 700 W ATX type power supply Power Control 1. Sonoff S20 switch 2. Goldpin cables (RTE <-> Board connection) Remote Testing Environment 1. RTE v1.0.0 (firmware v0.5.3 ) connected via RS232 2. Goldpin cables + qspimux (RTE <-> flash memory connection) ASUS KGPE-D16 16MB Component Description CPU AMD Opteron(TM) Processor 6282 SE CPU Cooler RAM DDR3 16GB Kingston KVR16R11D4/16 Flash memory Winbond W25Q128JV 16MB Network Local network wired connection Attached devices: 1. Goodram 16GB USB stick 2. ASUS TPM 1.2 Rev 1.02h module (chip Infineon SLB9635 TT 1.2) 3. Post Debug Card Power Supply 700 W ATX type power supply Power Control: 1. Sonoff S20 switch 2. Goldpin cables (RTE <-> Board connection) Remote Testing Environment 1. RTE v1.0.0 (firmware v0.5.3 ) connected via RS232 2. POMONA Clip + DIP8/SOIC8 adapter (RTE <-> flash memory connection) ASUS KGPE-D16 board ports, slots, and connectors description is available in the manufacturer documentation (page 2-7).","title":"Hardware configuration matrix"},{"location":"variants/asus_kgpe_d16/hardware-matrix/#hardware-configuration-matrix-asus-kgpe-d16","text":"This document describes the hardware configurations used for validation of the coreboot port on ASUS KGPE-D16 platforms.","title":"Hardware configuration matrix - ASUS KGPE-D16"},{"location":"variants/asus_kgpe_d16/hardware-matrix/#asus-kgpe-d16-8mb","text":"Component Description CPU AMD Opteron(TM) Processor 6282 SE CPU Cooler AMD Opteron(TM) Processor 6282 SE CPU Cooler RAM DDR3 16GB Kingston KVR16R11D4/16 DDR3 16GB Kingston KVR16R11D4/16 Flash memory Winbond W25Q64FV 8MB Network Local network wired connection Attached devices 1. Goodram 16GB USB stick 2. ASUS TPM-L R2.0 module (chip Infineon SLB9665 TT2.0) Power Supply 700 W ATX type power supply Power Control 1. Sonoff S20 switch 2. Goldpin cables (RTE <-> Board connection) Remote Testing Environment 1. RTE v1.0.0 (firmware v0.5.3 ) connected via RS232 2. Goldpin cables + qspimux (RTE <-> flash memory connection)","title":"ASUS KGPE-D16 8MB"},{"location":"variants/asus_kgpe_d16/hardware-matrix/#asus-kgpe-d16-16mb","text":"Component Description CPU AMD Opteron(TM) Processor 6282 SE CPU Cooler RAM DDR3 16GB Kingston KVR16R11D4/16 Flash memory Winbond W25Q128JV 16MB Network Local network wired connection Attached devices: 1. Goodram 16GB USB stick 2. ASUS TPM 1.2 Rev 1.02h module (chip Infineon SLB9635 TT 1.2) 3. Post Debug Card Power Supply 700 W ATX type power supply Power Control: 1. Sonoff S20 switch 2. Goldpin cables (RTE <-> Board connection) Remote Testing Environment 1. RTE v1.0.0 (firmware v0.5.3 ) connected via RS232 2. POMONA Clip + DIP8/SOIC8 adapter (RTE <-> flash memory connection) ASUS KGPE-D16 board ports, slots, and connectors description is available in the manufacturer documentation (page 2-7).","title":"ASUS KGPE-D16 16MB"},{"location":"variants/asus_kgpe_d16/releases/","text":"ASUS KGPE-D16 Dasharo Release Notes Following Release Notes describe status of Open Source Firmware development for ASUS KGPE-D16. For details about our release process please read Dasharo Standard Release Process . Subscribe to Release Newsletter Feel free to contact us on our Matrix Dasharo space . Test results for this platform can be found here . v0.3.0 - 2021-12-16 Added TPM support vboot support (see how to sign and protect the image here ) build targets for vboot with measured boot using TPM 1.2 and TPM 2.0 Fixed cmos.layout being incorrectly mapped from RW CBFS during coreboot tables generation CC6 storage area being incorrectly included in cbmem top calculations ACPI DSDT LPC device name which caused TPM to be undetected by OS SPI controller driver sometimes dropping bytes sent/received through SPI FIFO Binaries 2MB vboot TPM 1.2 asus_kgpe-d16_v0.3.0_2M_vboot_TPM1.2.rom sha256 sha256.sig 2MB vboot TPM 2.0 asus_kgpe-d16_v0.3.0_2M_vboot_TPM2.0.rom sha256 sha256.sig 8MB vboot TPM 1.2 asus_kgpe-d16_v0.3.0_8M_vboot_TPM1.2.rom sha256 sha256.sig 8MB vboot TPM 2.0 asus_kgpe-d16_v0.3.0_8M_vboot_TPM2.0.rom sha256 sha256.sig 16MB vboot TPM 1.2 asus_kgpe-d16_v0.3.0_16M_vboot_TPM1.2.rom sha256 sha256.sig 16MB vboot TPM 2.0 asus_kgpe-d16_v0.3.0_16M_vboot_TPM2.0.rom sha256 sha256.sig SBOM (Software Bill of Materials) coreboot based on 4.14 revision 67190bf SeaBIOS based on rel-1.14.0 revision 155821a1 iPXE based on 2019.3 revision ebf2eaf5 nvramcui based on 4.14 revision f1d1309f v0.2.0 - 2021-12-9 Added coreboot resource allocator v4 support Nuvoton W83795 HW monitor driver automatic fan control with W83795 platform and silicon ramstage support 2MB, 8MB and 16MB SPI flash targets SeaBIOS, iPXE and nvramcui payloads Binaries 2MB target asus_kgpe-d16_v0.2.0_2M.rom sha256 sha256.sig 8MB target asus_kgpe-d16_v0.2.0_8M.rom sha256 sha256.sig 16MB target asus_kgpe-d16_v0.2.0_16M.rom sha256 sha256.sig SBOM (Software Bill of Materials) coreboot based on 4.14 revision 63b7cbc1 SeaBIOS based on rel-1.14.0 revision 155821a1 iPXE based on 2019.3 revision ebf2eaf5 nvramcui based on 4.14 revision 63b7cbc1 v0.1.0 - 2021-11-10 Added C bootblock support postcar stage and no CAR global migration support separated chipset and mainboard code put non-mainboard specific romstage initialization to northirdge support for relocatable ramstage with caching in CBMEM Binaries asus_kgpe-d16_v0.1.0.rom asus_kgpe-d16_v0.1.0.rom.sha256 asus_kgpe-d16_v0.1.0.rom.sha256.sig SBOM (Software Bill of Materials) coreboot based on 03aef28 revision e6af2206","title":"Releases"},{"location":"variants/asus_kgpe_d16/releases/#asus-kgpe-d16-dasharo-release-notes","text":"Following Release Notes describe status of Open Source Firmware development for ASUS KGPE-D16. For details about our release process please read Dasharo Standard Release Process . Subscribe to Release Newsletter Feel free to contact us on our Matrix Dasharo space . Test results for this platform can be found here .","title":"ASUS KGPE-D16 Dasharo Release Notes"},{"location":"variants/asus_kgpe_d16/releases/#v030-2021-12-16","text":"","title":"v0.3.0 - 2021-12-16"},{"location":"variants/asus_kgpe_d16/releases/#v020-2021-12-9","text":"","title":"v0.2.0 - 2021-12-9"},{"location":"variants/asus_kgpe_d16/releases/#v010-2021-11-10","text":"","title":"v0.1.0 - 2021-11-10"},{"location":"variants/asus_kgpe_d16/setup/","text":"RTE v.0.5.3 with Asus KGPE-D16 connection Power supply Power to the Asus KGPE-D16 is delivered by a common PC power supply. Simply connect the power supply to ATX compatible connectors on the mainboard (SSIPWR1, SSI12V1, SSI12V2). SPI BIOS SPI flash is a socketed DIP-8. There is no simple way to attach to it with any tools. That is why we have thought about the qspimux made by Felix Held which can attach to various SPI modules footprints and sockets. The DIP-8 adapter is put into the DIP-8 socket on the mainboard, which allows attaching the qspimux SPI multiplexer. The multiplexer is responsible for switching between the external SPI lines and the mainboard lines routed to the external SPI flash chip. The external flash chip is soldered on a SOIC8 adapter, which is connected to the qspimux. The connection of the RTE and qspimux is as follows: RTE header J7 pin qspimux J101 pin 1 (VCC) 2 (VCC_PROG) 2 (GND) 7 (GND) 3 (CS) 1 (CS_PROG#) 4 (SCLK) 6 (CLK_PROG) 5 (MISO) 8 (IO0_DI_PROG) 6 (MOSI) 3 (IO1_DO_PROG) 7 (NC) Not connected 8 (NC) Not connected Additionally, one has to tie the IO3_HOLD_PROG (qspimux pin 4) high, so connect it to the 3.3V permanently. Another additional GPIO is required to control the routing of SPI lines. The MUX_SEL (qspimux pin 9) decides whether the programmer is allowed to access the SPI flash or the mainboard. One more GPIO is used to control state of #WP of the flash chip by connecting GPIO to IO2_WP_PROG. The proposed connections used: RTE GPIO400 to control MUX_SEL RTE GPIO401 to control IO3_HOLD_PROG RTE GPIO402 to control IO2_WP_PROG Simple flashing script looks as follows: # select flash <-> programmer echo \"0\" > /sys/class/gpio/gpio400/value # deassert SPI HOLD# echo \"1\" > /sys/class/gpio/gpio401/value flashrom -w firmware.bin -p linux_spi:dev = /dev/spidev1.0,spispeed = 16000 # select flash <-> board echo \"1\" > /sys/class/gpio/gpio400/value Controlling state of #WP: # configure direction of the pin echo \"out\" > /sys/class/gpio/gpio402/direction # deassert WP pin to disable hardware protection of status registers echo \"1\" > /sys/class/gpio/gpio402/value # assert WP pin to enable hardware protection of status registers echo \"0\" > /sys/class/gpio/gpio402/value RTE header J10 pin qspimux J101 pin 1 (GPIO400) 9 (MUX_SEL) 2 (GPIO401) 4 (IO3_HOLD_PROG) 3 (GPIO402) 5 (IO2_WP_PROG) qspimux schematic is available here Serial Asus KGPE-D16 has a DB9 serial connector for the debug UART. Connect it to the RTE via RS232 DB9 cable. TPM Asus KGPE-D16 has an LPC header for TPM or debugging. Since there is no other option to connect a TPM, we use the header for that purpose. IMPORTANT: Use only TPM modules which match their pinout with the board's header! Using a spider web connection degrades the signal quality to the point where CPU cannot properly talk to TPM via LPC bus. TPM modules that were tested and verified to work in 3mdeb lab with coreboot: ASUS TPM-L R2.0 module (chip Infineon SLB9665 TT 2.0) ASUS TPM 1.2 Rev 1.02h module (chip Infineon SLB9635 TT 1.2) Power management Asus KGPE-D16 provides a front panel pin header (PANEL1): RTE header J11 pin Asus KGPE-D16 8 (OC buffer output) PANEL1 pin 11 (PWR) 9 (OC buffer output) PANEL1 pin 17 (RESET) Additionally, connect one of the PANEL1 ground pins to one of the ground pins on RTE. Manunal For more details about the KGPE-D16, refer to the manual . Theory of operation Flashing There are two RTEs connected to two Asus KGPE-D16 boards: 192.168.20.15 192.168.4.111 Both boards are equipped with the qspimux and a replaced flash chip (Winbond W25Q64FV 8MB). The flash chip is attached to the qspimux with an adapter available with qspimux. Flashing may be done via the commands shown earlier or the flash script which is present in the root directory of the RTE: ./flash.sh coreboot.rom The script will automatically power off the board and update flash chip contents using flashrom. After the operation is finished the routing of SPI signals is restored to the platform. The flash chip adapter In order to provide an easy way to protect the SPI flash chip one may use a DIP-8 to SOIC-8 adapter with a special long pin header for WP pin jumper. It allows to use a SOIC-8 packaged flash in the DIP-8 socket and easily place a jumper to protect the flash. In order to assembly the adapter you will need the target SPI flash chip (we use wither Winbond W25Q64FV (8MB) or W25Q128JV (16MB)), male pin headers 2.54 mm pitch (6 pins) male long pin headers 2.54 mm pitch (2 pins) for the WP jumper SOIC-8 to DIP-8 adapter soldering station and the solder The build shall look like this: Such adapters are now available in our online shop for purchase. For more details how to enable SPI flash protection refer to SPI Flash protection page . Power management RTE can control the power of the board with the RteCtrl command-line application, or with the web GUI ( RteCtrl ) available at RTE's IP address port 8000. Possible commands are: ./RteCtrl -pon # power on the platform ./RteCtrl -poff # force 5seconds power button power off ./RteCtrl -reset # briefly assert platform reset pin to perform reset It is also possible to control the ATX power supply by disconnecting it from the power socket. For this special purpose, Sonoff S20 is used to remotely control the power socket activity. Sonoff IP to RTE IP mapping: RTE IP 192.168.20.15 - Sonoff IP 192.168.4.125 RTE IP 192.168.4.111 - Sonoff IP 192.168.4.146 Sonoffs respond to rest API requests to enable or disable the power socket. Shell scripts have been added to RTE root directories to ease the control of power of the KGPE-D16 platform: #!/bin/bash SONOFF_IP = 192 .168.4.125 if [[ \" $1 \" == \"off\" ]] ; then wget -q -O - http:// $SONOFF_IP /switch/sonoff_s20_relay/turn_off --method = POST elif [[ \" $1 \" == \"on\" ]] ; then wget -q -O - http:// $SONOFF_IP /switch/sonoff_s20_relay/turn_on --method = POST elif [[ \" $1 \" == \"show\" ]] ; then wget -q -O - http:// $SONOFF_IP /switch/sonoff_s20_relay echo -e '\\n' else echo -e \"\\$1 == on|off|show|toggle\\nEdit this script to set the sonoff ip.\" echo -e 'Current state:' wget -q -O - http:// $SONOFF_IP /switch/sonoff_s20_relay echo -e '\\n' fi To turn off the power from the platform ./sonoff.sh off and to turn it on ./sonoff.sh on . Invoking the script without any argument will print the current state of the switch. Serial console access A serial port is very useful in debugging and as a remote console of the system on the platform. The serial port of KGPE-D16 is connected to the RTE's serial port which can be accessed on RTE with /dev/ttyS1 . One may use minicom directly or take advantage of the ser2net service running on RTE which exposes the serial port over the network. The serial port can be accessed remotely like this telnet RTE_IP 13541 , e.g.: telnet 192 .168.20.15 13541 Demo A short demo presenting RTE capabilities with KGPE-D16: Remote access If you are interested in developing coreboot on KGPE-D16 and have some spare time, there is a possibility to obtain access to the hardware. Drop us an email to leads@3mdeb.com with a request. Newsletter If you are interested in this project, you can subscribe to the Dasharo KGPE-D16 Newsletter . If you are interested in the Dasharo in general, you are welcome to subscribe to the Dasharo Newsletter . Gallery","title":"Hardware setup"},{"location":"variants/asus_kgpe_d16/setup/#rte-v053-with-asus-kgpe-d16-connection","text":"","title":"RTE v.0.5.3 with Asus KGPE-D16 connection"},{"location":"variants/asus_kgpe_d16/setup/#power-supply","text":"Power to the Asus KGPE-D16 is delivered by a common PC power supply. Simply connect the power supply to ATX compatible connectors on the mainboard (SSIPWR1, SSI12V1, SSI12V2).","title":"Power supply"},{"location":"variants/asus_kgpe_d16/setup/#spi","text":"BIOS SPI flash is a socketed DIP-8. There is no simple way to attach to it with any tools. That is why we have thought about the qspimux made by Felix Held which can attach to various SPI modules footprints and sockets. The DIP-8 adapter is put into the DIP-8 socket on the mainboard, which allows attaching the qspimux SPI multiplexer. The multiplexer is responsible for switching between the external SPI lines and the mainboard lines routed to the external SPI flash chip. The external flash chip is soldered on a SOIC8 adapter, which is connected to the qspimux. The connection of the RTE and qspimux is as follows: RTE header J7 pin qspimux J101 pin 1 (VCC) 2 (VCC_PROG) 2 (GND) 7 (GND) 3 (CS) 1 (CS_PROG#) 4 (SCLK) 6 (CLK_PROG) 5 (MISO) 8 (IO0_DI_PROG) 6 (MOSI) 3 (IO1_DO_PROG) 7 (NC) Not connected 8 (NC) Not connected Additionally, one has to tie the IO3_HOLD_PROG (qspimux pin 4) high, so connect it to the 3.3V permanently. Another additional GPIO is required to control the routing of SPI lines. The MUX_SEL (qspimux pin 9) decides whether the programmer is allowed to access the SPI flash or the mainboard. One more GPIO is used to control state of #WP of the flash chip by connecting GPIO to IO2_WP_PROG. The proposed connections used: RTE GPIO400 to control MUX_SEL RTE GPIO401 to control IO3_HOLD_PROG RTE GPIO402 to control IO2_WP_PROG Simple flashing script looks as follows: # select flash <-> programmer echo \"0\" > /sys/class/gpio/gpio400/value # deassert SPI HOLD# echo \"1\" > /sys/class/gpio/gpio401/value flashrom -w firmware.bin -p linux_spi:dev = /dev/spidev1.0,spispeed = 16000 # select flash <-> board echo \"1\" > /sys/class/gpio/gpio400/value Controlling state of #WP: # configure direction of the pin echo \"out\" > /sys/class/gpio/gpio402/direction # deassert WP pin to disable hardware protection of status registers echo \"1\" > /sys/class/gpio/gpio402/value # assert WP pin to enable hardware protection of status registers echo \"0\" > /sys/class/gpio/gpio402/value RTE header J10 pin qspimux J101 pin 1 (GPIO400) 9 (MUX_SEL) 2 (GPIO401) 4 (IO3_HOLD_PROG) 3 (GPIO402) 5 (IO2_WP_PROG) qspimux schematic is available here","title":"SPI"},{"location":"variants/asus_kgpe_d16/setup/#serial","text":"Asus KGPE-D16 has a DB9 serial connector for the debug UART. Connect it to the RTE via RS232 DB9 cable.","title":"Serial"},{"location":"variants/asus_kgpe_d16/setup/#tpm","text":"Asus KGPE-D16 has an LPC header for TPM or debugging. Since there is no other option to connect a TPM, we use the header for that purpose. IMPORTANT: Use only TPM modules which match their pinout with the board's header! Using a spider web connection degrades the signal quality to the point where CPU cannot properly talk to TPM via LPC bus. TPM modules that were tested and verified to work in 3mdeb lab with coreboot: ASUS TPM-L R2.0 module (chip Infineon SLB9665 TT 2.0) ASUS TPM 1.2 Rev 1.02h module (chip Infineon SLB9635 TT 1.2)","title":"TPM"},{"location":"variants/asus_kgpe_d16/setup/#power-management","text":"Asus KGPE-D16 provides a front panel pin header (PANEL1): RTE header J11 pin Asus KGPE-D16 8 (OC buffer output) PANEL1 pin 11 (PWR) 9 (OC buffer output) PANEL1 pin 17 (RESET) Additionally, connect one of the PANEL1 ground pins to one of the ground pins on RTE.","title":"Power management"},{"location":"variants/asus_kgpe_d16/setup/#manunal","text":"For more details about the KGPE-D16, refer to the manual .","title":"Manunal"},{"location":"variants/asus_kgpe_d16/setup/#demo","text":"A short demo presenting RTE capabilities with KGPE-D16:","title":"Demo"},{"location":"variants/asus_kgpe_d16/setup/#newsletter","text":"If you are interested in this project, you can subscribe to the Dasharo KGPE-D16 Newsletter . If you are interested in the Dasharo in general, you are welcome to subscribe to the Dasharo Newsletter .","title":"Newsletter"},{"location":"variants/asus_kgpe_d16/setup/#gallery","text":"","title":"Gallery"},{"location":"variants/asus_kgpe_d16/spi-wp/","text":"SPI hardware write protection In order to from a Root of Trust in the firmware, e.g. in the immutable piece of firmware code for Static Root of Trust of Measurement one has to ensure the protection of this piece of code. One may achieve it by enabling Inte lBoot Guard or AMD Platform Secure Boot. However these technologies may nto always be available. In such case SPI hardware write protection becomes handy. Thanks to the patchset implementing write protection and OTP support in flashrom one can easily set the SPI write protection of the platform from the operating system user space. This page explain how to build the flashrom with WP and OTP support and use to to protect the coreboot's bootblock to form SRTM. Building flashrom In order to build flashrom we will need some packages and librares. For Debian based distros execute: sudo apt-get install git make binutils build-essential ca-certificates \\ libpci-dev libftdi-dev libusb-1.0-0-dev Now clone the flashrom repository and fetch the patchset: git clone https://github.com/flashrom/flashrom cd flashrom git fetch https://review.coreboot.org/flashrom refs/changes/13/59713/7 && \\ git checkout FETCH_HEAD Build flashrom: make The freshly built flashrom will be present in root directory of the repository. Flashrom write protection CLI Invoke the following command to see a lsit of available options for flashrom: ./flashrom --help flashrom v1.2-585-g3542afe on Linux 5 .10.0-9-amd64 ( x86_64 ) flashrom is free software, get the source code at https://flashrom.org Usage: ./flashrom [ -h | -R | -L | -p <programmername> [ :<parameters> ] [ -c <chipname> ] ( --flash-name | --flash-size | [ -E | -x | ( -r | -w | -v ) <file> ] [( -l <layoutfile> | --ifd | --fmap | --fmap-file <file> ) [ -i <region> [ :<file> ]] ... ] [ -n ] [ -N ] [ -f ])] [ -V [ V [ V ]]] [ -o <logfile> ] -h | --help print this help text -R | --version print version ( release ) -r | --read <file> read flash and save to <file> -w | --write <file | -> write <file> or the content provided on the standard input to flash -v | --verify <file | -> verify flash against <file> or the content provided on the standard input -E | --erase erase flash memory -V | --verbose more verbose output -c | --chip <chipname> probe only for specified flash chip -f | --force force specific operations ( see man page ) -n | --noverify don ' t auto-verify -N | --noverify-all verify included regions only ( cf. -i ) -x | --extract extract regions to files -l | --layout <layoutfile> read ROM layout from <layoutfile> --wp-disable disable write protection --wp-enable enable write protection --wp-list list supported write protection ranges --wp-status show write protection status --wp-range = <start>,<len> set write protection range ( use --wp-range = 0 ,0 to unprotect the entire flash ) --wp-region <region> set write protection region --otp-status print information about OTP regions --otp-region <otp-region> OTP region number ( base 1 ) to operate on --otp-read <file> read OTP region and save it to <file> --otp-write <file> write <file> to OTP region --otp-erase erase OTP region --otp-lock lock OTP region --flash-name read out the detected flash name --flash-size read out the detected flash size --fmap read ROM layout from fmap embedded in ROM --fmap-file <fmapfile> read ROM layout from fmap in <fmapfile> --ifd read layout from an Intel Firmware Descriptor -i | --image <region> [ :<file> ] only read/write image <region> from layout ( optionally with data from <file> ) -o | --output <logfile> log output to <logfile> --flash-contents <ref-file> assume flash contents to be <ref-file> -L | --list-supported print supported devices -p | --programmer <name> [ :<param> ] specify the programmer device. One of internal, dummy, nic3com, nicrealtek, gfxnvidia, raiden_debug_spi, drkaiser, satasii, atavia, it8212, ft2232_spi, serprog, buspirate_spi, dediprog, developerbox, rayer_spi, pony_spi, nicintel, nicintel_spi, nicintel_eeprom, ogp_spi, satamv, linux_mtd, linux_spi, usbblaster_spi, pickit2_spi, ch341a_spi, digilent_spi, stlinkv3_spi. You can specify one of -h, -R, -L, -E, -r, -w, -v or no operation. If no operation is specified, flashrom will only probe for flash chips. We will use only a few of those options to set the protection on the coreboot's bootblock. We protect the bootblock only, since it is the stage responsible for measurements and verification of next stages. Setting flash protection using flashrom NOTE: be sure to update the firmware first before proceeding! Estimating bootblock size and protection range First let's see how much space we need to protect. Take your coreboot.rom file and use cbfstool to show its contents: cd /path/to/coreboot/build ./cbfstool coreboot.rom print FMAP REGION: COREBOOT Name Offset Type Size Comp cbfs master header 0x0 cbfs header 32 none fallback/romstage 0x80 stage 171040 none fallback/ramstage 0x29d40 stage 98703 LZMA ( 229532 decompressed ) config 0x41f40 raw 709 none revision 0x42240 raw 723 none build_info 0x42540 raw 101 none fallback/dsdt.aml 0x42600 raw 7055 none cmos.default 0x441c0 cmos_default 256 none cmos_layout.bin 0x44300 cmos_layout 3676 none fallback/postcar 0x451c0 stage 21216 none img/nvramcui 0x4a500 simple elf 70630 none fallback/payload 0x5b940 simple elf 69936 none payload_config 0x6cac0 raw 1621 none payload_revision 0x6d140 raw 237 none pci8086,10d3.rom 0x6d280 raw 82944 none etc/sercon-port 0x816c0 raw 8 none ( empty ) 0x81700 null 8128932 none bootblock 0xffcac0 bootblock 13056 none The bootblock is taking slightly more than 12KB of space on the bottom of the flash. Converting 12KB to hex would be equal to 0x3000 but we must cover a little bit more than that. Let's see what protection ranges are available for the chip (running from the tagret machine to be protected): ./flashrom -p internal --wp-list ... Available write protection ranges: start = 0x00000000 length = 0x00000000 ( none ) start = 0x00000000 length = 0x00001000 ( lower 1 /2048 ) start = 0x007ff000 length = 0x00001000 ( upper 1 /2048 ) start = 0x00000000 length = 0x00002000 ( lower 1 /1024 ) start = 0x007fe000 length = 0x00002000 ( upper 1 /1024 ) start = 0x00000000 length = 0x00004000 ( lower 1 /512 ) start = 0x007fc000 length = 0x00004000 ( upper 1 /512 ) start = 0x00000000 length = 0x00008000 ( lower 1 /256 ) start = 0x007f8000 length = 0x00008000 ( upper 1 /256 ) start = 0x00000000 length = 0x00020000 ( lower 1 /64 ) start = 0x007e0000 length = 0x00020000 ( upper 1 /64 ) start = 0x00000000 length = 0x00040000 ( lower 1 /32 ) start = 0x007c0000 length = 0x00040000 ( upper 1 /32 ) start = 0x00000000 length = 0x00080000 ( lower 1 /16 ) start = 0x00780000 length = 0x00080000 ( upper 1 /16 ) start = 0x00000000 length = 0x00100000 ( lower 1 /8 ) start = 0x00700000 length = 0x00100000 ( upper 1 /8 ) start = 0x00000000 length = 0x00200000 ( lower 1 /4 ) start = 0x00600000 length = 0x00200000 ( upper 1 /4 ) start = 0x00000000 length = 0x00400000 ( lower 1 /2 ) start = 0x00400000 length = 0x00400000 ( upper 1 /2 ) start = 0x00000000 length = 0x00600000 ( lower 3 /4 ) start = 0x00200000 length = 0x00600000 ( upper 3 /4 ) start = 0x00000000 length = 0x00700000 ( lower 7 /8 ) start = 0x00100000 length = 0x00700000 ( upper 7 /8 ) start = 0x00000000 length = 0x00780000 ( lower 15 /16 ) start = 0x00080000 length = 0x00780000 ( upper 15 /16 ) start = 0x00000000 length = 0x007c0000 ( lower 31 /32 ) start = 0x00040000 length = 0x007c0000 ( upper 31 /32 ) start = 0x00000000 length = 0x007e0000 ( lower 63 /64 ) start = 0x00020000 length = 0x007e0000 ( upper 63 /64 ) start = 0x00000000 length = 0x007f8000 ( lower 255 /256 ) start = 0x00008000 length = 0x007f8000 ( upper 255 /256 ) start = 0x00000000 length = 0x007fc000 ( lower 511 /512 ) start = 0x00004000 length = 0x007fc000 ( upper 511 /512 ) start = 0x00000000 length = 0x007fe000 ( lower 1023 /1024 ) start = 0x00002000 length = 0x007fe000 ( upper 1023 /1024 ) start = 0x00000000 length = 0x007ff000 ( lower 2047 /2048 ) start = 0x00001000 length = 0x007ff000 ( upper 2047 /2048 ) start = 0x00000000 length = 0x00800000 ( all ) The output abvoe comes from Winbond W25Q64FV, a 8MB chip. Bootblock is always mapped to the bottom of the flash. 1MB is equal to 0x100000 so 8MB would be 0x800000. We need at least 0x4000 (16KB) to be protected starting at the bottom of the flash. And fortunately we have found our best match: start=0x007fc000 length=0x00004000 (upper 1/512) . Clearing SPI write protection Now that we have selected the desired range to protect, it is time to check the current protection status: ./flashrom -p internal --wp-status ... WP config bits: SRP1 = 0 SRP0 = 0 CMP = 0 SEC = 0 TB = 0 BP2 = 0 BP1 = 0 BP0 = 0 Protection range: start = 0x00000000 length = 0x00000000 ( none ) Protection mode: disabled The protection range should be set to zeros and all WP config bits should be cleared. If you see some bits were not cleared, ensure the WP pin jumper on the flash is not placed and invoke: ./flashrom -p internal --wp-disable ./flashrom -p internal --wp-range = 0 ,0 now that we have a clear state of the flash protection we may proceed with enabling the right range. Setting protection range Copy the range base and length and invoke: ./flashrom -p internal --wp-range = 0x007fc000,0x00004000 Setting SPI status register protection Flashrom should report Sucessfully set the requested protection range. . Now set the status register protection so the range protection cannot be changed: ./flashrom -p internal --wp-enable Flashrom should report Sucessfully set the requested mode. . Verifying SPI wite protection To check whether the settings are desired invoke: ./flashrom -p internal --wp-status ... WP config bits: SRP1 = 0 SRP0 = 1 CMP = 0 SEC = 1 TB = 0 BP2 = 0 BP1 = 1 BP0 = 1 Protection range: start = 0x007fc000 length = 0x00004000 ( upper 1 /512 ) Protection mode: hardware If it matches what you have wanted to set it is time to lock the status register protection bit (SRP0) from being changed. SRP0 protects the CMP, SEC, TB and BPx bits from being changed. In order to lock the SRP0 bit you have to place the jumper on the WP pin and tie it to ground (GND). This will assert the WP pin and prevent any WP config bits from being changed. To verify it invoke: ./flashrom -p internal --wp-disable ... Writing new WP configuration failed during verification: Expected configuration: SRP1 = 0 SRP0 = 0 CMP = 0 SEC = 1 TB = 0 BP2 = 0 BP1 = 1 BP0 = 1 Actual configuration: SRP1 = 0 SRP0 = 1 CMP = 0 SEC = 1 TB = 0 BP2 = 0 BP1 = 1 BP0 = 1 You should get the above result. Changing the protection range Now if you want to reprogram the protection range, you need to take off the jumper and invoke: ./flashrom -p internal --wp-disable Now you should get Sucessfully set the requested mode. now. Check the WP status: WP config bits: SRP1 = 0 SRP0 = 0 CMP = 0 SEC = 1 TB = 0 BP2 = 0 BP1 = 1 BP0 = 1 Protection range: start = 0x007fc000 length = 0x00004000 ( upper 1 /512 ) Protection mode: disabled It must indicate Protection mode: disabled . Now you may reconfigure the range, e.g. ./flashrom -p internal --wp-range = 0x007e0000,0x00020000 And proceed with enabling protection and setting back the jumper. Setting flash protection for vboot In case when vboot is enabled the protection range must be extended in order to cover other parts of the firmware. Vboot model assumes there is a read-only copy of the coreboot and payload called recovery partition. The recovery partition is supposed to be protected with a SPI write protection. The read-only region contains the bootblock, verstage (vboot stage used to verify other firmware components) and vboot keys and all other stages required to boot the platform in case of emergency. Typically the read-only partition occupies a space that matches the possible write protected regions of the flash chip. There are also read-write partitions (up to 2) that contain an updatable copies of the coreboot and payload. Unlike read-only partitions, read-write partitions are being verified using the signatures put into the read-write partitions. vboot checks the signature and decides whether read-write partition is safe to boot, otherwise it proceeds with execution of recovery firmware. The boot flow is shown on the diagram below: In order to properly protect the firmware, one has to lock whole WP_RO region define by flashmap in coreboot. To locate the region offset and size one has to use cbfstool to retrieve layout: cd /path/to/coreboot/build ./cbfstool coreboot.rom layout -w This image contains the following sections that can be accessed with this tool: 'RW_MISC' ( read-only, size 524288 , offset 0 ) 'UNIFIED_MRC_CACHE' ( read-only, size 131072 , offset 0 ) 'RECOVERY_MRC_CACHE' ( size 65536 , offset 0 ) 'RW_MRC_CACHE' ( size 65536 , offset 65536 ) 'SMMSTORE' ( preserve, size 262144 , offset 131072 ) 'CONSOLE' ( size 131072 , offset 393216 ) 'RW_NVRAM' ( size 16384 , offset 524288 ) 'RW_SECTION_A' ( read-only, size 5750784 , offset 540672 ) 'VBLOCK_A' ( size 8192 , offset 540672 ) 'FW_MAIN_A' ( CBFS, size 5742528 , offset 548864 ) 'RW_FWID_A' ( size 64 , offset 6291392 ) 'WP_RO' ( read-only, size 2097152 , offset 6291456 ) 'RO_VPD' ( preserve, size 16384 , offset 6291456 ) 'RO_SECTION' ( read-only, size 2080768 , offset 6307840 ) 'FMAP' ( read-only, size 2048 , offset 6307840 ) 'RO_FRID' ( size 64 , offset 6309888 ) 'RO_FRID_PAD' ( size 1984 , offset 6309952 ) 'GBB' ( size 16384 , offset 6311936 ) 'COREBOOT' ( CBFS, size 2060288 , offset 6328320 ) It is at least possible to perform the read action on every section listed above. The above example shows the KGPE-D16 8MB target with vboot enabled. The WP_RO section is at offset of 6291456 bytes from the beginning of the flash and has size of 2097152 bytes. These numbers are in decimal, so one must convert them to hex. Either use an online hex converter or use the command in bash like a pro :) printf \"0x%x\\n\" 6291456 0x600000 printf \"0x%x\\n\" 2097152 0x200000 So our WP range would be 2MB at 6MB offset start=0x00600000 length=0x00200000 (upper 1/4) . But before proceeding with setting the WP range, one may want to sign the firmware with own vboot keys. The Dasharo build come by default with Google vboot developer keys, so to take advantage of vboot, one should sign the binary before flashing and setting the WP range. Refer to vboot signing . Unfortunately the utilities support only 2 RW partitions for resiging. Otherwise a whole image must be rebuilt. After custo mkeys have been used to sign the ifmrware image and the image has been flashed proceed with enalbing the protection: ./flashrom -p internal --wp-range = 0x00600000,0x00200000 Then proceed with Setting SPI status register protection and Verifying SPI wite protection . At this point you should have your coreboot firmware with vboot well protected and ready to go. Place the jumper in order to prevent any changes to the configuration.","title":"Hardware flash protection"},{"location":"variants/asus_kgpe_d16/spi-wp/#spi-hardware-write-protection","text":"In order to from a Root of Trust in the firmware, e.g. in the immutable piece of firmware code for Static Root of Trust of Measurement one has to ensure the protection of this piece of code. One may achieve it by enabling Inte lBoot Guard or AMD Platform Secure Boot. However these technologies may nto always be available. In such case SPI hardware write protection becomes handy. Thanks to the patchset implementing write protection and OTP support in flashrom one can easily set the SPI write protection of the platform from the operating system user space. This page explain how to build the flashrom with WP and OTP support and use to to protect the coreboot's bootblock to form SRTM.","title":"SPI hardware write protection"},{"location":"variants/asus_kgpe_d16/spi-wp/#building-flashrom","text":"In order to build flashrom we will need some packages and librares. For Debian based distros execute: sudo apt-get install git make binutils build-essential ca-certificates \\ libpci-dev libftdi-dev libusb-1.0-0-dev Now clone the flashrom repository and fetch the patchset: git clone https://github.com/flashrom/flashrom cd flashrom git fetch https://review.coreboot.org/flashrom refs/changes/13/59713/7 && \\ git checkout FETCH_HEAD Build flashrom: make The freshly built flashrom will be present in root directory of the repository.","title":"Building flashrom"},{"location":"variants/asus_kgpe_d16/spi-wp/#flashrom-write-protection-cli","text":"Invoke the following command to see a lsit of available options for flashrom: ./flashrom --help flashrom v1.2-585-g3542afe on Linux 5 .10.0-9-amd64 ( x86_64 ) flashrom is free software, get the source code at https://flashrom.org Usage: ./flashrom [ -h | -R | -L | -p <programmername> [ :<parameters> ] [ -c <chipname> ] ( --flash-name | --flash-size | [ -E | -x | ( -r | -w | -v ) <file> ] [( -l <layoutfile> | --ifd | --fmap | --fmap-file <file> ) [ -i <region> [ :<file> ]] ... ] [ -n ] [ -N ] [ -f ])] [ -V [ V [ V ]]] [ -o <logfile> ] -h | --help print this help text -R | --version print version ( release ) -r | --read <file> read flash and save to <file> -w | --write <file | -> write <file> or the content provided on the standard input to flash -v | --verify <file | -> verify flash against <file> or the content provided on the standard input -E | --erase erase flash memory -V | --verbose more verbose output -c | --chip <chipname> probe only for specified flash chip -f | --force force specific operations ( see man page ) -n | --noverify don ' t auto-verify -N | --noverify-all verify included regions only ( cf. -i ) -x | --extract extract regions to files -l | --layout <layoutfile> read ROM layout from <layoutfile> --wp-disable disable write protection --wp-enable enable write protection --wp-list list supported write protection ranges --wp-status show write protection status --wp-range = <start>,<len> set write protection range ( use --wp-range = 0 ,0 to unprotect the entire flash ) --wp-region <region> set write protection region --otp-status print information about OTP regions --otp-region <otp-region> OTP region number ( base 1 ) to operate on --otp-read <file> read OTP region and save it to <file> --otp-write <file> write <file> to OTP region --otp-erase erase OTP region --otp-lock lock OTP region --flash-name read out the detected flash name --flash-size read out the detected flash size --fmap read ROM layout from fmap embedded in ROM --fmap-file <fmapfile> read ROM layout from fmap in <fmapfile> --ifd read layout from an Intel Firmware Descriptor -i | --image <region> [ :<file> ] only read/write image <region> from layout ( optionally with data from <file> ) -o | --output <logfile> log output to <logfile> --flash-contents <ref-file> assume flash contents to be <ref-file> -L | --list-supported print supported devices -p | --programmer <name> [ :<param> ] specify the programmer device. One of internal, dummy, nic3com, nicrealtek, gfxnvidia, raiden_debug_spi, drkaiser, satasii, atavia, it8212, ft2232_spi, serprog, buspirate_spi, dediprog, developerbox, rayer_spi, pony_spi, nicintel, nicintel_spi, nicintel_eeprom, ogp_spi, satamv, linux_mtd, linux_spi, usbblaster_spi, pickit2_spi, ch341a_spi, digilent_spi, stlinkv3_spi. You can specify one of -h, -R, -L, -E, -r, -w, -v or no operation. If no operation is specified, flashrom will only probe for flash chips. We will use only a few of those options to set the protection on the coreboot's bootblock. We protect the bootblock only, since it is the stage responsible for measurements and verification of next stages.","title":"Flashrom write protection CLI"},{"location":"variants/asus_kgpe_d16/spi-wp/#setting-flash-protection-using-flashrom","text":"NOTE: be sure to update the firmware first before proceeding!","title":"Setting flash protection using flashrom"},{"location":"variants/asus_kgpe_d16/spi-wp/#setting-flash-protection-for-vboot","text":"In case when vboot is enabled the protection range must be extended in order to cover other parts of the firmware. Vboot model assumes there is a read-only copy of the coreboot and payload called recovery partition. The recovery partition is supposed to be protected with a SPI write protection. The read-only region contains the bootblock, verstage (vboot stage used to verify other firmware components) and vboot keys and all other stages required to boot the platform in case of emergency. Typically the read-only partition occupies a space that matches the possible write protected regions of the flash chip. There are also read-write partitions (up to 2) that contain an updatable copies of the coreboot and payload. Unlike read-only partitions, read-write partitions are being verified using the signatures put into the read-write partitions. vboot checks the signature and decides whether read-write partition is safe to boot, otherwise it proceeds with execution of recovery firmware. The boot flow is shown on the diagram below: In order to properly protect the firmware, one has to lock whole WP_RO region define by flashmap in coreboot. To locate the region offset and size one has to use cbfstool to retrieve layout: cd /path/to/coreboot/build ./cbfstool coreboot.rom layout -w This image contains the following sections that can be accessed with this tool: 'RW_MISC' ( read-only, size 524288 , offset 0 ) 'UNIFIED_MRC_CACHE' ( read-only, size 131072 , offset 0 ) 'RECOVERY_MRC_CACHE' ( size 65536 , offset 0 ) 'RW_MRC_CACHE' ( size 65536 , offset 65536 ) 'SMMSTORE' ( preserve, size 262144 , offset 131072 ) 'CONSOLE' ( size 131072 , offset 393216 ) 'RW_NVRAM' ( size 16384 , offset 524288 ) 'RW_SECTION_A' ( read-only, size 5750784 , offset 540672 ) 'VBLOCK_A' ( size 8192 , offset 540672 ) 'FW_MAIN_A' ( CBFS, size 5742528 , offset 548864 ) 'RW_FWID_A' ( size 64 , offset 6291392 ) 'WP_RO' ( read-only, size 2097152 , offset 6291456 ) 'RO_VPD' ( preserve, size 16384 , offset 6291456 ) 'RO_SECTION' ( read-only, size 2080768 , offset 6307840 ) 'FMAP' ( read-only, size 2048 , offset 6307840 ) 'RO_FRID' ( size 64 , offset 6309888 ) 'RO_FRID_PAD' ( size 1984 , offset 6309952 ) 'GBB' ( size 16384 , offset 6311936 ) 'COREBOOT' ( CBFS, size 2060288 , offset 6328320 ) It is at least possible to perform the read action on every section listed above. The above example shows the KGPE-D16 8MB target with vboot enabled. The WP_RO section is at offset of 6291456 bytes from the beginning of the flash and has size of 2097152 bytes. These numbers are in decimal, so one must convert them to hex. Either use an online hex converter or use the command in bash like a pro :) printf \"0x%x\\n\" 6291456 0x600000 printf \"0x%x\\n\" 2097152 0x200000 So our WP range would be 2MB at 6MB offset start=0x00600000 length=0x00200000 (upper 1/4) . But before proceeding with setting the WP range, one may want to sign the firmware with own vboot keys. The Dasharo build come by default with Google vboot developer keys, so to take advantage of vboot, one should sign the binary before flashing and setting the WP range. Refer to vboot signing . Unfortunately the utilities support only 2 RW partitions for resiging. Otherwise a whole image must be rebuilt. After custo mkeys have been used to sign the ifmrware image and the image has been flashed proceed with enalbing the protection: ./flashrom -p internal --wp-range = 0x00600000,0x00200000 Then proceed with Setting SPI status register protection and Verifying SPI wite protection . At this point you should have your coreboot firmware with vboot well protected and ready to go. Place the jumper in order to prevent any changes to the configuration.","title":"Setting flash protection for vboot"},{"location":"variants/asus_kgpe_d16/test-matrix/","text":"Test matrix - Asus KGPE-A16 About The test matrix is used to determine the scope of tests which the DUT is subjected from before the release of the new binary. Module: Dasharo compatibility No. Supported test suite Test suite ID Supported test cases 1. coreboot base port CBP All 2. SMBIOS DMI DMI001.001, DMI002.001, DMI003.001, DMI004.001 3. coreboot fan control FAN All 4. Custom boot menu key CBK All 5. Debian Stable and Ubuntu LTS support LBT LBT002.001 6. Network boot PXE All 7. USB detection USB All 8. USB booting UBB All 9. Platform suspend and resume SUSP All 10. Flash write protection HWP All 11. Display ports and LCD support DSP DSP004.001, DSP004.002 Module: Dasharo security No. Supported test suite Test suite ID Supported test cases 1. TPM Support TPM TPM001.001 2. Verified Boot support VBO VBO001.001, VBO002.001, VBO003.001 Module: Dasharo performance No. Supported test suite Test suite ID Supported test cases 1. coreboot bring up time measurement CBMEM All","title":"Test matrix"},{"location":"variants/asus_kgpe_d16/test-matrix/#test-matrix-asus-kgpe-a16","text":"","title":"Test matrix - Asus KGPE-A16"},{"location":"variants/asus_kgpe_d16/test-matrix/#about","text":"The test matrix is used to determine the scope of tests which the DUT is subjected from before the release of the new binary.","title":"About"},{"location":"variants/asus_kgpe_d16/test-matrix/#module-dasharo-compatibility","text":"No. Supported test suite Test suite ID Supported test cases 1. coreboot base port CBP All 2. SMBIOS DMI DMI001.001, DMI002.001, DMI003.001, DMI004.001 3. coreboot fan control FAN All 4. Custom boot menu key CBK All 5. Debian Stable and Ubuntu LTS support LBT LBT002.001 6. Network boot PXE All 7. USB detection USB All 8. USB booting UBB All 9. Platform suspend and resume SUSP All 10. Flash write protection HWP All 11. Display ports and LCD support DSP DSP004.001, DSP004.002","title":"Module: Dasharo compatibility"},{"location":"variants/asus_kgpe_d16/test-matrix/#module-dasharo-security","text":"No. Supported test suite Test suite ID Supported test cases 1. TPM Support TPM TPM001.001 2. Verified Boot support VBO VBO001.001, VBO002.001, VBO003.001","title":"Module: Dasharo security"},{"location":"variants/asus_kgpe_d16/test-matrix/#module-dasharo-performance","text":"No. Supported test suite Test suite ID Supported test cases 1. coreboot bring up time measurement CBMEM All","title":"Module: Dasharo performance"},{"location":"variants/asus_kgpe_d16/tpm-mboot/","text":"TPM measured boot Since the Dasharo release v0.3.0 for KGPE-D16 TPM and measured boot are enabled by default. The firmware comes with 2 variants for all 3 flash size targets: vboot and TPM 1.2 measured boot for 2MB, 8MB and 16MB flash vboot and TPM 2.0 measured boot for 2MB, 8MB and 16MB flash TPM support 3mdeb office validates the following setups: KGPE-D16 8MB flash with ASUS TPM-L R2.0 (Infineon SLB9665 TT2.0). KGPE-D16 16MB flash with ASUS TPM 1.2 Rev 1.02h (Infineon SLB9635 TT1.2). Both chips are supported by coreboot. For the time being the platforms will be tested with ASUS modules until OSHW lpnTPM with open-source TPM firmware is ready. Measured boot behaviour It is also possible to have builds without vboot: TPM 1.2 measured boot only (no vboot) for 2MB, 8MB and 16MB flash TPM 2.0 measured boot only (no vboot) for 2MB, 8MB and 16MB flash These targets are for cases where only the bootblock is intended to be locked to form Static Root of Trust for Measurement. For details how to lock flash depending on the firmware variant (with or without vboot) refer to SPI hardware write protection . Note the targets without vboot do not need to have any division into read-only and read-write partitions. Everything can be contained in a single COREBOOT flashmap region like in a standard coreboot build to have the largest free space for big payloads like heads. The variants without vboot have enabled measured boot with an additional option to initialize the TPM in bootblock in order to send the measurements directly to TPM in bootblock and other early stages. Otherwise the TPM measurements are cached in memory and sent to TPM PCRs late in ramstage during TPM setup. The downside of this approach is that the memory could be corrupted in the meantime and the measurements could be faked before they are migrated to the TPM. If you check the boot logs either on serial port on via cbmem utility you should see: coreboot-asus_kgpe-d16_v0.2.0-15-g521dec6dff Wed Dec 15 11 :43:34 UTC 2021 bootblock starting ( log level: 8 ) ... CPU INIT detected 00000000 Found TPM SLB9665 TT 2 .0 by Infineon tlcl_send_startup: Startup return code is 0 TPM: Write digests cached in TCPA log to PCR TPM: Write digest for FMAP: FMAP into PCR 2 tlcl_extend: response is 0 TPM: Write digest for FMAP: COREBOOT CBFS: bootblock into PCR 2 tlcl_extend: response is 0 TPM: Write digest for FMAP: COREBOOT CBFS: cmos.default into PCR 3 tlcl_extend: response is 0 TPM: setup succeeded CBFS: Found 'fallback/romstage' @0x80 size 0x2d688 in mcache @0x0004962c FMAP: area COREBOOT found @ 200 ( 8388096 bytes ) TPM: Extending digest for FMAP: COREBOOT CBFS: fallback/romstage into PCR 2 tlcl_extend: response is 0 TPM: Digest of FMAP: COREBOOT CBFS: fallback/romstage to PCR 2 measured BS: bootblock times ( exec / console ) : total ( unknown ) / 62 ms When vboot is enabled and the verstage is being located, the bootblock measures itself and the verstage, but the measurements are sent to the TPM PCRs not in bootblock, but in verstage: coreboot-asus_kgpe-d16_v0.2.0-15-g521dec6dff Wed Dec 15 11 :43:34 UTC 2021 bootblock starting ( log level: 8 ) ... CPU INIT detected 00000000 VBOOT: Loading verstage. CBFS: Found 'fallback/verstage' @0x8c300 size 0xd848 in mcache @0x0004c8fc FMAP: area COREBOOT found @ 609000 ( 2060288 bytes ) TPM: Digest of FMAP: COREBOOT CBFS: fallback/verstage to PCR 2 logged coreboot-asus_kgpe-d16_v0.2.0-15-g521dec6dff Wed Dec 15 11 :43:34 UTC 2021 verstage starting ( log level: 8 ) ... VBNV: CMOS invalid, restoring from flash FMAP: area RW_NVRAM found @ 80000 ( 16384 bytes ) spi_init: SPI base fec10000 Manufacturer: ef SF: Detected ef 4017 with sector size 0x1000, total 0x800000 VBNV: Restore from flash failed Found TPM SLB9665 TT 2 .0 by Infineon tlcl_send_startup: Startup return code is 0 TPM: Write digests cached in TCPA log to PCR TPM: Write digest for FMAP: FMAP into PCR 2 tlcl_extend: response is 0 TPM: Write digest for FMAP: COREBOOT CBFS: bootblock into PCR 2 tlcl_extend: response is 0 TPM: Write digest for FMAP: COREBOOT CBFS: cmos.default into PCR 3 tlcl_extend: response is 0 TPM: Write digest for FMAP: COREBOOT CBFS: fallback/verstage into PCR 2 tlcl_extend: response is 0 TPM: Write digest for FMAP: COREBOOT CBFS: cmos_layout.bin into PCR 2 tlcl_extend: response is 0 TPM: setup succeeded","title":"TPM measured boot"},{"location":"variants/asus_kgpe_d16/tpm-mboot/#tpm-measured-boot","text":"Since the Dasharo release v0.3.0 for KGPE-D16 TPM and measured boot are enabled by default. The firmware comes with 2 variants for all 3 flash size targets: vboot and TPM 1.2 measured boot for 2MB, 8MB and 16MB flash vboot and TPM 2.0 measured boot for 2MB, 8MB and 16MB flash","title":"TPM measured boot"},{"location":"variants/asus_kgpe_d16/tpm-mboot/#tpm-support","text":"3mdeb office validates the following setups: KGPE-D16 8MB flash with ASUS TPM-L R2.0 (Infineon SLB9665 TT2.0). KGPE-D16 16MB flash with ASUS TPM 1.2 Rev 1.02h (Infineon SLB9635 TT1.2). Both chips are supported by coreboot. For the time being the platforms will be tested with ASUS modules until OSHW lpnTPM with open-source TPM firmware is ready.","title":"TPM support"},{"location":"variants/asus_kgpe_d16/tpm-mboot/#measured-boot-behaviour","text":"It is also possible to have builds without vboot: TPM 1.2 measured boot only (no vboot) for 2MB, 8MB and 16MB flash TPM 2.0 measured boot only (no vboot) for 2MB, 8MB and 16MB flash These targets are for cases where only the bootblock is intended to be locked to form Static Root of Trust for Measurement. For details how to lock flash depending on the firmware variant (with or without vboot) refer to SPI hardware write protection . Note the targets without vboot do not need to have any division into read-only and read-write partitions. Everything can be contained in a single COREBOOT flashmap region like in a standard coreboot build to have the largest free space for big payloads like heads. The variants without vboot have enabled measured boot with an additional option to initialize the TPM in bootblock in order to send the measurements directly to TPM in bootblock and other early stages. Otherwise the TPM measurements are cached in memory and sent to TPM PCRs late in ramstage during TPM setup. The downside of this approach is that the memory could be corrupted in the meantime and the measurements could be faked before they are migrated to the TPM. If you check the boot logs either on serial port on via cbmem utility you should see: coreboot-asus_kgpe-d16_v0.2.0-15-g521dec6dff Wed Dec 15 11 :43:34 UTC 2021 bootblock starting ( log level: 8 ) ... CPU INIT detected 00000000 Found TPM SLB9665 TT 2 .0 by Infineon tlcl_send_startup: Startup return code is 0 TPM: Write digests cached in TCPA log to PCR TPM: Write digest for FMAP: FMAP into PCR 2 tlcl_extend: response is 0 TPM: Write digest for FMAP: COREBOOT CBFS: bootblock into PCR 2 tlcl_extend: response is 0 TPM: Write digest for FMAP: COREBOOT CBFS: cmos.default into PCR 3 tlcl_extend: response is 0 TPM: setup succeeded CBFS: Found 'fallback/romstage' @0x80 size 0x2d688 in mcache @0x0004962c FMAP: area COREBOOT found @ 200 ( 8388096 bytes ) TPM: Extending digest for FMAP: COREBOOT CBFS: fallback/romstage into PCR 2 tlcl_extend: response is 0 TPM: Digest of FMAP: COREBOOT CBFS: fallback/romstage to PCR 2 measured BS: bootblock times ( exec / console ) : total ( unknown ) / 62 ms When vboot is enabled and the verstage is being located, the bootblock measures itself and the verstage, but the measurements are sent to the TPM PCRs not in bootblock, but in verstage: coreboot-asus_kgpe-d16_v0.2.0-15-g521dec6dff Wed Dec 15 11 :43:34 UTC 2021 bootblock starting ( log level: 8 ) ... CPU INIT detected 00000000 VBOOT: Loading verstage. CBFS: Found 'fallback/verstage' @0x8c300 size 0xd848 in mcache @0x0004c8fc FMAP: area COREBOOT found @ 609000 ( 2060288 bytes ) TPM: Digest of FMAP: COREBOOT CBFS: fallback/verstage to PCR 2 logged coreboot-asus_kgpe-d16_v0.2.0-15-g521dec6dff Wed Dec 15 11 :43:34 UTC 2021 verstage starting ( log level: 8 ) ... VBNV: CMOS invalid, restoring from flash FMAP: area RW_NVRAM found @ 80000 ( 16384 bytes ) spi_init: SPI base fec10000 Manufacturer: ef SF: Detected ef 4017 with sector size 0x1000, total 0x800000 VBNV: Restore from flash failed Found TPM SLB9665 TT 2 .0 by Infineon tlcl_send_startup: Startup return code is 0 TPM: Write digests cached in TCPA log to PCR TPM: Write digest for FMAP: FMAP into PCR 2 tlcl_extend: response is 0 TPM: Write digest for FMAP: COREBOOT CBFS: bootblock into PCR 2 tlcl_extend: response is 0 TPM: Write digest for FMAP: COREBOOT CBFS: cmos.default into PCR 3 tlcl_extend: response is 0 TPM: Write digest for FMAP: COREBOOT CBFS: fallback/verstage into PCR 2 tlcl_extend: response is 0 TPM: Write digest for FMAP: COREBOOT CBFS: cmos_layout.bin into PCR 2 tlcl_extend: response is 0 TPM: setup succeeded","title":"Measured boot behaviour"},{"location":"variants/dell_optiplex/building-manual/","text":"Dell OptiPlex 7010/9010 Dasharo - building manual Building coreboot To build coreboot image, follow the steps below: Clone the coreboot repository: git clone https://review.coreboot.org/coreboot.git Get the submodules: cd coreboot git submodule update --init --recursive --checkout Checkout Dasharo branch for OptiPlex 7010/9010 (replace vX.Y.Z with valid version): git remote add dasharo https://github.com/dasharo/coreboot.git git fetch dasharo git checkout dell_optiplex_9010_vX.Y.Z Start docker container: docker run --rm -it \\ -v $PWD :/home/coreboot/coreboot \\ -w /home/coreboot/coreboot \\ coreboot/coreboot-sdk:0ad5fbd48d /bin/bash Inside of the container, configure and start the build process: ( docker ) make distclean ( docker ) cp configs/config.dell_optiplex_9010_sff .config ( docker ) make olddefconfig ( docker ) make or simply: ( docker ) make distclean && cp configs/config.dell_optiplex_9010_sff .config && make olddefconfig && make This will produce a debug binary placed in build/coreboot.rom . To flash coreboot refer to initial deployment manual .","title":"Building manual"},{"location":"variants/dell_optiplex/building-manual/#dell-optiplex-70109010-dasharo-building-manual","text":"","title":"Dell OptiPlex 7010/9010 Dasharo - building manual"},{"location":"variants/dell_optiplex/building-manual/#building-coreboot","text":"To build coreboot image, follow the steps below: Clone the coreboot repository: git clone https://review.coreboot.org/coreboot.git Get the submodules: cd coreboot git submodule update --init --recursive --checkout Checkout Dasharo branch for OptiPlex 7010/9010 (replace vX.Y.Z with valid version): git remote add dasharo https://github.com/dasharo/coreboot.git git fetch dasharo git checkout dell_optiplex_9010_vX.Y.Z Start docker container: docker run --rm -it \\ -v $PWD :/home/coreboot/coreboot \\ -w /home/coreboot/coreboot \\ coreboot/coreboot-sdk:0ad5fbd48d /bin/bash Inside of the container, configure and start the build process: ( docker ) make distclean ( docker ) cp configs/config.dell_optiplex_9010_sff .config ( docker ) make olddefconfig ( docker ) make or simply: ( docker ) make distclean && cp configs/config.dell_optiplex_9010_sff .config && make olddefconfig && make This will produce a debug binary placed in build/coreboot.rom . To flash coreboot refer to initial deployment manual .","title":"Building coreboot"},{"location":"variants/dell_optiplex/firmware-update/","text":"Firmware update Following documentation describe process of Dasharo open-source firmware update. OS booting For simplicity we using network boot netboot.xyz from USB . Boot system from USB: From section Tools choose Utilities (64-bit) Then from section netboot.xyz tools choose Kernel cmdline params You should see prompt Enter kernel cmdline parameters Type: iomem=relaxed and Enter Use Esc to get back to netboot.xyz main menu From section Distributions choose Live CDs , then Debian , Debian Live 11 (bullseye) and Debian 11 (Core) NOTE : If trustworthiness of that solution is in question please note netboot.xyz can be self-hosted . Get Dasharo Download the Dell OptiPlex 7010/9010 Dasharo from release section or build from source .","title":"Firmware update"},{"location":"variants/dell_optiplex/firmware-update/#firmware-update","text":"Following documentation describe process of Dasharo open-source firmware update.","title":"Firmware update"},{"location":"variants/dell_optiplex/firmware-update/#os-booting","text":"For simplicity we using network boot netboot.xyz from USB . Boot system from USB: From section Tools choose Utilities (64-bit) Then from section netboot.xyz tools choose Kernel cmdline params You should see prompt Enter kernel cmdline parameters Type: iomem=relaxed and Enter Use Esc to get back to netboot.xyz main menu From section Distributions choose Live CDs , then Debian , Debian Live 11 (bullseye) and Debian 11 (Core) NOTE : If trustworthiness of that solution is in question please note netboot.xyz can be self-hosted .","title":"OS booting"},{"location":"variants/dell_optiplex/firmware-update/#get-dasharo","text":"Download the Dell OptiPlex 7010/9010 Dasharo from release section or build from source .","title":"Get Dasharo"},{"location":"variants/dell_optiplex/hardware-matrix/","text":"Hardware configuration matrix The tables below contain information about current components of the testing environment for Dell OptiPlex workstations available in 3mdeb testing laboratory. OptiPlex 7010 Component Description CPU Intel Core iTBD CPU Cooler GPU N/A RAM TBD HDD TBD SSD TBD Flash memory TBD Network Local network wired connection Attached devices 1. TBD USB stick Power Supply TBD Power Control 1. Sonoff TBD Remote Testing Environment 1. RTE TBD OptiPlex 9010 Component Description CPU Intel Core iTBD CPU Cooler GPU N/A RAM TBD HDD TBD SSD TBD Flash memory TBD Network Local network wired connection Attached devices 1. TBD USB stick Power Supply TBD Power Control 1. Sonoff Web Server Remote Testing Environment 1. RTE v1.0.0 (firmware v0.5.3 ) connected via RS232","title":"Hardware configuration matrix"},{"location":"variants/dell_optiplex/hardware-matrix/#hardware-configuration-matrix","text":"The tables below contain information about current components of the testing environment for Dell OptiPlex workstations available in 3mdeb testing laboratory.","title":"Hardware configuration matrix"},{"location":"variants/dell_optiplex/hardware-matrix/#optiplex-7010","text":"Component Description CPU Intel Core iTBD CPU Cooler GPU N/A RAM TBD HDD TBD SSD TBD Flash memory TBD Network Local network wired connection Attached devices 1. TBD USB stick Power Supply TBD Power Control 1. Sonoff TBD Remote Testing Environment 1. RTE TBD","title":"OptiPlex 7010"},{"location":"variants/dell_optiplex/hardware-matrix/#optiplex-9010","text":"Component Description CPU Intel Core iTBD CPU Cooler GPU N/A RAM TBD HDD TBD SSD TBD Flash memory TBD Network Local network wired connection Attached devices 1. TBD USB stick Power Supply TBD Power Control 1. Sonoff Web Server Remote Testing Environment 1. RTE v1.0.0 (firmware v0.5.3 ) connected via RS232","title":"OptiPlex 9010"},{"location":"variants/dell_optiplex/initial-deployment/","text":"Initial deployment Following documentation describe process of replacing original BIOS/UEFI firmware with Dasharo open-source firmware. Following procedure is supported for following models Vendor Model Dell OptiPlex 7010 SFF Dell OptiPlex 7010 DT Dell OptiPlex 9010 SFF Hardware preparation Flash descriptor security override To perform any SPI NOR flash operations in presence of ME we have to put it in flash descriptor security override mode. Please follow below steps: Open the case by lifting the handle on the case up. Lift the whole top cover and take it off. Now, it is time to release the disk dock. Lift up the handle of the CD/DVD drive bay. Pull the CD/DVD drive bay to the CPU fan side. Move the blue disk dock handle to the CPU fan side. The screw should be at the more giant hole now. Lift up the whole dock to remove it. When the dock is removed, the service mode jumper should be visible. Place the jumper in the place marked by the red rectangle. It should look like this. Power on the machine. You should see a warning that the service jumper is active. Press F1 to proceed and boot to your Linux system. OS booting For simplicity we using network boot netboot.xyz from USB . Boot system from USB: From section Tools choose Utilities (64-bit) Then from section netboot.xyz tools choose Kernel cmdline params You should see prompt Enter kernel cmdline parameters Type: iomem=relaxed and Enter Use Esc to get back to netboot.xyz main menu From section Distributions choose Live CDs , then Debian , Debian Live 11 (bullseye) and Debian 11 (Core) NOTE : If trustworthiness of that solution is in question please note netboot.xyz can be self-hosted . Flashrom installation Install flashrom v1.1 or newer with your distribution's package manager if you don't have it installed yet. If your distro doesn't provide flashrom or provides an outdated one, you can build it yourself using this instruction . Or compile recent version of flashrom: sudo apt install libpci-dev libftdi-dev libusb-1.0-0-dev git clone https://github.com/flashrom/flashrom.git cd flashrom sudo make install BIOS backup It is always good idea to backup original BIOS of your hardware, before switching to open-source firmware. Read content of SPI NOR flash: sudo flashrom -p internal -r bios_backup_`date +%Y%m%d`.bin flashrom v1.2-551-gf47ff31 on Linux 5.10.0-9-amd64 (x86_64) flashrom is free software, get the source code at https://flashrom.org Using clock_gettime for delay loops (clk_id: 1, resolution: 1ns). Found chipset \"Intel Q77\". Enabling flash write... SPI Configuration is locked down. The Flash Descriptor Override Strap-Pin is set. Restrictions implied by the Master Section of the flash descriptor are NOT in effect. Please note that Protected Range (PR) restrictions still apply. Enabling hardware sequencing due to multiple flash chips detected. OK. Found Programmer flash chip \"Opaque flash chip\" (12288 kB, Programmer-specific) mapped at physical address 0x0000000000000000. Reading flash... done. If you will face any issues please refer to troubleshooting section . Get Dasharo Download the Dell OptiPlex 7010/9010 Dasharo from release section or build from source . Non-redistributable blobs Some Dell OptiPlex 7010/9010 SFF binary blobs have unknown license or questionable redistributability. To avoid potential issues we transfer non-redistributable components from your original BIOS to Dell OptiPlex 9010 Dasharo binary using fwdeploy . wget https://raw.githubusercontent.com/Dasharo/fwdeploy/main/run.sh chmod +x run.sh ./run.sh <bios_backup> <dasharo_optiplex_9010_firmware> After that procedure <dasharo_optiplex_9010_firmware> can be flashed on your Dell OptiPlex 7010/9010 SFF. NOTE: We gathering information about non-redistributable firmware components in Dasharo fwdeploy project. Feel free to report SHA256 of blobs from your platform. Flashing Following procedure will flash Dell OptiPlex 7010/9010 SFF Dasharo firmware to your machine SPI NOR flash. Flash it on you Dell OptiPlex machine: sudo flashrom -p internal --ifd -i bios -i me -w <dasharo_optiplex_9010_firmware> for example: sudo flashrom -p internal --ifd -i bios -i me -w /tmp/dasharo_workstation_v0.2_rc3.rom flashrom v1.2-551-gf47ff31 on Linux 5.10.0-9-amd64 (x86_64) flashrom is free software, get the source code at https://flashrom.org Using clock_gettime for delay loops (clk_id: 1, resolution: 1ns). Found chipset \"Intel Q77\". Enabling flash write... SPI Configuration is locked down. The Flash Descriptor Override Strap-Pin is set. Restrictions implied by the Master Section of the flash descriptor are NOT in effect. Please note that Protected Range (PR) restrictions still apply. Enabling hardware sequencing due to multiple flash chips detected. OK. Found Programmer flash chip \"Opaque flash chip\" (12288 kB, Programmer-specific) mapped at physical address 0x0000000000000000. Reading ich descriptor... done. Using regions: \"me\", \"bios\". Reading old flash chip contents... done. Erasing and writing flash chip... Erase/write done. Verifying flash... VERIFIED. If you get a warning: WARNING! You may be running flashrom on an unsupported laptop. And programmer initialization failed, run command: flashrom -p internal:laptop=this_is_not_a_laptop -w /tmp/dasharo_workstation_v0.2_rc3.rom --ifd -i bios -i me If you have placed the jumper correctly, you should see the following message in flashrom's output: The Flash Descriptor Override Strap-Pin is set. Restrictions implied by the Master Section of the flash descriptor are NOT in effect. Please note that Protected Range (PR) restrictions still apply. A newer version of flashrom may not display the warning about unsupported chipset as it already may be marked as tested. Our team has verified that the flashrom updates firmware reliably on this chipset. If you will face any issues please refer to troubleshooting section . Verification If everything went well (flashrom has verified the flash content), Shut down machine, move the jumper to the original place Power on the machine. After rebooting, you should see the Dasharo Workstation logo when booting. When the logo appears, you may press Esc to select the boot device if you want to reboot from another source. Troubleshooting If you do not see the logo after few seconds, something probably went wrong, or a bug was hit. If the LED on the power button shines white, that means the platform booted correctly. If the power button LED constantly shines in orange color, that means you have hit an error. The LED will start blinking soon. If you see the logo and after that system does not starts (black screen), please take the following steps: Put a bootable USB stick to the USB port. Restart the computer using the power button. Press the Esc key to enter a boot menu. Choose a USB drive from the list. Re-install the operating system. Common deployment problems you can find in FAQ . Ubuntu installation Ubuntu legacy installers have problems with graphical setup mode. When you see an error: graphics initialization failed Error setting up gfxboot boot:_ You need a workaround to proceed with the installation. To boot the installer, simply type live-install and press ENTER . It will boot to Ubuntu Live, and the installer will be automatically launched. Version affected: Dasharo Workstation v0.1. If you see blinking yellow LED and black screen after reboot: 1. Unplug the power supply cable 2. Wait for 30s 3. Plug power supply again (machine should start automatically) Bug reporting If you encountered an error or bug, please fill report in Dasharo Issues repo .","title":"Initial deployment"},{"location":"variants/dell_optiplex/initial-deployment/#initial-deployment","text":"Following documentation describe process of replacing original BIOS/UEFI firmware with Dasharo open-source firmware. Following procedure is supported for following models Vendor Model Dell OptiPlex 7010 SFF Dell OptiPlex 7010 DT Dell OptiPlex 9010 SFF","title":"Initial deployment"},{"location":"variants/dell_optiplex/initial-deployment/#hardware-preparation","text":"","title":"Hardware preparation"},{"location":"variants/dell_optiplex/initial-deployment/#os-booting","text":"For simplicity we using network boot netboot.xyz from USB . Boot system from USB: From section Tools choose Utilities (64-bit) Then from section netboot.xyz tools choose Kernel cmdline params You should see prompt Enter kernel cmdline parameters Type: iomem=relaxed and Enter Use Esc to get back to netboot.xyz main menu From section Distributions choose Live CDs , then Debian , Debian Live 11 (bullseye) and Debian 11 (Core) NOTE : If trustworthiness of that solution is in question please note netboot.xyz can be self-hosted .","title":"OS booting"},{"location":"variants/dell_optiplex/initial-deployment/#flashrom-installation","text":"Install flashrom v1.1 or newer with your distribution's package manager if you don't have it installed yet. If your distro doesn't provide flashrom or provides an outdated one, you can build it yourself using this instruction . Or compile recent version of flashrom: sudo apt install libpci-dev libftdi-dev libusb-1.0-0-dev git clone https://github.com/flashrom/flashrom.git cd flashrom sudo make install","title":"Flashrom installation"},{"location":"variants/dell_optiplex/initial-deployment/#bios-backup","text":"It is always good idea to backup original BIOS of your hardware, before switching to open-source firmware. Read content of SPI NOR flash: sudo flashrom -p internal -r bios_backup_`date +%Y%m%d`.bin flashrom v1.2-551-gf47ff31 on Linux 5.10.0-9-amd64 (x86_64) flashrom is free software, get the source code at https://flashrom.org Using clock_gettime for delay loops (clk_id: 1, resolution: 1ns). Found chipset \"Intel Q77\". Enabling flash write... SPI Configuration is locked down. The Flash Descriptor Override Strap-Pin is set. Restrictions implied by the Master Section of the flash descriptor are NOT in effect. Please note that Protected Range (PR) restrictions still apply. Enabling hardware sequencing due to multiple flash chips detected. OK. Found Programmer flash chip \"Opaque flash chip\" (12288 kB, Programmer-specific) mapped at physical address 0x0000000000000000. Reading flash... done. If you will face any issues please refer to troubleshooting section .","title":"BIOS backup"},{"location":"variants/dell_optiplex/initial-deployment/#get-dasharo","text":"Download the Dell OptiPlex 7010/9010 Dasharo from release section or build from source .","title":"Get Dasharo"},{"location":"variants/dell_optiplex/initial-deployment/#non-redistributable-blobs","text":"Some Dell OptiPlex 7010/9010 SFF binary blobs have unknown license or questionable redistributability. To avoid potential issues we transfer non-redistributable components from your original BIOS to Dell OptiPlex 9010 Dasharo binary using fwdeploy . wget https://raw.githubusercontent.com/Dasharo/fwdeploy/main/run.sh chmod +x run.sh ./run.sh <bios_backup> <dasharo_optiplex_9010_firmware> After that procedure <dasharo_optiplex_9010_firmware> can be flashed on your Dell OptiPlex 7010/9010 SFF. NOTE: We gathering information about non-redistributable firmware components in Dasharo fwdeploy project. Feel free to report SHA256 of blobs from your platform.","title":"Non-redistributable blobs"},{"location":"variants/dell_optiplex/initial-deployment/#flashing","text":"Following procedure will flash Dell OptiPlex 7010/9010 SFF Dasharo firmware to your machine SPI NOR flash. Flash it on you Dell OptiPlex machine: sudo flashrom -p internal --ifd -i bios -i me -w <dasharo_optiplex_9010_firmware> for example: sudo flashrom -p internal --ifd -i bios -i me -w /tmp/dasharo_workstation_v0.2_rc3.rom flashrom v1.2-551-gf47ff31 on Linux 5.10.0-9-amd64 (x86_64) flashrom is free software, get the source code at https://flashrom.org Using clock_gettime for delay loops (clk_id: 1, resolution: 1ns). Found chipset \"Intel Q77\". Enabling flash write... SPI Configuration is locked down. The Flash Descriptor Override Strap-Pin is set. Restrictions implied by the Master Section of the flash descriptor are NOT in effect. Please note that Protected Range (PR) restrictions still apply. Enabling hardware sequencing due to multiple flash chips detected. OK. Found Programmer flash chip \"Opaque flash chip\" (12288 kB, Programmer-specific) mapped at physical address 0x0000000000000000. Reading ich descriptor... done. Using regions: \"me\", \"bios\". Reading old flash chip contents... done. Erasing and writing flash chip... Erase/write done. Verifying flash... VERIFIED. If you get a warning: WARNING! You may be running flashrom on an unsupported laptop. And programmer initialization failed, run command: flashrom -p internal:laptop=this_is_not_a_laptop -w /tmp/dasharo_workstation_v0.2_rc3.rom --ifd -i bios -i me If you have placed the jumper correctly, you should see the following message in flashrom's output: The Flash Descriptor Override Strap-Pin is set. Restrictions implied by the Master Section of the flash descriptor are NOT in effect. Please note that Protected Range (PR) restrictions still apply. A newer version of flashrom may not display the warning about unsupported chipset as it already may be marked as tested. Our team has verified that the flashrom updates firmware reliably on this chipset. If you will face any issues please refer to troubleshooting section .","title":"Flashing"},{"location":"variants/dell_optiplex/initial-deployment/#verification","text":"If everything went well (flashrom has verified the flash content), Shut down machine, move the jumper to the original place Power on the machine. After rebooting, you should see the Dasharo Workstation logo when booting. When the logo appears, you may press Esc to select the boot device if you want to reboot from another source.","title":"Verification"},{"location":"variants/dell_optiplex/initial-deployment/#troubleshooting","text":"If you do not see the logo after few seconds, something probably went wrong, or a bug was hit. If the LED on the power button shines white, that means the platform booted correctly. If the power button LED constantly shines in orange color, that means you have hit an error. The LED will start blinking soon. If you see the logo and after that system does not starts (black screen), please take the following steps: Put a bootable USB stick to the USB port. Restart the computer using the power button. Press the Esc key to enter a boot menu. Choose a USB drive from the list. Re-install the operating system. Common deployment problems you can find in FAQ .","title":"Troubleshooting"},{"location":"variants/dell_optiplex/overview/","text":"Overview Releases - list all releases. Initial deployment - describe initial Dasharo deployment methods for Dell OptiPlex 7010/9010 SFF. Firmware update - explain supported Dasharo open-source firmware update methods. Recovery - gathers information how to recover from potential failure. History Dell OptiPlex and coreboot - a story about porting cursed hardware (part 1) Dell OptiPlex and coreboot - a story about porting cursed hardware (part 2) Dasharo for Dell OptiPlex 7010 / 9010","title":"Overview"},{"location":"variants/dell_optiplex/overview/#overview","text":"Releases - list all releases. Initial deployment - describe initial Dasharo deployment methods for Dell OptiPlex 7010/9010 SFF. Firmware update - explain supported Dasharo open-source firmware update methods. Recovery - gathers information how to recover from potential failure.","title":"Overview"},{"location":"variants/dell_optiplex/overview/#history","text":"Dell OptiPlex and coreboot - a story about porting cursed hardware (part 1) Dell OptiPlex and coreboot - a story about porting cursed hardware (part 2) Dasharo for Dell OptiPlex 7010 / 9010","title":"History"},{"location":"variants/dell_optiplex/recovery/","text":"Recovery Prequisitions To proceed with recovery .rom file with backup vendor firmware will be neccesary eg. backup.rom . Backup file should be generated before making any changes in device flash chip according to documentation in BIOS backup section. Set jumper according to hardware preparation Install flashrom using flashrom installation guide Internal flashing Flash firmware on you Dell OptiPlex machine using below command: sudo flashrom -p internal -i me -w <optiplex_firmware> for example: sudo flashrom -p internal -i me -w /tmp/backup.rom output: flashrom v1.2-551-gf47ff31 on Linux 5 .10.0-9-amd64 ( x86_64 ) flashrom is free software, get the source code at https://flashrom.org Using clock_gettime for delay loops ( clk_id: 1 , resolution: 1ns ) . Found chipset \"Intel Q77\" . Enabling flash write... SPI Configuration is locked down. The Flash Descriptor Override Strap-Pin is set. Restrictions implied by the Master Section of the flash descriptor are NOT in effect. Please note that Protected Range ( PR ) restrictions still apply. Enabling hardware sequencing due to multiple flash chips detected. OK. Found Programmer flash chip \"Opaque flash chip\" ( 12288 kB, Programmer-specific ) mapped at physical address 0x0000000000000000. Reading ich descriptor... done . Using regions: \"me\" , \"bios\" . Reading old flash chip contents... done . Erasing and writing flash chip... Erase/write done . Verifying flash... VERIFIED. If you get a warning: WARNING! You may be running flashrom on an unsupported laptop. And programmer initialization failed, run command: flashrom -p internal:laptop = this_is_not_a_laptop -w /tmp/backup.rom -i me If you have placed the jumper correctly, you should see the following message in flashrom's output: The Flash Descriptor Override Strap-Pin is set. Restrictions implied by the Master Section of the flash descriptor are NOT in effect. Please note that Protected Range ( PR ) restrictions still apply. A newer version of flashrom may not display the warning about unsupported chipset as it already may be marked as tested. Our team has verified that the flashrom updates firmware reliably on this chipset. If you will face any issues please refer to troubleshooting section .","title":"Recovery"},{"location":"variants/dell_optiplex/recovery/#recovery","text":"","title":"Recovery"},{"location":"variants/dell_optiplex/recovery/#prequisitions","text":"To proceed with recovery .rom file with backup vendor firmware will be neccesary eg. backup.rom . Backup file should be generated before making any changes in device flash chip according to documentation in BIOS backup section. Set jumper according to hardware preparation Install flashrom using flashrom installation guide","title":"Prequisitions"},{"location":"variants/dell_optiplex/recovery/#internal-flashing","text":"Flash firmware on you Dell OptiPlex machine using below command: sudo flashrom -p internal -i me -w <optiplex_firmware> for example: sudo flashrom -p internal -i me -w /tmp/backup.rom output: flashrom v1.2-551-gf47ff31 on Linux 5 .10.0-9-amd64 ( x86_64 ) flashrom is free software, get the source code at https://flashrom.org Using clock_gettime for delay loops ( clk_id: 1 , resolution: 1ns ) . Found chipset \"Intel Q77\" . Enabling flash write... SPI Configuration is locked down. The Flash Descriptor Override Strap-Pin is set. Restrictions implied by the Master Section of the flash descriptor are NOT in effect. Please note that Protected Range ( PR ) restrictions still apply. Enabling hardware sequencing due to multiple flash chips detected. OK. Found Programmer flash chip \"Opaque flash chip\" ( 12288 kB, Programmer-specific ) mapped at physical address 0x0000000000000000. Reading ich descriptor... done . Using regions: \"me\" , \"bios\" . Reading old flash chip contents... done . Erasing and writing flash chip... Erase/write done . Verifying flash... VERIFIED. If you get a warning: WARNING! You may be running flashrom on an unsupported laptop. And programmer initialization failed, run command: flashrom -p internal:laptop = this_is_not_a_laptop -w /tmp/backup.rom -i me If you have placed the jumper correctly, you should see the following message in flashrom's output: The Flash Descriptor Override Strap-Pin is set. Restrictions implied by the Master Section of the flash descriptor are NOT in effect. Please note that Protected Range ( PR ) restrictions still apply. A newer version of flashrom may not display the warning about unsupported chipset as it already may be marked as tested. Our team has verified that the flashrom updates firmware reliably on this chipset. If you will face any issues please refer to troubleshooting section .","title":"Internal flashing"},{"location":"variants/dell_optiplex/releases/","text":"Dell OptiPlex Dasharo Release Notes Following Release Notes describe status of Open Source Firmware development for Dell OptiPlex 7010 SFF, DT and Dell OptiPlex 9010 SFF. For details about our release process please read Dasharo Standard Release Process . Subscribe to Dell OptiPlex 7010/9010 Dasharo Release Newsletter Unreleased Software BOM: coreboot 4.12-1428-g20cf396c96 (with additional commits for custom platform config and CI YAML) EDKII Added UEFI boot support Discrete graphics support SATA password TCG OPAL password configurable boot order configurable boot options UEFI iPXE for EFI network boot support UEFI Secure Boot Internal UEFI Shell One-time boot feature Removed Legacy boot support Binaries v0.1.0 - 2021-01-18 Added Dell OptiPlex 7010 and 9010 platforms supported Dasharo bootsplash Legacy boot support USB, SATA, and NVMe boot supported Measured boot with TPM 1.2 ME neutralized with me_cleaner Environmental Controller fan control Environmental Controller firmware update support (the DELL EC firmware is included in the image, the firmware update process is open-source, but the EC firmware code is in binary form only and we have no control over what is executed on EC) Integrated graphics initialization with open-source libgfxinit library for both VGA and 2 DP ports Onboard serial port supported Binaries Dell OptiPlex 7010/9010 Dasharo SHA256 SHA256.sig All in one zip SBOM (Software Bill of Materials) coreboot 4.12-1428-g20cf396c96 (with additional commits for custom platform config and CI YAML) SeaBIOS 1.13.0","title":"Releases"},{"location":"variants/dell_optiplex/releases/#dell-optiplex-dasharo-release-notes","text":"Following Release Notes describe status of Open Source Firmware development for Dell OptiPlex 7010 SFF, DT and Dell OptiPlex 9010 SFF. For details about our release process please read Dasharo Standard Release Process . Subscribe to Dell OptiPlex 7010/9010 Dasharo Release Newsletter","title":"Dell OptiPlex Dasharo Release Notes"},{"location":"variants/dell_optiplex/releases/#unreleased","text":"Software BOM: coreboot 4.12-1428-g20cf396c96 (with additional commits for custom platform config and CI YAML) EDKII","title":"Unreleased"},{"location":"variants/dell_optiplex/releases/#v010-2021-01-18","text":"","title":"v0.1.0 - 2021-01-18"},{"location":"variants/msi_z690/building-manual/","text":"Dasharo compatible with MSI PRO Z690-A WIFI DDR4 - building manual Intro This documents describes the procedure for compiling Dasharo firmware compatible with MSI PRO Z690-A WIFI DDR4. Requirements Ubuntu 20.04/21.04 as a host OS was tested Internet connection Docker installed follow Install Docker Engine on Ubuntu follow Post-installation steps for Linux Git, wget, unzip installed sudo apt install git unzip wget UEFIExtract installed this tool is used in the build.sh script to extract CPU microcode from the original MSI firmware sudo apt install wget wget https://github.com/LongSoft/UEFITool/releases/download/A59/UEFIExtract_NE_A59_linux_x86_64.zip unzip UEFIExtract_NE_A59_linux_x86_64.zip sudo cp ./UEFIExtract /usr/local/bin Procedure Obtain Dasharo source code for MSI PRO Z690-A WIFI DDR4: Replace the REVISION with one of the: msi_ms7d25/release for the latest released version msi_ms7d25_vVERSION (e.g. msi_ms7d25_v0.1.0 ) for the given release git clone https://github.com/Dasharo/coreboot.git -b REVISION Navigate to the source code directory and start the build process: cd coreboot ./build.sh build The resulting Dasharo firmware image will be placed at build/coreboot.rom .","title":"Building manual"},{"location":"variants/msi_z690/building-manual/#dasharo-compatible-with-msi-pro-z690-a-wifi-ddr4-building-manual","text":"","title":"Dasharo compatible with MSI PRO Z690-A WIFI DDR4 - building manual"},{"location":"variants/msi_z690/building-manual/#intro","text":"This documents describes the procedure for compiling Dasharo firmware compatible with MSI PRO Z690-A WIFI DDR4.","title":"Intro"},{"location":"variants/msi_z690/building-manual/#requirements","text":"Ubuntu 20.04/21.04 as a host OS was tested Internet connection Docker installed follow Install Docker Engine on Ubuntu follow Post-installation steps for Linux Git, wget, unzip installed sudo apt install git unzip wget UEFIExtract installed this tool is used in the build.sh script to extract CPU microcode from the original MSI firmware sudo apt install wget wget https://github.com/LongSoft/UEFITool/releases/download/A59/UEFIExtract_NE_A59_linux_x86_64.zip unzip UEFIExtract_NE_A59_linux_x86_64.zip sudo cp ./UEFIExtract /usr/local/bin","title":"Requirements"},{"location":"variants/msi_z690/building-manual/#procedure","text":"Obtain Dasharo source code for MSI PRO Z690-A WIFI DDR4: Replace the REVISION with one of the: msi_ms7d25/release for the latest released version msi_ms7d25_vVERSION (e.g. msi_ms7d25_v0.1.0 ) for the given release git clone https://github.com/Dasharo/coreboot.git -b REVISION Navigate to the source code directory and start the build process: cd coreboot ./build.sh build The resulting Dasharo firmware image will be placed at build/coreboot.rom .","title":"Procedure"},{"location":"variants/msi_z690/community-test-results/","text":"Community test results - MSI Z690-A WIFI DDR4 About The following document contains information about additional tests which were carried out on the MSI Z690-A WIFI DDR4 platform with Dasharo firmware by community members. The following list is created based on the information from the community - people which are currently using the platform with Dasharo firmware. This document contains three main sections: - Contributing in which we are describing preferred of reporting the results. - Testing method in which we are describing our preferred testing method. - Hardware Compatible List in which in a labelled manner we show all tests carried out by the community. Contributing Feel free to perform different tests and report your results via email or submit a Pull Request to Dasharo documentation repository or by using Dasharo issues repository . Testing method Platform testing might be carried out on the basis of Dasharo Test Specification . If you prefer another mechanism for checking any functionality or check any mechanism that we did not include in the documentation - describe it in the test report issue. Community test results No. Description Link to description Notes 1.","title":"Community Test Results"},{"location":"variants/msi_z690/community-test-results/#community-test-results-msi-z690-a-wifi-ddr4","text":"","title":"Community test results - MSI Z690-A WIFI DDR4"},{"location":"variants/msi_z690/community-test-results/#about","text":"The following document contains information about additional tests which were carried out on the MSI Z690-A WIFI DDR4 platform with Dasharo firmware by community members. The following list is created based on the information from the community - people which are currently using the platform with Dasharo firmware. This document contains three main sections: - Contributing in which we are describing preferred of reporting the results. - Testing method in which we are describing our preferred testing method. - Hardware Compatible List in which in a labelled manner we show all tests carried out by the community.","title":"About"},{"location":"variants/msi_z690/community-test-results/#contributing","text":"Feel free to perform different tests and report your results via email or submit a Pull Request to Dasharo documentation repository or by using Dasharo issues repository .","title":"Contributing"},{"location":"variants/msi_z690/community-test-results/#testing-method","text":"Platform testing might be carried out on the basis of Dasharo Test Specification . If you prefer another mechanism for checking any functionality or check any mechanism that we did not include in the documentation - describe it in the test report issue.","title":"Testing method"},{"location":"variants/msi_z690/community-test-results/#community-test-results","text":"No. Description Link to description Notes 1.","title":"Community test results"},{"location":"variants/msi_z690/cpu-hcl/","text":"CPU HCL Contributing Feel free to test different processors and report your results via email or submit a Pull Request to Dasharo documentation repository or by using Dasharo issues repository . HCL list CPU Hardware Compatibility List presents the CPUs tested and verified to work with Dasharo by community. The following list does not include CPU which is tested and verfied in 3mdeb laboratory - this information might be found in Hardware Matrix documentation. Legend: * Processor name - the full name of processor including vendor, brand and CPU number. * Core name - CPU core codename. * CPU base speed - based CPU speed. * CPU boost spped - boosted CPU speed. * Wattage - declared by producer processor wattage. * GPU - information about embedded graphics processing unit. * Results - link to measurement results. Information about processor name, core name and speed might be read from OS (Linux systems - command lscpu , Windows systems - System information menu). Rest of the information might be read from CPU package or documentation. Processor name Core name CPU base speed CPU boost speed Wattage GPU Results Intel Core i9-12900K Alder Lake 3.2 GHz 5.3 GHz 125 UHDGraphics710 Qubes HCL reports","title":"CPU Compatibility"},{"location":"variants/msi_z690/cpu-hcl/#cpu-hcl","text":"","title":"CPU HCL"},{"location":"variants/msi_z690/cpu-hcl/#contributing","text":"Feel free to test different processors and report your results via email or submit a Pull Request to Dasharo documentation repository or by using Dasharo issues repository .","title":"Contributing"},{"location":"variants/msi_z690/cpu-hcl/#hcl-list","text":"CPU Hardware Compatibility List presents the CPUs tested and verified to work with Dasharo by community. The following list does not include CPU which is tested and verfied in 3mdeb laboratory - this information might be found in Hardware Matrix documentation. Legend: * Processor name - the full name of processor including vendor, brand and CPU number. * Core name - CPU core codename. * CPU base speed - based CPU speed. * CPU boost spped - boosted CPU speed. * Wattage - declared by producer processor wattage. * GPU - information about embedded graphics processing unit. * Results - link to measurement results. Information about processor name, core name and speed might be read from OS (Linux systems - command lscpu , Windows systems - System information menu). Rest of the information might be read from CPU package or documentation. Processor name Core name CPU base speed CPU boost speed Wattage GPU Results Intel Core i9-12900K Alder Lake 3.2 GHz 5.3 GHz 125 UHDGraphics710 Qubes HCL reports","title":"HCL list"},{"location":"variants/msi_z690/development/","text":"Dasharo compatible with MSI PRO Z690-A WIFI DDR4 - development Intro This document gather various notes and documentation useful for development of Dasharo compatible with the MSI PRO Z690-A WIFI DDR4 platform. Hardware connection Requirements peripherals listed in the Hardware Configuration Matrix RTE Sonoff S20 Smart Plug with custom firmware Serial debug Attach the jumpers in J16 header to eanble header J18 according to the table below: Jumper position (TX) Jumper position (RX) EXT + COM EXT + COM Connect signals from the J18 header to serial receiver: RTE Msi Z690 J18 pin 1 (GND) JBD1 pin 1 (pin closer to JBAT1) J18 pin 2 (RX) JBD1 pin 2 (pin further from JBAT1) Pins on JBD1 are not described in the documentation. They have been discovered experimentally. Pay attention to the connections. Please also note that this is uni-directional communication. We can gether logs from booting, but we cannot provide input to the platform at the same time. SPI For external flashing, connect RTE with motherboard according to the table below: RTE SPI header Msi Z690 J7 pin 1 (Vcc) JTPM1 pin 1 (SPI Power) J7 pin 2 (GND) JTPM1 pin 7 (GND) J7 pin 3 (CS) Pin soldered to SPI chip pin 1 (CS), see image below J7 pin 4 (SCLK) JTPM1 pin 6 (SPI Clock) J7 pin 5 (MISO) JTPM1 pin 3 (MISO) J7 pin 6 (MOSI) JTPM1 pin 4 (MOSI) Example connection: Power control Power buttons control Connect 12V/4A power supply to RTE J13 connector to power on RTE Connect power control pins from mainboard to RTE according to the table below: JFP1 is located in the corner of the mainbaord, near SATA interface ports RTE Msi Z690 J11 pin 9 JFP1 pin 6 (PWR_ON) J11 pin 8 JFP1 pin 7 (RST) J15 pin 1 (GND) JFP1 pin 5 (GND) Power supply control Connect SeaSonic FOCUS Plus Platinum power supply unit to the mains via Sonoff S20 Smart Plug . To power control via RTE, Sonoff smart plug","title":"Development"},{"location":"variants/msi_z690/development/#dasharo-compatible-with-msi-pro-z690-a-wifi-ddr4-development","text":"","title":"Dasharo compatible with MSI PRO Z690-A WIFI DDR4 - development"},{"location":"variants/msi_z690/development/#intro","text":"This document gather various notes and documentation useful for development of Dasharo compatible with the MSI PRO Z690-A WIFI DDR4 platform.","title":"Intro"},{"location":"variants/msi_z690/development/#hardware-connection","text":"","title":"Hardware connection"},{"location":"variants/msi_z690/faq/","text":"FAQ Will this work on my MSI PRO Z690-A WIFI DDR5 or MSI PRO Z690-A DDR5 ? Not yet. The build is configured for the DDR4 only. It might be extended with the DDR5 variant in the future. Do not try that . Will this work on my MSI PRO Z690-A DDR4 ? Although we do not own that one and cannot give promises without testing, we believe that it should work the same as the MSI PRO Z690-A WIFI DDR4 . This is almost the same board, just with no WiFi card. Can I safely try this on my board? If you are afraid of bricking the board and have no means of recovering from failed installation , we do not recommend trying it out until at least the v1.0.0 is released. Recovery process is not suitable for inexperienced users right now. We will be trying to make it easier, and if that happens, we may change our recommendation here. Can I destroy my hardware by installing this firmware? We give no warranty, although it is highly unlikely, provided that you use the supported board model and follow the installation manual . In the worst scenario, you might \"brick\" the board, rendering it unbootable. It can be fixed by following the recovery procedure . How can I know if the board is \"bricked\"? In such a case, you would get stuck with black screen on the display. There will be no beeping sounds from the buzzer as well. The only way to get some information on what's going on in that state is to use the Serial header to read out error information. What can be the reason of board \"bricking\"? The most common reason would be the fact that you DDR memory modules are not initializad properly. The other reason might be improper or interrupted installation. Please make sure to follow the Installation Manual correctly. How can I \"unbrick\" my board? Please follow the recovery procedure . Which CPUs are supported? We can say the \"supported\" one is the one we have tested. It is the Intel Core i5-12600K and you can check that in the Hardware Configuration Matrix . In practice, any Alder Lake-S Processor with integrated GPU (which means no F-series). F-series is not supported because currently the PCIe ports are not initialized, so there is no other way to get video output (or any other signs of system being functional, unless you have a way to get logging from the Serial header ) to know that it is actually working. 12900KS is rather unknown at the moment, because it was released later and may require more recent microcode. Which DDR4 memory modules are supported? We can say the \"supported\" one is the one we have tested. It is the Kingston Fury Beast KF436C17BBK4/32 part populated in all 4 slots, and you can check that in the Hardware Configuration Matrix . At that point it was not extensively tested either, though. Once the memory initialization goes through (we can see firmware logo on the display, and then boot into OS), we assume it is good enough at this stage. No other memory modules or combination in slots were verified so far. This is on the roadmap for future releases. You should not refer to the Memory Compatibility of the mainboard. It does not need to apply here due the difference on what memory initialization routines are used in the original MSI firmware and the ones in Dasharo firmware (provied by the Intel FSP ). What is the memory profile? Currently, Dasharo firmware picks the highest standard SPD Profile, no support for XMP ones. This means that on the Kingston modules it is actually working at 2400 MHz, but it is expected to work all the way to 3200 MHz. Why my GPU doesn't work on MSI PRO Z690-A DDR4 ? Due to the fact, that there's no possibility to insert all available GPU drivers into the firmware, the solution in the form of the Option ROM is in use. Option ROMs are the drivers flashed in the GPUs non-volatile memory. These types of drivers can be divided into Legacy Option ROMs and EFI Option ROMs . Legacy Option ROMs are only supported on legacy BIOS, such as SeaBIOS. Legacy BIOS checks the availability of Option ROM and if its signature matches, it executes its entry point. This option ROM initializes the graphics. The only way to support Option ROM in UEFI is through CSM, which we do not have implemented. EFI Option ROMs are nothing more than EFI drivers which have the same form as the UEFI files (PE format). UEFI firmware scans the Option ROM space of the graphics card and if it finds a potential EFI Option ROM with PE signature, it executes the file. This option ROM initializes the graphics. Considering the above, the firmware might have a problem with initializing older graphics cards - UEFI standard appeared about 15 years ago. The problem might also be caused by an enabled Secure boot - because there is no certainty that EFI Option ROM is signed correctly.","title":"FAQ"},{"location":"variants/msi_z690/faq/#faq","text":"","title":"FAQ"},{"location":"variants/msi_z690/faq/#will-this-work-on-my-msi-pro-z690-a-wifi-ddr5-or-msi-pro-z690-a-ddr5","text":"Not yet. The build is configured for the DDR4 only. It might be extended with the DDR5 variant in the future. Do not try that .","title":"Will this work on my MSI PRO Z690-A WIFI DDR5 or MSI PRO Z690-A DDR5 ?"},{"location":"variants/msi_z690/faq/#will-this-work-on-my-msi-pro-z690-a-ddr4","text":"Although we do not own that one and cannot give promises without testing, we believe that it should work the same as the MSI PRO Z690-A WIFI DDR4 . This is almost the same board, just with no WiFi card.","title":"Will this work on my MSI PRO Z690-A DDR4 ?"},{"location":"variants/msi_z690/faq/#can-i-safely-try-this-on-my-board","text":"If you are afraid of bricking the board and have no means of recovering from failed installation , we do not recommend trying it out until at least the v1.0.0 is released. Recovery process is not suitable for inexperienced users right now. We will be trying to make it easier, and if that happens, we may change our recommendation here.","title":"Can I safely try this on my board?"},{"location":"variants/msi_z690/faq/#can-i-destroy-my-hardware-by-installing-this-firmware","text":"We give no warranty, although it is highly unlikely, provided that you use the supported board model and follow the installation manual . In the worst scenario, you might \"brick\" the board, rendering it unbootable. It can be fixed by following the recovery procedure .","title":"Can I destroy my hardware by installing this firmware?"},{"location":"variants/msi_z690/faq/#how-can-i-know-if-the-board-is-bricked","text":"In such a case, you would get stuck with black screen on the display. There will be no beeping sounds from the buzzer as well. The only way to get some information on what's going on in that state is to use the Serial header to read out error information.","title":"How can I know if the board is \"bricked\"?"},{"location":"variants/msi_z690/faq/#what-can-be-the-reason-of-board-bricking","text":"The most common reason would be the fact that you DDR memory modules are not initializad properly. The other reason might be improper or interrupted installation. Please make sure to follow the Installation Manual correctly.","title":"What can be the reason of board \"bricking\"?"},{"location":"variants/msi_z690/faq/#how-can-i-unbrick-my-board","text":"Please follow the recovery procedure .","title":"How can I \"unbrick\" my board?"},{"location":"variants/msi_z690/faq/#which-cpus-are-supported","text":"We can say the \"supported\" one is the one we have tested. It is the Intel Core i5-12600K and you can check that in the Hardware Configuration Matrix . In practice, any Alder Lake-S Processor with integrated GPU (which means no F-series). F-series is not supported because currently the PCIe ports are not initialized, so there is no other way to get video output (or any other signs of system being functional, unless you have a way to get logging from the Serial header ) to know that it is actually working. 12900KS is rather unknown at the moment, because it was released later and may require more recent microcode.","title":"Which CPUs are supported?"},{"location":"variants/msi_z690/faq/#which-ddr4-memory-modules-are-supported","text":"We can say the \"supported\" one is the one we have tested. It is the Kingston Fury Beast KF436C17BBK4/32 part populated in all 4 slots, and you can check that in the Hardware Configuration Matrix . At that point it was not extensively tested either, though. Once the memory initialization goes through (we can see firmware logo on the display, and then boot into OS), we assume it is good enough at this stage. No other memory modules or combination in slots were verified so far. This is on the roadmap for future releases. You should not refer to the Memory Compatibility of the mainboard. It does not need to apply here due the difference on what memory initialization routines are used in the original MSI firmware and the ones in Dasharo firmware (provied by the Intel FSP ).","title":"Which DDR4 memory modules are supported?"},{"location":"variants/msi_z690/faq/#what-is-the-memory-profile","text":"Currently, Dasharo firmware picks the highest standard SPD Profile, no support for XMP ones. This means that on the Kingston modules it is actually working at 2400 MHz, but it is expected to work all the way to 3200 MHz.","title":"What is the memory profile?"},{"location":"variants/msi_z690/faq/#why-my-gpu-doesnt-work-on-msi-pro-z690-a-ddr4","text":"Due to the fact, that there's no possibility to insert all available GPU drivers into the firmware, the solution in the form of the Option ROM is in use. Option ROMs are the drivers flashed in the GPUs non-volatile memory. These types of drivers can be divided into Legacy Option ROMs and EFI Option ROMs . Legacy Option ROMs are only supported on legacy BIOS, such as SeaBIOS. Legacy BIOS checks the availability of Option ROM and if its signature matches, it executes its entry point. This option ROM initializes the graphics. The only way to support Option ROM in UEFI is through CSM, which we do not have implemented. EFI Option ROMs are nothing more than EFI drivers which have the same form as the UEFI files (PE format). UEFI firmware scans the Option ROM space of the graphics card and if it finds a potential EFI Option ROM with PE signature, it executes the file. This option ROM initializes the graphics. Considering the above, the firmware might have a problem with initializing older graphics cards - UEFI standard appeared about 15 years ago. The problem might also be caused by an enabled Secure boot - because there is no certainty that EFI Option ROM is signed correctly.","title":"Why my GPU doesn't work on MSI PRO Z690-A DDR4 ?"},{"location":"variants/msi_z690/gpu-hcl/","text":"GPU HCL Contributing Feel free to test different graphics cards and report your results via email or submit a Pull Request to Dasharo documentation repository or by using Dasharo issues repository . HCL list GPU Hardware Compatibility List presents the GPUs tested and verified to work with Dasharo by community. The following list does not include GPU which is tested and verfied in 3mdeb laboratory - this information might be found in Hardware Matrix documentation. Legend: * GPU name - the full name of GPU including vendor and model name. * Memory size - total amount of GPU memory declared by vendor. * Memory type - GPU's type of memory. * Bandwith - GPU's bandwith. * PCI-E Architecture - declared by producer generation of PCI-E architecture. * Multi-Graphics Technology - information about support for Multi-Graphics Technology. Information about GPU might be read from GPU package or documentation. GPU name Memory size Memory type Bandwidth PCI-E Architecture Multi-Graphics Technology Results Nvidia GeForce GTX 1060 3072 MB GDDR5 x16 Gen3 1 Qubes HCL reports","title":"GPU Compatibility"},{"location":"variants/msi_z690/gpu-hcl/#gpu-hcl","text":"","title":"GPU HCL"},{"location":"variants/msi_z690/gpu-hcl/#contributing","text":"Feel free to test different graphics cards and report your results via email or submit a Pull Request to Dasharo documentation repository or by using Dasharo issues repository .","title":"Contributing"},{"location":"variants/msi_z690/gpu-hcl/#hcl-list","text":"GPU Hardware Compatibility List presents the GPUs tested and verified to work with Dasharo by community. The following list does not include GPU which is tested and verfied in 3mdeb laboratory - this information might be found in Hardware Matrix documentation. Legend: * GPU name - the full name of GPU including vendor and model name. * Memory size - total amount of GPU memory declared by vendor. * Memory type - GPU's type of memory. * Bandwith - GPU's bandwith. * PCI-E Architecture - declared by producer generation of PCI-E architecture. * Multi-Graphics Technology - information about support for Multi-Graphics Technology. Information about GPU might be read from GPU package or documentation. GPU name Memory size Memory type Bandwidth PCI-E Architecture Multi-Graphics Technology Results Nvidia GeForce GTX 1060 3072 MB GDDR5 x16 Gen3 1 Qubes HCL reports","title":"HCL list"},{"location":"variants/msi_z690/hardware-matrix/","text":"Hardware configuration matrix - MSI PRO Z690-A WIFI DDR4 Introduction This document describes the hardware configuration used for validation of the coreboot port on the MSI PRO Z690-A workstation. For additional information, please check the FAQ section . LA1E312159 Component Description CPU Intel Core i5-12600K 3.7 Noctua NH-U12S CPU Cooler RAM Slot 1: Kingston KF436C17BBK4/32 Slot 2: Kingston KF436C17BBK4/32 Slot 3: Kingston KF436C17BBK4/32 Slot 4: Kingston KF436C17BBK4/32 SSD Intel 670p 512 GB M26472-201 NVME Flash memory Macronix MX25U25673G Network Local network wired connection Attached devices 1. SanDisk Ultra Flair USB 3.0 16 GB 2. Kingston DataTraveler 3.1Gen1 16 GB 3. SanDisk Ultra microSD HC I 16 GB 4. Logitech, Inc. Keyboard K120 5. Dell Mouse MS116p 6. 1-port USB Type-C Power Supply SeaSonic FOCUS Plus Platinum LA1E012608 Component Description CPU Intel Core i5-12600K 3.7 Noctua NH-U12S CPU Cooler RAM Slot 1: Kingston KF436C17BBK4/32 Slot 2: Kingston KF436C17BBK4/32 Slot 3: Kingston KF436C17BBK4/32 Slot 4: Kingston KF436C17BBK4/32 SSD Intel 670p 512 GB M26472-201 NVME Flash memory Macronix MX25U25673G Network Local network wired connection Attached devices 1. SanDisk Ultra Flair USB 3.0 16 GB 2. Kingston DataTraveler 3.1Gen1 16 GB 3. SanDisk Ultra microSD HC I 16 GB 4. Logitech, Inc. Keyboard K120 5. Dell Mouse MS116p 6. 1-port USB Type-C Power Supply SeaSonic FOCUS Plus Platinum Power Control Sonoff Remote Testing Environment RTE v1.1.0","title":"Hardware Configuration Matrix"},{"location":"variants/msi_z690/hardware-matrix/#hardware-configuration-matrix-msi-pro-z690-a-wifi-ddr4","text":"","title":"Hardware configuration matrix - MSI PRO Z690-A WIFI DDR4"},{"location":"variants/msi_z690/hardware-matrix/#introduction","text":"This document describes the hardware configuration used for validation of the coreboot port on the MSI PRO Z690-A workstation. For additional information, please check the FAQ section .","title":"Introduction"},{"location":"variants/msi_z690/hardware-matrix/#la1e312159","text":"Component Description CPU Intel Core i5-12600K 3.7 Noctua NH-U12S CPU Cooler RAM Slot 1: Kingston KF436C17BBK4/32 Slot 2: Kingston KF436C17BBK4/32 Slot 3: Kingston KF436C17BBK4/32 Slot 4: Kingston KF436C17BBK4/32 SSD Intel 670p 512 GB M26472-201 NVME Flash memory Macronix MX25U25673G Network Local network wired connection Attached devices 1. SanDisk Ultra Flair USB 3.0 16 GB 2. Kingston DataTraveler 3.1Gen1 16 GB 3. SanDisk Ultra microSD HC I 16 GB 4. Logitech, Inc. Keyboard K120 5. Dell Mouse MS116p 6. 1-port USB Type-C Power Supply SeaSonic FOCUS Plus Platinum","title":"LA1E312159"},{"location":"variants/msi_z690/hardware-matrix/#la1e012608","text":"Component Description CPU Intel Core i5-12600K 3.7 Noctua NH-U12S CPU Cooler RAM Slot 1: Kingston KF436C17BBK4/32 Slot 2: Kingston KF436C17BBK4/32 Slot 3: Kingston KF436C17BBK4/32 Slot 4: Kingston KF436C17BBK4/32 SSD Intel 670p 512 GB M26472-201 NVME Flash memory Macronix MX25U25673G Network Local network wired connection Attached devices 1. SanDisk Ultra Flair USB 3.0 16 GB 2. Kingston DataTraveler 3.1Gen1 16 GB 3. SanDisk Ultra microSD HC I 16 GB 4. Logitech, Inc. Keyboard K120 5. Dell Mouse MS116p 6. 1-port USB Type-C Power Supply SeaSonic FOCUS Plus Platinum Power Control Sonoff Remote Testing Environment RTE v1.1.0","title":"LA1E012608"},{"location":"variants/msi_z690/installation-manual/","text":"Dasharo compatible with MSI PRO Z690-A WIFI DDR4 - installation manual Flashing coreboot can be done from Linux using flashrom with the internal programmer. This document describes the process of building, installing and running flashrom on Ubuntu 21.04. Build flashrom Currently, the latest flashrom release lacks support for Alder Lake S internal flashing. Because of this, we need to build flashrom from 3mdeb fork . The procedure is based on Ubuntu 21.04 desktop amd64 ISO burned on the USB stick. Boot the Ubuntu live image and select Try ubuntu option. Open a terminal and proceed with commands below. Install build dependencies: sudo apt-get install git build-essential pkg-config libpci-dev udev Obtain source code: git clone https://github.com/Dasharo/flashrom.git -b dasharo-release cd flashrom Build and install flashrom: sudo make install Flashing All flash operations require UEFI Secure Boot to be disabled. You may download the binary using scp (need to install openssh-server package) or wget command. The binaries can be found on the release page . Reading flash contents Always prepare a backup of the current firmware image. To read the original firmware from the flash and save it to a file ( dump.rom ), execute the following command: sudo flashrom -p internal -r dump.rom IMPORTANT! You will need a second USB storage to keep the dumped firmware backup or alternatively upload it to some cloud or network drive (Ubuntu live has a Firefox browser installed). Ubuntu live image is volatile and has no persistent storage. All changes made in live image will be lost after reboot. Migrating SMBIOS unique data To migrate the SMBIOS system UUID and board serial number follow the Linux instructions below before attempting to flash the binary. The procedure is supported on Dasharo version v1.0.0 and later and requires cbfstool built from coreboot tree. Follow the Building Manual using v1.0.0 version or newer and then: echo -n ` sudo dmidecode -s system-uuid ` > system_uuid.txt echo -n ` sudo dmidecode -s baseboard-serial-number ` > serial_number.txt # assuming in coreboot root directory ./build/cbfstool build/coreboot.rom add \\ -f serial_number.txt -n serial_number -t raw -r FW_MAIN_A ./build/cbfstool build/coreboot.rom add \\ -f serial_number.txt -n serial_number -t raw -r FW_MAIN_B ./build/cbfstool build/coreboot.rom add \\ -f serial_number.txt -n serial_number -t raw -r COREBOOT ./build/cbfstool build/coreboot.rom add \\ -f system_uuid.txt -n system_uuid -t raw -r FW_MAIN_A ./build/cbfstool build/coreboot.rom add \\ -f system_uuid.txt -n system_uuid -t raw -r FW_MAIN_B ./build/cbfstool build/coreboot.rom add \\ -f system_uuid.txt -n system_uuid -t raw -r COREBOOT One may use msi_ms7d25_v1.0.0.rom (or newer) binary directly and simply build the cbfstool only from coreboot repository: git clone https://github.com/Dasharo/coreboot -b msi_ms7d25/release cd coreboot make -C util/cbfstool echo -n ` sudo dmidecode -s system-uuid ` > system_uuid.txt echo -n ` sudo dmidecode -s baseboard-serial-number ` > serial_number.txt # assuming in coreboot root directory ./util/cbfstool/cbfstool /path/to/msi_ms7d25_v1.0.0.rom add \\ -f serial_number.txt -n serial_number -t raw -r FW_MAIN_A ./util/cbfstool/cbfstool /path/to/msi_ms7d25_v1.0.0.rom add \\ -f serial_number.txt -n serial_number -t raw -r FW_MAIN_B ./util/cbfstool/cbfstool /path/to/msi_ms7d25_v1.0.0.rom add \\ -f serial_number.txt -n serial_number -t raw -r COREBOOT ./util/cbfstool/cbfstool /path/to/msi_ms7d25_v1.0.0.rom add \\ -f system_uuid.txt -n system_uuid -t raw -r FW_MAIN_A ./util/cbfstool/cbfstool /path/to/msi_ms7d25_v1.0.0.rom add \\ -f system_uuid.txt -n system_uuid -t raw -r FW_MAIN_B ./util/cbfstool/cbfstool /path/to/msi_ms7d25_v1.0.0.rom add \\ -f system_uuid.txt -n system_uuid -t raw -r COREBOOT Note you will need to resign the binary after adding the SMBIOS data. Please check Vboot documentation how to resign the data. It is machine owner's responsibility to generate and use own keys during updates. Flashing Dasharo To flash Dasharo on the platform, execute the following command: Replace the VERSION in firmware file name with the version you want to flash. For example: msi_ms7d25_v0.1.0.rom . sudo flashrom -p internal -w msi_ms7d25_vVERSION.rom --ifd -i bios After the command succeeds, invoke poweroff or click the power off in the GUI to shutdown the board. Press ENTER when prompted on the screen. Power on the board back. Reboot will not work as some memory settings are preserved after reboot and FSP fails to train the memory. Poweroff is required. Flashing back vendor firmware sudo flashrom -p internal -w dump.rom --ifd -i bios NOTE: Dasharo version v0.1.0 will not have network connection. Use a different USB storage or an USB to Ethernet/USB WiFi adapter to move the binary to the live system.","title":"Installation manual"},{"location":"variants/msi_z690/installation-manual/#dasharo-compatible-with-msi-pro-z690-a-wifi-ddr4-installation-manual","text":"Flashing coreboot can be done from Linux using flashrom with the internal programmer. This document describes the process of building, installing and running flashrom on Ubuntu 21.04.","title":"Dasharo compatible with MSI PRO Z690-A WIFI DDR4 - installation manual"},{"location":"variants/msi_z690/installation-manual/#build-flashrom","text":"Currently, the latest flashrom release lacks support for Alder Lake S internal flashing. Because of this, we need to build flashrom from 3mdeb fork . The procedure is based on Ubuntu 21.04 desktop amd64 ISO burned on the USB stick. Boot the Ubuntu live image and select Try ubuntu option. Open a terminal and proceed with commands below. Install build dependencies: sudo apt-get install git build-essential pkg-config libpci-dev udev Obtain source code: git clone https://github.com/Dasharo/flashrom.git -b dasharo-release cd flashrom Build and install flashrom: sudo make install","title":"Build flashrom"},{"location":"variants/msi_z690/installation-manual/#flashing","text":"All flash operations require UEFI Secure Boot to be disabled. You may download the binary using scp (need to install openssh-server package) or wget command. The binaries can be found on the release page .","title":"Flashing"},{"location":"variants/msi_z690/memory-hcl/","text":"Memory HCL Contributing Feel free to test different modules and report your results via email or submit a Pull Request to Dasharo documentation repository . Be sure to include information about the memory: If using Linux use sudo dmidecode -t memory . If using Windows attach screenshots from CPU-Z for example. Part Number of the Memory Modules: If you have physical access to the modules, the Part Number is printed on a sticker. You may send a photo where the sticker is legible if you can't identify it. The Part Number is also usually available as data on the SPD and retrievable via Software (see point 2 below), but sometimes it is possible than it doesn't match the Part Number on the sticker, or that it wasn't programmed onto the SPD at all. Dump of SPD Profiles: If using Linux use sudo dmidecode -t memory . Additionally you may provide SPD data binaries (example for Ubuntu for all 4 DIMMs): sudo apt-get install i2c-tools decode-dimms > dimms.log cat /sys/bus/i2c/drivers/ee1004/0-0050/eeprom > dimm0_spd.bin cat /sys/bus/i2c/drivers/ee1004/0-0051/eeprom > dimm1_spd.bin cat /sys/bus/i2c/drivers/ee1004/0-0052/eeprom > dimm2_spd.bin cat /sys/bus/i2c/drivers/ee1004/0-0053/eeprom > dimm3_spd.bin If using Windows attach screenshots from CPU-Z SPD Tab. If multiple modules are installed, make sure to open multiple CPU-Z instances and have each one cover a different Slot via the Memory Slot Selection drop down list. DDR4 DIMMs include a SPD ROM which can have up to 4 SPD Profiles. Each SPD Profile contains data for a combination of Speed (MHz), Timings and Voltage that the module is factory rated to run at. These SPD Profiles can be considered either JEDEC standard or XMP (Overclocking). Currently, Dasharo only loads the JEDEC standard profile and ignores the XMP ones. Currently memory profile is not selectable via BIOS setup. This feature is planned for future releases. HCL list Memory hardware Compatibility List present the DIMM modules tested and verified to work with Dasharo in 3mdeb laboratory. Memory Modules are tested in 1, 2 and 4 modules configurations. These follow the DIMM population procedures as stated in the Board Manual: 1 module in DIMMA2 Slot (Single Channel), 2 by adding another module in DIMMB2 (Dual Channel), and 4 by populating all 4 slots. Testing is defined as passing firmware POST and booting an OS, since what is being tested is that the Intel FSP (Firmware Support Package) component is initializing the Memory Modules. We don't stress test them for stability. Each SPD Profile is tested, so each Memory Module can have from 1 to 4 entries. You may also check out Intel memory validation results page and see the results for DDR4 UDIMM testing. Maximum ratings for Alder Lake S CPUs is also available in the CPU datasheet . Legend: Configuration 1/2/4 - means given memory module was tested in 1, 2 and 4 DIMMs populated configuration, \u2714 means successfully tested, \u2716 means platform did not boot with Dasharo, e.g. \u2714/\u2714/\u2714 means all configurations work, - means not tested Size: DIMM capacity in GB SPD profile: can be one of JEDEC(Standard) / XMP Profile #1 / XMP Profile #2. Profile data: Type/speed: for example DDR4-2400 means DDR4 module clocked at max 2400MHz for given profile Timings: for example CL17-17-17 means CAS Latency 17, tRCD 17, tRP 17 (numbers expressed in clock cycles) for given memory profile Voltage: memory voltage in Volts for given memory profile NOTE: some XMP profiles may have lower speeds than other ones, but also have smaller CAS latency. Also the memory frequency configured in the memory controller and reported by DMI/SMBIOS may be slightly lower than advertised in the module specifications. This can vary based on the board design, CPU and many other factors. DIMM vendor Part Number Size SPD profile Configuration 1/2/4 Kingston KF436C17BBK4/32 8GB JEDEC: DDR4-2400 CL17-17-17 1.2V \u2714/\u2714/\u2714 Kingston KF436C17BBK4/32 8GB XMP profile #1: DDR4-3600 CL17-21-21 1.35V -/-/\u2714 Kingston KF436C17BBK4/32 8GB XMP profile #2: DDR4-3000 CL15-17-17 1.35V -/-/\u2714","title":"Memory Compatibility"},{"location":"variants/msi_z690/memory-hcl/#memory-hcl","text":"","title":"Memory HCL"},{"location":"variants/msi_z690/memory-hcl/#contributing","text":"Feel free to test different modules and report your results via email or submit a Pull Request to Dasharo documentation repository . Be sure to include information about the memory: If using Linux use sudo dmidecode -t memory . If using Windows attach screenshots from CPU-Z for example. Part Number of the Memory Modules: If you have physical access to the modules, the Part Number is printed on a sticker. You may send a photo where the sticker is legible if you can't identify it. The Part Number is also usually available as data on the SPD and retrievable via Software (see point 2 below), but sometimes it is possible than it doesn't match the Part Number on the sticker, or that it wasn't programmed onto the SPD at all. Dump of SPD Profiles: If using Linux use sudo dmidecode -t memory . Additionally you may provide SPD data binaries (example for Ubuntu for all 4 DIMMs): sudo apt-get install i2c-tools decode-dimms > dimms.log cat /sys/bus/i2c/drivers/ee1004/0-0050/eeprom > dimm0_spd.bin cat /sys/bus/i2c/drivers/ee1004/0-0051/eeprom > dimm1_spd.bin cat /sys/bus/i2c/drivers/ee1004/0-0052/eeprom > dimm2_spd.bin cat /sys/bus/i2c/drivers/ee1004/0-0053/eeprom > dimm3_spd.bin If using Windows attach screenshots from CPU-Z SPD Tab. If multiple modules are installed, make sure to open multiple CPU-Z instances and have each one cover a different Slot via the Memory Slot Selection drop down list. DDR4 DIMMs include a SPD ROM which can have up to 4 SPD Profiles. Each SPD Profile contains data for a combination of Speed (MHz), Timings and Voltage that the module is factory rated to run at. These SPD Profiles can be considered either JEDEC standard or XMP (Overclocking). Currently, Dasharo only loads the JEDEC standard profile and ignores the XMP ones. Currently memory profile is not selectable via BIOS setup. This feature is planned for future releases.","title":"Contributing"},{"location":"variants/msi_z690/memory-hcl/#hcl-list","text":"Memory hardware Compatibility List present the DIMM modules tested and verified to work with Dasharo in 3mdeb laboratory. Memory Modules are tested in 1, 2 and 4 modules configurations. These follow the DIMM population procedures as stated in the Board Manual: 1 module in DIMMA2 Slot (Single Channel), 2 by adding another module in DIMMB2 (Dual Channel), and 4 by populating all 4 slots. Testing is defined as passing firmware POST and booting an OS, since what is being tested is that the Intel FSP (Firmware Support Package) component is initializing the Memory Modules. We don't stress test them for stability. Each SPD Profile is tested, so each Memory Module can have from 1 to 4 entries. You may also check out Intel memory validation results page and see the results for DDR4 UDIMM testing. Maximum ratings for Alder Lake S CPUs is also available in the CPU datasheet . Legend: Configuration 1/2/4 - means given memory module was tested in 1, 2 and 4 DIMMs populated configuration, \u2714 means successfully tested, \u2716 means platform did not boot with Dasharo, e.g. \u2714/\u2714/\u2714 means all configurations work, - means not tested Size: DIMM capacity in GB SPD profile: can be one of JEDEC(Standard) / XMP Profile #1 / XMP Profile #2. Profile data: Type/speed: for example DDR4-2400 means DDR4 module clocked at max 2400MHz for given profile Timings: for example CL17-17-17 means CAS Latency 17, tRCD 17, tRP 17 (numbers expressed in clock cycles) for given memory profile Voltage: memory voltage in Volts for given memory profile NOTE: some XMP profiles may have lower speeds than other ones, but also have smaller CAS latency. Also the memory frequency configured in the memory controller and reported by DMI/SMBIOS may be slightly lower than advertised in the module specifications. This can vary based on the board design, CPU and many other factors. DIMM vendor Part Number Size SPD profile Configuration 1/2/4 Kingston KF436C17BBK4/32 8GB JEDEC: DDR4-2400 CL17-17-17 1.2V \u2714/\u2714/\u2714 Kingston KF436C17BBK4/32 8GB XMP profile #1: DDR4-3600 CL17-21-21 1.35V -/-/\u2714 Kingston KF436C17BBK4/32 8GB XMP profile #2: DDR4-3000 CL15-17-17 1.35V -/-/\u2714","title":"HCL list"},{"location":"variants/msi_z690/openness_analysis/","text":"Dasharo Openness Score This document aims to compare the openness of Dasharo firmware and AMI BIOS for MSI PRO Z690-A DDR4 WiFI. There is an ongoing discussion about the methodology of the openness metric. BIOS versions used in the analysis Dasharo v1.0.0 AMI BIOS v1.0 MSI original BIOS from AMI In the case of the AMI BIOS, the entire image should be considered proprietary. There are several parts of the image that have a well-known structure or make use of a public standard. However, to decode these structures, one needs to employ reverse-engineering tools and techniques to know what structures are present. For simplicity we treat UEFI variables as BIOS data. All empty padding regions between FFS and all volume free spaces are treated as unused space. Dasharo BIOS CBFS regions The below table shows only a single FMAP region COREBOOT. There are also two RW vboot partitions containing copies of the same components from COREBOOT region (except the verstage, bootblock and cbfs master header). Note that there are other regions to store non-volatile data like MRC cache, UEFI variables or vboot state backup. Region COREBOOT: File Size (bytes) Is it open-source? cbfs master header 32 \u2714 fallback/romstage 95152 \u2714 cpu_microcode_blob.bin 944144 \u2716 intel_fit 80 \u2714 fallback/ramstage 127231(LZMA) \u2714 config 1378 \u2714 revision 842 \u2714 build_info 142 \u2714 fallback/dsdt.aml 9973 \u2714 vbt.bin 1254 (LZMA) \u2714 (empty) 2596 N/A fspm.bin 720896 \u2716 fsps.bin 290481 (LZ4) \u2716 fallback/postcar 37504 \u2714 fallback/payload 1813047 (LZMA) \u2714 (with exceptions) fallback/verstage 77008 \u2714 (empty) 1055076 N/A bootblock 31808 \u2714 The payload used is Tianocore EDK2 UEFIPayload. In order to support network boot over i225 Ethernet, an i225 EFI driver is included in the payload. The driver is 154064 bytes in size uncompressed (63445 LZMA compressed). The 63445 bytes will be added to closed source pool and removed from the payload size in the calculations. Note that UEFIPayload has support for Option ROM loading, for example to support external graphics card output during POST. It is an additional closed-source code which depends on the hardware configuration and is not included in the calculations. Type Total size (bytes) Percent COREBOOT region 5208644 N/A empty 1057672 N/A code size (open + closed) 4150972 N/A open-source 2132006 51.36% closed-source 2018966 48.64% Region FW_MAIN_A/FW_MAIN_B: File Size (bytes) Is it open-source? fallback/romstage 95152 \u2714 cpu_microcode_blob.bin 944144 \u2716 fallback/ramstage 127231(LZMA) \u2714 config 1378 \u2714 revision 842 \u2714 build_info 142 \u2714 fallback/dsdt.aml 9973 \u2714 (empty) 100 N/A fspm.bin 720896 \u2716 fsps.bin 290481 (LZ4) \u2716 vbt.bin 1254 (LZMA) \u2714 fallback/postcar 37504 \u2714 fallback/payload 1813047 (LZMA) \u2714 (with exceptions) (empty) 1306724 N/A The FW_MAIN_A/FW_MAIN_B regions have been expanded first with CBFStool to show whole empty space for given region. Type Total size (bytes) Percent FW_MAIN_A/B region 5340928 N/A empty 1306824 N/A code size (open + closed) 4042044 N/A open-source 2023078 50.05% closed-source 2018966 49.95% COREBOOT has slightly higher open-source code percentage due to verstage and bootblock not being present in FW_MAIN_A/B regions. Summary for all 3 regions: Whole flash image To get the overall BIOS region and full image percentage of open source code we ignore unused space or FMAP regions which do not have CBFS and are merely data generated during build process or boot process. The BIOS region percentage is calculated as follows: (COREBOOT region open-source size + FW_MAIN_A/B open-source size * 2) * 100 divided by (COREBOOT region code size + FW_MAIN_A/B code size * 2) . Full image code only percentage is calculated as follows: (COREBOOT region open-source size + FW_MAIN_A/B open-source size * 2) * 100 divided by (ME + descriptor + COREBOOT region code size + FW_MAIN_A/B code size * 2) . Region Size (bytes) Open-source percent (bytes) descriptor 0x1000 0% ME 0x3D9000 0% unused hole 0xC26000 N/A BIOS 0x1000000 50.5% Summary 0x2000000 38% Comparison of pure code open-source vs closed-source. This was rather expected result. AMI BIOS region statistics: Type Total size (bytes) Percent BIOS data (UEFI var) 524288 N/A empty 7638472 N/A code size (open + closed) 8614456 N/A open-source 0 0% closed-source 8614456 100% Full BIOS region openness compared to AMI BIOS with data and free space: THat mean Full image openness code only compared to AMI BIOS: Few conclusions from the above charts: Dasharo needs more space for BIOS data, it is mainly dictated by the usage of vboot which needs a significant amount of space for VBLOCKs, GBB and other stuff BIOS data is rather comparable between the firmware distributions, although it must be noted that vboot also generates BIOS data as explained above Dasharo has much less free space than AMI, however it must be noted that Dasharo contains 3! copies of functional firmware, but AMI only a single copy. Without vboot, BIOS region free space would reach over 70%! While BIOS region's Dasharo Openness Score is 50%, when compared with Intel ME and descriptor, the overall Dasharo Openness Score is 38% ME share is different because the size of BIOS code is different on both distributions Summary Image Open-source percent (bytes) AMI BIOS 0% Dasharo 38% Dasharo code takes approximately 4MB of space for a single region + some space for data which is less than 1MB. This reduces the single copy of firmware from 8MB to roughly 4MB compared to AMI BIOS. This is roughly 50% reduction of TCB! More over, given the 50% share in size of open-source code, Dasharo liberates BIOS in 75%! Few conclusions: Although the reduction of TCB is 50% it cannot be seen on the charts due to 3 copies of the firmware in Dasharo image. It also effectively increases the percentage of BIOS code both open and closed source in the full image. More significant differences would be seen with vboot disabled, there would be more free space and even less BIOS code both open and closed","title":"Openness score"},{"location":"variants/msi_z690/openness_analysis/#dasharo-openness-score","text":"This document aims to compare the openness of Dasharo firmware and AMI BIOS for MSI PRO Z690-A DDR4 WiFI. There is an ongoing discussion about the methodology of the openness metric.","title":"Dasharo Openness Score"},{"location":"variants/msi_z690/openness_analysis/#bios-versions-used-in-the-analysis","text":"Dasharo v1.0.0 AMI BIOS v1.0","title":"BIOS versions used in the analysis"},{"location":"variants/msi_z690/openness_analysis/#msi-original-bios-from-ami","text":"In the case of the AMI BIOS, the entire image should be considered proprietary. There are several parts of the image that have a well-known structure or make use of a public standard. However, to decode these structures, one needs to employ reverse-engineering tools and techniques to know what structures are present. For simplicity we treat UEFI variables as BIOS data. All empty padding regions between FFS and all volume free spaces are treated as unused space.","title":"MSI original BIOS from AMI"},{"location":"variants/msi_z690/openness_analysis/#dasharo-bios","text":"","title":"Dasharo BIOS"},{"location":"variants/msi_z690/openness_analysis/#summary","text":"Image Open-source percent (bytes) AMI BIOS 0% Dasharo 38% Dasharo code takes approximately 4MB of space for a single region + some space for data which is less than 1MB. This reduces the single copy of firmware from 8MB to roughly 4MB compared to AMI BIOS. This is roughly 50% reduction of TCB! More over, given the 50% share in size of open-source code, Dasharo liberates BIOS in 75%! Few conclusions: Although the reduction of TCB is 50% it cannot be seen on the charts due to 3 copies of the firmware in Dasharo image. It also effectively increases the percentage of BIOS code both open and closed source in the full image. More significant differences would be seen with vboot disabled, there would be more free space and even less BIOS code both open and closed","title":"Summary"},{"location":"variants/msi_z690/overview/","text":"Overview FAQ - list of frequently asked questions Releases - list of all releases Building manual - how to build Dasharo compatible with the MSI PRO Z690-A WiFi DDR4 Installation manual - how to install Dasharo firmware on the MSI PRO Z690-A WiFi DDR4 Recovery - recovering bricked platform Hardware configuration matrix - definition of hardware configuration used during validation Test matrix - validation scope for the MSI PRO Z690-A WiFi DDR4 Development - information for Dasharo developers Memory Compatibility - memory modules tested by community CPU Compatibility - processors tested by community GPU Compatibility - graphics cards tested by community Community test results - test results performed by the community. Useful documents MSI Z690-A PRO DDR4 WiFI site Board manual Press releases PC Gamer Phoronix Tom's Hardware Root.cz GN24 ITBusiness","title":"Overview"},{"location":"variants/msi_z690/overview/#overview","text":"FAQ - list of frequently asked questions Releases - list of all releases Building manual - how to build Dasharo compatible with the MSI PRO Z690-A WiFi DDR4 Installation manual - how to install Dasharo firmware on the MSI PRO Z690-A WiFi DDR4 Recovery - recovering bricked platform Hardware configuration matrix - definition of hardware configuration used during validation Test matrix - validation scope for the MSI PRO Z690-A WiFi DDR4 Development - information for Dasharo developers Memory Compatibility - memory modules tested by community CPU Compatibility - processors tested by community GPU Compatibility - graphics cards tested by community Community test results - test results performed by the community.","title":"Overview"},{"location":"variants/msi_z690/overview/#useful-documents","text":"MSI Z690-A PRO DDR4 WiFI site Board manual","title":"Useful documents"},{"location":"variants/msi_z690/overview/#press-releases","text":"PC Gamer Phoronix Tom's Hardware Root.cz GN24 ITBusiness","title":"Press releases"},{"location":"variants/msi_z690/recovery/","text":"Dasharo compatible with MSI PRO Z690-A WIFI DDR4 - recovery Intro The project is in early development phase. It may happen that on certain hardware configurations the Dasharo firmware will not boot correctly (i.e. we will have \"bricked\" platform). In such a case, recovery procedure can install back the original firmware from the board manufacturer. MSI Flash BIOS Button The MSI Flash BIOS Button would give us easy-to-use recovery method. We have tried that one to switch from Dasharo firmware to the original one, but it did not work, unfortunately. The details of how this process exactly works are unknown due to the closed nature of it's implementation. We can research this topic more in the future, so maybe it can be utilized later for deployment and/or recovery of the platform. External flashing with programmer In this case, using external programmer is necessary. We are using RTE here. Connect programmer to the flash chip as shown in the Hardware connection / SPI section of the Development documentation. Download official BIOS from vendor's website (this is the newest version, you may choose an older one too or in the best case use your firmware backup): wget https://download.msi.com/bos_exe/mb/7D25v13.zip unzip 7D25v13.zip Flash via external programmer: The command line will be different, depending on the programmer you use flashrom -p linux_spi:dev = /dev/spidev1.0,spispeed = 16000 -w 7D25v13/E7D25IMS.130 First boot after the recovery process is significantly longer SMBIOS unique data recovery Serial number format and recovery SMBIOS specification sections 7.2 and 7.3 defines two spaces for serial number: the system serial number and baseboard serial number. The original MSI PRO Z690-A firmware provides only baseboard serial number. In case you have lost your serial number in the process of flashing Dasharo or newer MSI firmware, there is a way to retrieve it. The board has a QR code imprinted between the chipset heatsink and dPGU PCIe slot: If you read the QR code with your smartphone you will get the full serial number. The serial number has the format 07D25xx_LyzEaaaaaa where: 07D25 - is the board model, i.e. MS-7D25 for this particular board xx is the mainboard revision which should match the revision imprinted between the M2_1 slot and dGPU slot. E.g. xx=11 means VER:1.1 yz is the manufacturing date in hex, i.e. y is the month, z is the year, for example A1 means October 202 1 , 12 means January 202 2 aaaaaa is the unique 6-digit number which is imprinted under the serial number QR code System UUID format and recovery SMBIOS specification section 7.2 defines a field for unique system identification with a special number called UUID (Universally Unique IDentifier). UUID is specified by RFC 4122 . MSI firmware provides the system UUID in the SMBIOS system information structure. The problem with UUID is that it cannot be recovered if the backup binary or SMBIOS logs are lost. You can backup the SMBIOS information with our Dasharo Tools Suite bootable stick . The dmidecode.log will have all the necessary information. Things we know about MSI system UUID: UUID format is as follows: 33221100-5544-7766-8899-AABBCCDDEEFF , the hex numbers represent the order of bytes in memory for the little-endian format as required by SMBIOS MSI UUIDs do not conform to any of the RFC 4122 UUID variants/versions (the bits responsible for UUID version and variant identification are not constant across multiple boards) the last octet group AABBCCDDEEFF is equal to the MAC address of the on-board Intel i225 Ethernet, so be sure to NOT share the UUID with anybody as it contains system sensitive information the first four groups are either random numbers or some cryptographically acquired value from e.g. combination of some board data, unfortunately it is not known by us The MAC address is printed on a sticker placed on the 2x2 SATA connector: SMBIOS data migration For Dasharo simply follow the Installation manual how to migrate the data. For MSI firmware you will probably need an AMI DMI/SMBIOS editor to save those values back if you do not have a backup binary.","title":"Recovery"},{"location":"variants/msi_z690/recovery/#dasharo-compatible-with-msi-pro-z690-a-wifi-ddr4-recovery","text":"","title":"Dasharo compatible with MSI PRO Z690-A WIFI DDR4 - recovery"},{"location":"variants/msi_z690/recovery/#intro","text":"The project is in early development phase. It may happen that on certain hardware configurations the Dasharo firmware will not boot correctly (i.e. we will have \"bricked\" platform). In such a case, recovery procedure can install back the original firmware from the board manufacturer.","title":"Intro"},{"location":"variants/msi_z690/recovery/#smbios-unique-data-recovery","text":"","title":"SMBIOS unique data recovery"},{"location":"variants/msi_z690/releases/","text":"Dasharo compatible with MSI PRO Z690-A WIFI DDR4 Release Notes Following Release Notes describe status of Open Source Firmware development for MSI PRO Z690-A WIFI DDR4 For details about our release process please read Dasharo Standard Release Process . Subscribe to Dasharo compatible with MSI PRO Z690-A WIFI DDR4 Newsletter Test results for this platform can be found here . v1.0.0 - 2022-05-27 Added Serial number and UUID in CBFS support TPM Physical Presence Interface support Changed Updated i225 EFI driver to version 0.10.04 to reduce the POST time Vboot submodule revision to fix recovery mode loop Fixed fTPM is not working Known issues USB storage devices disappear after reboot/power failure Binaries MSI PRO Z690-A WIFI DDR4 v1.0.0 sha256 sha256.sig See how to verify signatures on this video Commands snippet: gpg --fetch-keys https://raw.githubusercontent.com/3mdeb/3mdeb-secpack/master/keys/master-key/3mdeb-master-key.asc gpg --fetch-keys https://raw.githubusercontent.com/3mdeb/3mdeb-secpack/master/dasharo/3mdeb-dasharo-master-key.asc gpg --fetch-keys https://raw.githubusercontent.com/3mdeb/3mdeb-secpack/master/dasharo/msi_ms7d25/dasharo-release-1.x-compatible-with-msi-ms-7d25-signing-key.asc gpg --list-sigs \"3mdeb Master Key\" \"3mdeb Dasharo Master Key\" \"Dasharo release 1.x compatible with MSI MS-7D25 signing key\" wget https://3mdeb.com/open-source-firmware/Dasharo/msi_ms7d25/v1.0.0/msi_ms7d25_v1.0.0.rom wget https://3mdeb.com/open-source-firmware/Dasharo/msi_ms7d25/v1.0.0/msi_ms7d25_v1.0.0.rom.sha256 wget https://3mdeb.com/open-source-firmware/Dasharo/msi_ms7d25/v1.0.0/msi_ms7d25_v1.0.0.rom.sha256.sig sha256sum -c msi_ms7d25_v1.0.0.rom.sha256 gpg --verify msi_ms7d25_v1.0.0.rom.sha256.sig msi_ms7d25_v1.0.0.rom.sha256 SBOM (Software Bill of Materials) coreboot based on a552cfc9 revision d22caaa0a edk2 based on 4d2846ba revision 0c94299b v0.4.0 - 2022-05-13 Added Verified boot support Fixed Some PCIe ports are not working Known issues USB storage devices disappear after reboot/power failure fTPM is not working Binaries MSI PRO Z690-A WIFI DDR4 v0.4.0 sha256 sha256.sig See how to verify signatures on this video Commands snippet: gpg --fetch-keys https://raw.githubusercontent.com/3mdeb/3mdeb-secpack/master/keys/master-key/3mdeb-master-key.asc gpg --fetch-keys https://raw.githubusercontent.com/3mdeb/3mdeb-secpack/master/dasharo/3mdeb-dasharo-master-key.asc gpg --fetch-keys https://raw.githubusercontent.com/3mdeb/3mdeb-secpack/master/dasharo/msi_ms7d25/dasharo-release-0.x-compatible-with-msi-ms-7d25-signing-key.asc gpg --list-sigs \"3mdeb Master Key\" \"3mdeb Dasharo Master Key\" \"Dasharo release 0.x compatible with MSI MS-7D25 signing key\" wget https://3mdeb.com/open-source-firmware/Dasharo/msi_ms7d25/v0.4.0/msi_ms7d25_v0.4.0.rom wget https://3mdeb.com/open-source-firmware/Dasharo/msi_ms7d25/v0.4.0/msi_ms7d25_v0.4.0.rom.sha256 wget https://3mdeb.com/open-source-firmware/Dasharo/msi_ms7d25/v0.4.0/msi_ms7d25_v0.4.0.rom.sha256.sig sha256sum -c msi_ms7d25_v0.4.0.rom.sha256 gpg --verify msi_ms7d25_v0.4.0.rom.sha256.sig msi_ms7d25_v0.4.0.rom.sha256 SBOM (Software Bill of Materials) coreboot based on a552cfc9 revision 31c1da6b edk2 based on 4d2846ba revision 5494c8e2 v0.3.0 - 2022-05-05 Added Mainboard-specific SMBIOS data for slots and ports PCI Subsystem ID configuration CPU VR and PCH FIVR configuration Memory HCL UEFI Secure Boot TPM Support Measured Boot Custom boot menu keys Known issues USB storage devices disappear after reboot/power failure Some PCIe ports are not working fTPM is not working Binaries MSI PRO Z690-A WIFI DDR4 v0.3.0 sha256 sha256.sig See how to verify signatures on this video Commands snippet: gpg --fetch-keys https://raw.githubusercontent.com/3mdeb/3mdeb-secpack/master/keys/master-key/3mdeb-master-key.asc gpg --fetch-keys https://raw.githubusercontent.com/3mdeb/3mdeb-secpack/master/dasharo/3mdeb-dasharo-master-key.asc gpg --fetch-keys https://raw.githubusercontent.com/3mdeb/3mdeb-secpack/master/dasharo/msi_ms7d25/dasharo-release-0.x-compatible-with-msi-ms-7d25-signing-key.asc gpg --list-sigs \"3mdeb Master Key\" \"3mdeb Dasharo Master Key\" \"Dasharo release 0.x compatible with MSI MS-7D25 signing key\" wget https://3mdeb.com/open-source-firmware/Dasharo/msi_ms7d25/v0.3.0/msi_ms7d25_v0.3.0.rom wget https://3mdeb.com/open-source-firmware/Dasharo/msi_ms7d25/v0.3.0/msi_ms7d25_v0.3.0.rom.sha256 wget https://3mdeb.com/open-source-firmware/Dasharo/msi_ms7d25/v0.3.0/msi_ms7d25_v0.3.0.rom.sha256.sig sha256sum -c msi_ms7d25_v0.3.0.rom.sha256 gpg --verify msi_ms7d25_v0.3.0.rom.sha256.sig msi_ms7d25_v0.3.0.rom.sha256 SBOM (Software Bill of Materials) coreboot based on a552cfc9 revision b45173e9 edk2 based on 4d2846ba revision 5494c8e2 v0.2.0 - 2022-04-22 Added Configurable boot order Configurable boot options NVMe support Integrated WiFi and BT support PCIe support Network boot with integrated Ethernet Audio support Known issues USB storage devices disappear after reboot/power failure Some PCIe ports are not working Binaries MSI PRO Z690-A WIFI DDR4 v0.2.0 sha256 sha256.sig See how to verify signatures on this video Commands snippet: gpg --fetch-keys https://raw.githubusercontent.com/3mdeb/3mdeb-secpack/master/keys/master-key/3mdeb-master-key.asc gpg --fetch-keys https://raw.githubusercontent.com/3mdeb/3mdeb-secpack/master/dasharo/3mdeb-dasharo-master-key.asc gpg --fetch-keys https://raw.githubusercontent.com/3mdeb/3mdeb-secpack/master/dasharo/msi_ms7d25/dasharo-release-0.x-compatible-with-msi-ms-7d25-signing-key.asc gpg --list-sigs \"3mdeb Master Key\" \"3mdeb Dasharo Master Key\" \"Dasharo release 0.x compatible with MSI MS-7D25 signing key\" wget https://3mdeb.com/open-source-firmware/Dasharo/msi_ms7d25/v0.2.0/msi_ms7d25_v0.2.0.rom wget https://3mdeb.com/open-source-firmware/Dasharo/msi_ms7d25/v0.2.0/msi_ms7d25_v0.2.0.rom.sha256 wget https://3mdeb.com/open-source-firmware/Dasharo/msi_ms7d25/v0.2.0/msi_ms7d25_v0.2.0.rom.sha256.sig sha256sum -c msi_ms7d25_v0.2.0.rom.sha256 gpg --verify msi_ms7d25_v0.2.0.rom.sha256.sig msi_ms7d25_v0.2.0.rom.sha256 SBOM (Software Bill of Materials) coreboot based on a552cfc9 revision 83fbdcf1 edk2 based on 4d2846ba revision 0a188758 v0.1.0 - 2022-04-13 Added Initial support for the MSI PRO Z690-A WIFI DDR4 platform Dasharo boot logo Dasharo SMBIOS compatibility UEFI compatibility UEFI shell One-time boot feature External HDMI and Display Port rear panel display support USB support Known issues USB storage devices disappear after reboot/power failure Binaries MSI PRO Z690-A WIFI DDR4 v0.1.0 sha256 sha256.sig See how to verify signatures on this video Commands snippet: gpg --fetch-keys https://raw.githubusercontent.com/3mdeb/3mdeb-secpack/master/keys/master-key/3mdeb-master-key.asc gpg --fetch-keys https://raw.githubusercontent.com/3mdeb/3mdeb-secpack/master/dasharo/3mdeb-dasharo-master-key.asc gpg --fetch-keys https://raw.githubusercontent.com/3mdeb/3mdeb-secpack/master/dasharo/msi_ms7d25/dasharo-release-0.x-compatible-with-msi-ms-7d25-signing-key.asc gpg --list-sigs \"3mdeb Master Key\" \"3mdeb Dasharo Master Key\" \"Dasharo release 0.x compatible with MSI MS-7D25 signing key\" wget https://3mdeb.com/open-source-firmware/Dasharo/msi_ms7d25/msi_ms7d25_v0.1.0.rom wget https://3mdeb.com/open-source-firmware/Dasharo/msi_ms7d25/msi_ms7d25_v0.1.0.rom.sha256 wget https://3mdeb.com/open-source-firmware/Dasharo/msi_ms7d25/msi_ms7d25_v0.1.0.rom.sha256.sig sha256sum -c msi_ms7d25_v0.1.0.rom.sha256 gpg --verify msi_ms7d25_v0.1.0.rom.sha256.sig msi_ms7d25_v0.1.0.rom.sha256 SBOM (Software Bill of Materials) coreboot based on a552cfc9 revision 53948cd8 edk2 based on 4d2846ba revision 4d2846ba","title":"Releases"},{"location":"variants/msi_z690/releases/#dasharo-compatible-with-msi-pro-z690-a-wifi-ddr4-release-notes","text":"Following Release Notes describe status of Open Source Firmware development for MSI PRO Z690-A WIFI DDR4 For details about our release process please read Dasharo Standard Release Process . Subscribe to Dasharo compatible with MSI PRO Z690-A WIFI DDR4 Newsletter Test results for this platform can be found here .","title":"Dasharo compatible with MSI PRO Z690-A WIFI DDR4 Release Notes"},{"location":"variants/msi_z690/releases/#v100-2022-05-27","text":"","title":"v1.0.0 - 2022-05-27"},{"location":"variants/msi_z690/releases/#v040-2022-05-13","text":"","title":"v0.4.0 - 2022-05-13"},{"location":"variants/msi_z690/releases/#v030-2022-05-05","text":"","title":"v0.3.0 - 2022-05-05"},{"location":"variants/msi_z690/releases/#v020-2022-04-22","text":"","title":"v0.2.0 - 2022-04-22"},{"location":"variants/msi_z690/releases/#v010-2022-04-13","text":"","title":"v0.1.0 - 2022-04-13"},{"location":"variants/msi_z690/test-matrix/","text":"Test matrix - MSI Z690-A WIFI DDR4 About The test matrix is used to determine the scope of tests which the DUT is subjected from before the release of the new binary. Module: Dasharo compatibility No. Supported test suite Test suite ID Supported test cases 1. Memory HCL HCL All 2. UEFI compatible interface EFI All 3. UEFI Shell USH All 4. Display ports and LCD support DSP DSP002.001, DSP002.002, DSP002.003, DSP003.001, DSP003.002, DSP003.003 5. USB HID and MSC Support USB All 6. SMBIOS DMI DMI002.001, DMI003.001, DMI004.001, DMI005.001, DMI006.001, DMI008.001 7. Custom boot logo CLG All 8. M.2 WiFi/Bluetooth WLE All 9. Audio subsystem AUD AUD001.001, AUD001.002, AUD004.001, AUD004.002 AUD005.001, AUD005.002 AUD006.001, AUD006.002 10. NVMe support NVM All 11. Network boot PXE All 12. Debian Stable and Ubuntu LTS support LBT All 13. Windows booting WBT All 14. SD card support SDC All 15. Custom logo CLG All 16. Custom boot menu key CBK All Module: Dasharo security No. Supported test suite Test suite ID Supported test cases 1. TPM Support TPM All 2. Verified Boot support VBO VBO001.002, VBO002.002, VBO003.001 3. Measured Boot support MBO All 4. Secure Boot support SBO All Module: Dasharo performance No. Supported test suite Test suite ID Supported test cases 1. coreboot bring up time measurement CBMEM All","title":"Test matrix"},{"location":"variants/msi_z690/test-matrix/#test-matrix-msi-z690-a-wifi-ddr4","text":"","title":"Test matrix - MSI Z690-A WIFI DDR4"},{"location":"variants/msi_z690/test-matrix/#about","text":"The test matrix is used to determine the scope of tests which the DUT is subjected from before the release of the new binary.","title":"About"},{"location":"variants/msi_z690/test-matrix/#module-dasharo-compatibility","text":"No. Supported test suite Test suite ID Supported test cases 1. Memory HCL HCL All 2. UEFI compatible interface EFI All 3. UEFI Shell USH All 4. Display ports and LCD support DSP DSP002.001, DSP002.002, DSP002.003, DSP003.001, DSP003.002, DSP003.003 5. USB HID and MSC Support USB All 6. SMBIOS DMI DMI002.001, DMI003.001, DMI004.001, DMI005.001, DMI006.001, DMI008.001 7. Custom boot logo CLG All 8. M.2 WiFi/Bluetooth WLE All 9. Audio subsystem AUD AUD001.001, AUD001.002, AUD004.001, AUD004.002 AUD005.001, AUD005.002 AUD006.001, AUD006.002 10. NVMe support NVM All 11. Network boot PXE All 12. Debian Stable and Ubuntu LTS support LBT All 13. Windows booting WBT All 14. SD card support SDC All 15. Custom logo CLG All 16. Custom boot menu key CBK All","title":"Module: Dasharo compatibility"},{"location":"variants/msi_z690/test-matrix/#module-dasharo-security","text":"No. Supported test suite Test suite ID Supported test cases 1. TPM Support TPM All 2. Verified Boot support VBO VBO001.002, VBO002.002, VBO003.001 3. Measured Boot support MBO All 4. Secure Boot support SBO All","title":"Module: Dasharo security"},{"location":"variants/novacustom_ns5x/building/","text":"Dasharo for NovaCustom NS5X - Building manual Intro This documents describes the procedure for compiling coreboot for NovaCustom NS5X. Requirements Docker follow Install Docker Engine on Ubuntu follow Post-installation steps for Linux Git Procedure The easiest way to build coreboot is to use the official Docker image. Obtain the image: docker pull coreboot/coreboot-sdk:0ad5fbd48d Clone the coreboot repository: git clone https://review.coreboot.org/coreboot.git Checkout to the desired Dasharo revision: Replace the REVISION with one of the: - novacustom_ns5x/release for the latest released version - novacustom_ns5x_vVERSION (e.g. v1.0.0 ) for the given release cd coreboot git remote add dasharo https://github.com/dasharo/coreboot.git git submodule update --init --recursive --checkout git fetch dasharo git checkout REVISION Build the firmware: ./build.sh build The resulting coreboot image will be placed in artifacts/dasharo_novacustom_ns5x_VERSION.rom . Warning : Do not run ./build.sh as root. This command uses docker and should be executed as your current user. If you're having trouble running build.sh on your user account, follow the Docker instructions outlined in Requirements .","title":"Building manual"},{"location":"variants/novacustom_ns5x/building/#dasharo-for-novacustom-ns5x-building-manual","text":"","title":"Dasharo for NovaCustom NS5X - Building manual"},{"location":"variants/novacustom_ns5x/building/#intro","text":"This documents describes the procedure for compiling coreboot for NovaCustom NS5X.","title":"Intro"},{"location":"variants/novacustom_ns5x/building/#requirements","text":"Docker follow Install Docker Engine on Ubuntu follow Post-installation steps for Linux Git","title":"Requirements"},{"location":"variants/novacustom_ns5x/building/#procedure","text":"The easiest way to build coreboot is to use the official Docker image. Obtain the image: docker pull coreboot/coreboot-sdk:0ad5fbd48d Clone the coreboot repository: git clone https://review.coreboot.org/coreboot.git Checkout to the desired Dasharo revision: Replace the REVISION with one of the: - novacustom_ns5x/release for the latest released version - novacustom_ns5x_vVERSION (e.g. v1.0.0 ) for the given release cd coreboot git remote add dasharo https://github.com/dasharo/coreboot.git git submodule update --init --recursive --checkout git fetch dasharo git checkout REVISION Build the firmware: ./build.sh build The resulting coreboot image will be placed in artifacts/dasharo_novacustom_ns5x_VERSION.rom . Warning : Do not run ./build.sh as root. This command uses docker and should be executed as your current user. If you're having trouble running build.sh on your user account, follow the Docker instructions outlined in Requirements .","title":"Procedure"},{"location":"variants/novacustom_ns5x/hardware-matrix/","text":"Hardware configuration matrix - NovaCustom NS51/NS70 Introduction This document describes the hardware configurations used for validation of the coreboot port on the NovaCustom NS51/NS70 laptops. NS51 Component Description CPU Intel(R) Core(TM) i5-1135G7 Internal Cooling RAM Slot 1: KVR32S22D8/16 Slot 2: KVR32S22D8/16 SSD Samsung SSD 980 PRO 250 GB Flash memory Winbond 25Q128JVSQ 2118 16 MB Network Local network wired connection Internal devices 1. 1920x1080 14 inch screen 2. Internal keyboard with LED backlight 3. Touchpad 4. Camera 5. Audio subsystem Attached devices 1. SanDisk Ultra USB 3.0 64 GB 2. SanDisk Ultra Flair USB 3.0 16 GB 3. SanDisk Ultra Flair USB 3.0 32 GB 4. Kingston DataTraveler 3.1Gen1 16 GB 5. SanDisk Ultra microSD HC I 16 GB + SD Adapter 6. Logitech, Inc. Keyboard K120 7. Expansion Dock Type-C Power Supply Chicony 65 W Power Control N/A NS70 Component Description CPU Intel(R) Core(TM) i5-1135G7 Internal Cooling RAM Slot 1: KVR32S22S8/8 Slot 2: KVR32S22S8/8 SSD Samsung SSD 980 250 GB Samsung SSD 980 PRO 250 GB Flash memory GigaDevice 25B127DSIG 16 MB Network Local network wired connection Internal devices 1. 1920x1080 14 inch screen 2. Internal keyboard with LED backlight 3. Touchpad 4. Camera 5. Audio subsystem Attached devices 1. SanDisk Ultra USB 3.0 64 GB 2. SanDisk Ultra Flair USB 3.0 16 GB 3. SanDisk Ultra Flair USB 3.0 32 GB 4. Kingston DataTraveler 3.1Gen1 16 GB 5. SanDisk Ultra microSD HC I 16 GB + SD Adapter 6. Logitech, Inc. Keyboard K120 7. Expansion Dock Type-C Power Supply Chicony 65 W Power Control N/A","title":"Hardware Configuration Matrix"},{"location":"variants/novacustom_ns5x/hardware-matrix/#hardware-configuration-matrix-novacustom-ns51ns70","text":"","title":"Hardware configuration matrix - NovaCustom NS51/NS70"},{"location":"variants/novacustom_ns5x/hardware-matrix/#introduction","text":"This document describes the hardware configurations used for validation of the coreboot port on the NovaCustom NS51/NS70 laptops.","title":"Introduction"},{"location":"variants/novacustom_ns5x/hardware-matrix/#ns51","text":"Component Description CPU Intel(R) Core(TM) i5-1135G7 Internal Cooling RAM Slot 1: KVR32S22D8/16 Slot 2: KVR32S22D8/16 SSD Samsung SSD 980 PRO 250 GB Flash memory Winbond 25Q128JVSQ 2118 16 MB Network Local network wired connection Internal devices 1. 1920x1080 14 inch screen 2. Internal keyboard with LED backlight 3. Touchpad 4. Camera 5. Audio subsystem Attached devices 1. SanDisk Ultra USB 3.0 64 GB 2. SanDisk Ultra Flair USB 3.0 16 GB 3. SanDisk Ultra Flair USB 3.0 32 GB 4. Kingston DataTraveler 3.1Gen1 16 GB 5. SanDisk Ultra microSD HC I 16 GB + SD Adapter 6. Logitech, Inc. Keyboard K120 7. Expansion Dock Type-C Power Supply Chicony 65 W Power Control N/A","title":"NS51"},{"location":"variants/novacustom_ns5x/hardware-matrix/#ns70","text":"Component Description CPU Intel(R) Core(TM) i5-1135G7 Internal Cooling RAM Slot 1: KVR32S22S8/8 Slot 2: KVR32S22S8/8 SSD Samsung SSD 980 250 GB Samsung SSD 980 PRO 250 GB Flash memory GigaDevice 25B127DSIG 16 MB Network Local network wired connection Internal devices 1. 1920x1080 14 inch screen 2. Internal keyboard with LED backlight 3. Touchpad 4. Camera 5. Audio subsystem Attached devices 1. SanDisk Ultra USB 3.0 64 GB 2. SanDisk Ultra Flair USB 3.0 16 GB 3. SanDisk Ultra Flair USB 3.0 32 GB 4. Kingston DataTraveler 3.1Gen1 16 GB 5. SanDisk Ultra microSD HC I 16 GB + SD Adapter 6. Logitech, Inc. Keyboard K120 7. Expansion Dock Type-C Power Supply Chicony 65 W Power Control N/A","title":"NS70"},{"location":"variants/novacustom_ns5x/installation/","text":"Dasharo for NovaCustom NS5X - Installation manual Intro Flashing coreboot can be done from Linux using flashrom with the internal programmer. This document describes the process of building, installing and running flashrom on Ubuntu 20.04. Build flashrom Currently, the latest flashrom release lacks support for Tiger Lake-U internal flashing. Because of this, we need to build flashrom from source. Install build dependencies: apt install git build-essential debhelper pkg-config libpci-dev libusb-1.0-0-dev libftdi1-dev meson Obtain source code: git clone https://review.coreboot.org/flashrom.git cd flashrom Build flashrom: make sudo make install Reading flash contents To read from the flash and save them to a file ( dump.rom ), execute the following command: flashrom -p internal -r dump.rom Installing Dasharo Initial Installation During initial installation of Dasharo, you should deploy supported Intel ME version (and configuration) on the device. Publicly released binaries do not contain ME binary. If you need an Intel ME update for your device, contact us via already established commercial support channel. When flashing binaries with ME binary included, flashing of the whole chip is required. Additionally, the firmware has to be flashed externally using an external programmer like a ch341a_spi . Steps for initial Dasharo installation: Open the laptop Disconnect the primary battery (1) Disconnect the CMOS battery (2) Attach an external programmer with a SOIC-8 clip to the SPI flash chip (3) Execute the following command, replaceing [path] with the path to the firmware image you want to flash, e.g. novacustom_ns5x_full_v1.0.0.rom flashrom -p ch341a_spi -w [ path ] Detach the SOIC-8 clip Connect the primary battery (1) - do not connect the CMOS battery yet (2) Power on the laptop. The laptop may shut down once after training the memory. Once Dasharo is booted, shut down the laptop and reconnect the CMOS battery. Updating Dasharo If Dasharo is currently installed, only the RW_SECTION_A partition of the flash needs to be updated. Flash it using the following command: flashrom -p internal -w [ path ] --fmap -i RW_SECTION_A This command also preserves UEFI settings and the boot order.","title":"Installation manual"},{"location":"variants/novacustom_ns5x/installation/#dasharo-for-novacustom-ns5x-installation-manual","text":"","title":"Dasharo for NovaCustom NS5X - Installation manual"},{"location":"variants/novacustom_ns5x/installation/#intro","text":"Flashing coreboot can be done from Linux using flashrom with the internal programmer. This document describes the process of building, installing and running flashrom on Ubuntu 20.04.","title":"Intro"},{"location":"variants/novacustom_ns5x/installation/#build-flashrom","text":"Currently, the latest flashrom release lacks support for Tiger Lake-U internal flashing. Because of this, we need to build flashrom from source. Install build dependencies: apt install git build-essential debhelper pkg-config libpci-dev libusb-1.0-0-dev libftdi1-dev meson Obtain source code: git clone https://review.coreboot.org/flashrom.git cd flashrom Build flashrom: make sudo make install","title":"Build flashrom"},{"location":"variants/novacustom_ns5x/installation/#reading-flash-contents","text":"To read from the flash and save them to a file ( dump.rom ), execute the following command: flashrom -p internal -r dump.rom","title":"Reading flash contents"},{"location":"variants/novacustom_ns5x/installation/#installing-dasharo","text":"","title":"Installing Dasharo"},{"location":"variants/novacustom_ns5x/overview/","text":"Overview Releases - list of all releases Building manual - how to build Dasharo compatible with NovaCustom NS5X Installation manual - how to install Dasharo firmware on NovaCustom NS5X Hardware configuration matrix - definition of hardware configuration used during validation Test matrix - validation scope for NovaCustom NS5X Post installation steps - Post-installation tweaks RGB keyboard - Manual for the RGB keyboard hotkeys","title":"Overview"},{"location":"variants/novacustom_ns5x/overview/#overview","text":"Releases - list of all releases Building manual - how to build Dasharo compatible with NovaCustom NS5X Installation manual - how to install Dasharo firmware on NovaCustom NS5X Hardware configuration matrix - definition of hardware configuration used during validation Test matrix - validation scope for NovaCustom NS5X Post installation steps - Post-installation tweaks RGB keyboard - Manual for the RGB keyboard hotkeys","title":"Overview"},{"location":"variants/novacustom_ns5x/post_install/","text":"Post-installation setup This document contains extra steps to perform after installing Dasharo in order to enable full functionality. Touchpad hotkey enablement (Linux) The touchpad hotkey needs extra setup to function correctly under Linux. To enable the touchpad hotkey to work under Linux, follow the steps below: Create a file /etc/udev/hwdb.d/60-keyboard.hwdb with the following contents: bash evdev:atkbd:dmi:bvn*:bvr*:svnNotebook:pnNS50_70MU:* KEYBOARD_KEY_f7=191 KEYBOARD_KEY_f8=191 Execute the following commands: sudo systemd-hwdb update sudo udevadm trigger After executing these steps, it should be possible to enable and disable the touchpad using the touchpad hotkey (Fn+F1) on the keyboard when using GNOME.","title":"Post-installation steps"},{"location":"variants/novacustom_ns5x/post_install/#post-installation-setup","text":"This document contains extra steps to perform after installing Dasharo in order to enable full functionality.","title":"Post-installation setup"},{"location":"variants/novacustom_ns5x/post_install/#touchpad-hotkey-enablement-linux","text":"The touchpad hotkey needs extra setup to function correctly under Linux. To enable the touchpad hotkey to work under Linux, follow the steps below: Create a file /etc/udev/hwdb.d/60-keyboard.hwdb with the following contents: bash evdev:atkbd:dmi:bvn*:bvr*:svnNotebook:pnNS50_70MU:* KEYBOARD_KEY_f7=191 KEYBOARD_KEY_f8=191 Execute the following commands: sudo systemd-hwdb update sudo udevadm trigger After executing these steps, it should be possible to enable and disable the touchpad using the touchpad hotkey (Fn+F1) on the keyboard when using GNOME.","title":"Touchpad hotkey enablement (Linux)"},{"location":"variants/novacustom_ns5x/releases/","text":"NovaCustom NS5x Dasharo Release Notes Following Release Notes describe status of Open Source Firmware development for NovaCustom NS5x For details about our release process please read Dasharo Standard Release Process . Subscribe to NovaCustom NS5x Dasharo Release Newsletter Test results for this platform can be found here . v1.2.0 - 2022-05-26 Test results for this release can be found here . Added Persistent RGB keyboard settings Increased power limits to CPU defaults (28W PL1 / 35W PL2) Fixed CVE-2022-29264 SMM loader vulnerability Incorrect vendor name in SMBIOS Known issues CPU not running on expected frequency and usage NS50MU UCM-UCSI ACPI device displays an error in Windows Device Manager Headsets connected to the docking station are not recognizable on NS70/50 v1.2.0 General problem with charging the DUT via the docking station using USB Type-C slot NS70/50 v1.2.0 Binaries novacustom_ns5x_v1.2.0.rom sha256 sha256.sig See how to verify signatures on this video SBOM (Software Bill of Materials) coreboot based on 4.16 revision b087dcbd tianocore based on e0334c228ce4ba51f47ff79a118f214031d4650f revision 90364638 v1.1.0 - 2022-04-22 Added Support for NovaCustom NS7x Support for RGB Keyboard Persistent boot logo implementation Changed Temporarily disable vboot due to the risk of bricinkg certain units when flashing via internal programmer Known issues CPU not running on expected frequency and usage NS50MU UCM-UCSI ACPI device displays an error in Windows Device Manager The touchpad ON/OFF switch Fn key is not functional Incorrect vendor name in SMBIOS Binaries novacustom_ns5x_v1.1.0.rom sha256 sha256.sig See how to verify signatures on this video SBOM (Software Bill of Materials) coreboot based on 4.16 revision c2f031af tianocore based on e0334c228ce4ba51f47ff79a118f214031d4650f revision 4d2846ba v1.0.0 - 2022-03-23 Added Support for NovaCustom NS5x Support for EC firmware 1.07.07 UEFI Boot Support Configurable boot order Configurable boot options UEFI Secure Boot support NovaCustom boot logo Known issues The touchpad ON/OFF switch Fn key is not functional Binaries novacustom_ns5x_v1.0.0.rom sha256 sha256.sig SBOM (Software Bill of Materials) coreboot based on 4.16 revision ecf1e9b8 tianocore based on e0334c228ce4ba51f47ff79a118f214031d4650f revision ec6805c2","title":"Releases"},{"location":"variants/novacustom_ns5x/releases/#novacustom-ns5x-dasharo-release-notes","text":"Following Release Notes describe status of Open Source Firmware development for NovaCustom NS5x For details about our release process please read Dasharo Standard Release Process . Subscribe to NovaCustom NS5x Dasharo Release Newsletter Test results for this platform can be found here .","title":"NovaCustom NS5x Dasharo Release Notes"},{"location":"variants/novacustom_ns5x/releases/#v120-2022-05-26","text":"Test results for this release can be found here .","title":"v1.2.0 - 2022-05-26"},{"location":"variants/novacustom_ns5x/releases/#v110-2022-04-22","text":"","title":"v1.1.0 - 2022-04-22"},{"location":"variants/novacustom_ns5x/releases/#v100-2022-03-23","text":"","title":"v1.0.0 - 2022-03-23"},{"location":"variants/novacustom_ns5x/rgb_keyboard/","text":"NovaCustom NS5x RGB keyboard The NS5x laptop features an RGB backlight keyboard. Dasharo implements full driverless backlight control using only the hotkeys on the keyboard. Usage The backlight can be operated using the hotkeys on the numpad: Fn + / - Next color Fn + * - Toggle On / Off Fn + - - Brightness down Fn + + - Brightness up The backlight has the following color modes: White (default) Red Green Blue Yellow Magenta Cyan","title":"RGB keyboard"},{"location":"variants/novacustom_ns5x/rgb_keyboard/#novacustom-ns5x-rgb-keyboard","text":"The NS5x laptop features an RGB backlight keyboard. Dasharo implements full driverless backlight control using only the hotkeys on the keyboard.","title":"NovaCustom NS5x RGB keyboard"},{"location":"variants/novacustom_ns5x/rgb_keyboard/#usage","text":"The backlight can be operated using the hotkeys on the numpad: Fn + / - Next color Fn + * - Toggle On / Off Fn + - - Brightness down Fn + + - Brightness up The backlight has the following color modes: White (default) Red Green Blue Yellow Magenta Cyan","title":"Usage"},{"location":"variants/novacustom_ns5x/test-matrix/","text":"Test matrix - NovaCustom NS5x/NS7x About The test matrix is used to determine the scope of tests which the DUT is subjected from before the release of the new binary. Module: Dasharo compatibility No. Supported test suite Test suite ID Supported test cases 1. Memory HCL HCL All 2. UEFI compatible interface EFI All 3. Display ports and LCD support DSP DSP001.001, DSP001.002, DSP001.003, DSP002.001, DSP002.002, DSP002.003 4. Embedded Controller and Super I/O initialization ECR Whithout ECR010.001 and ECR010.002 5. NVMe support NVM All 6. Custom logo CLG All 7. Custom boot menu key CBK All 8. USB HID and MSC Support USB All 9. Debian Stable and Ubuntu LTS support LBT All 10. Windows booting WBT WBT001.001 11. Audio subsystem AUD All 12. USB-C/Thunderbolt UTC All 13. M.2 WiFi/Bluetooth WLE All 14. SD card support SDC All 15. USB Camera verification CAM All 16. Custom fan curve FAN FAN001.001 17. SMBIOS DMI DMI002.001, DMI003.001, DMI005.001, DMI006.001, DMI007.001, DMI008.001 18. Docking station detect DUD All 19. Docking station USB devices DUB All 20. Docking station Audio DAU All 21. Docking station USB-C DUC All 22. Firmware update using fwupd FFW All 23. Firmware update using Dasharo Tools Suite FDT All Module: Dasharo security No. Supported test suite Test suite ID Supported test cases 1. TPM Support TPM All 2. Measured Boot support MBO All 3. Secure Boot support SBO All Module: Dasharo performance No. Supported test suite Test suite ID Supported test cases 1. CPU frequency measure CPF All","title":"Test matrix"},{"location":"variants/novacustom_ns5x/test-matrix/#test-matrix-novacustom-ns5xns7x","text":"","title":"Test matrix - NovaCustom NS5x/NS7x"},{"location":"variants/novacustom_ns5x/test-matrix/#about","text":"The test matrix is used to determine the scope of tests which the DUT is subjected from before the release of the new binary.","title":"About"},{"location":"variants/novacustom_ns5x/test-matrix/#module-dasharo-compatibility","text":"No. Supported test suite Test suite ID Supported test cases 1. Memory HCL HCL All 2. UEFI compatible interface EFI All 3. Display ports and LCD support DSP DSP001.001, DSP001.002, DSP001.003, DSP002.001, DSP002.002, DSP002.003 4. Embedded Controller and Super I/O initialization ECR Whithout ECR010.001 and ECR010.002 5. NVMe support NVM All 6. Custom logo CLG All 7. Custom boot menu key CBK All 8. USB HID and MSC Support USB All 9. Debian Stable and Ubuntu LTS support LBT All 10. Windows booting WBT WBT001.001 11. Audio subsystem AUD All 12. USB-C/Thunderbolt UTC All 13. M.2 WiFi/Bluetooth WLE All 14. SD card support SDC All 15. USB Camera verification CAM All 16. Custom fan curve FAN FAN001.001 17. SMBIOS DMI DMI002.001, DMI003.001, DMI005.001, DMI006.001, DMI007.001, DMI008.001 18. Docking station detect DUD All 19. Docking station USB devices DUB All 20. Docking station Audio DAU All 21. Docking station USB-C DUC All 22. Firmware update using fwupd FFW All 23. Firmware update using Dasharo Tools Suite FDT All","title":"Module: Dasharo compatibility"},{"location":"variants/novacustom_ns5x/test-matrix/#module-dasharo-security","text":"No. Supported test suite Test suite ID Supported test cases 1. TPM Support TPM All 2. Measured Boot support MBO All 3. Secure Boot support SBO All","title":"Module: Dasharo security"},{"location":"variants/novacustom_ns5x/test-matrix/#module-dasharo-performance","text":"No. Supported test suite Test suite ID Supported test cases 1. CPU frequency measure CPF All","title":"Module: Dasharo performance"},{"location":"variants/novacustom_nv4x/building/","text":"coreboot building Intro This documents describes the procedure for compiling coreboot for NovaCustom NV4X. Requirements Docker follow Install Docker Engine on Ubuntu follow Post-installation steps for Linux Git Procedure The easiest way to build coreboot is to use the official Docker image. Obtain the image: docker pull coreboot/coreboot-sdk:0ad5fbd48d Clone the coreboot repository: git clone https://review.coreboot.org/coreboot.git Navigate to the source code directory and checkout to the desired revision: Replace the REVISION with one of the: - novacustom_nv4x/release for the latest released version - novacustom_nv4x_vVERSION (e.g. v1.2.1 ) for the given release cd coreboot git remote add dasharo https://github.com/dasharo/coreboot.git git submodule update --init --recursive --checkout git fetch dasharo git checkout REVISION Build the firmware: ./build.sh build The resulting coreboot image will be placed in artifacts/dasharo_novacustom_nv4x_VERSION.rom . Warning : Do not run ./build.sh as root. This command uses docker and should be executed as your current user. If you're having trouble running build.sh on your user account, follow the Docker instructions outlined in Requirements .","title":"Building manual"},{"location":"variants/novacustom_nv4x/building/#coreboot-building","text":"","title":"coreboot building"},{"location":"variants/novacustom_nv4x/building/#intro","text":"This documents describes the procedure for compiling coreboot for NovaCustom NV4X.","title":"Intro"},{"location":"variants/novacustom_nv4x/building/#requirements","text":"Docker follow Install Docker Engine on Ubuntu follow Post-installation steps for Linux Git","title":"Requirements"},{"location":"variants/novacustom_nv4x/building/#procedure","text":"The easiest way to build coreboot is to use the official Docker image. Obtain the image: docker pull coreboot/coreboot-sdk:0ad5fbd48d Clone the coreboot repository: git clone https://review.coreboot.org/coreboot.git Navigate to the source code directory and checkout to the desired revision: Replace the REVISION with one of the: - novacustom_nv4x/release for the latest released version - novacustom_nv4x_vVERSION (e.g. v1.2.1 ) for the given release cd coreboot git remote add dasharo https://github.com/dasharo/coreboot.git git submodule update --init --recursive --checkout git fetch dasharo git checkout REVISION Build the firmware: ./build.sh build The resulting coreboot image will be placed in artifacts/dasharo_novacustom_nv4x_VERSION.rom . Warning : Do not run ./build.sh as root. This command uses docker and should be executed as your current user. If you're having trouble running build.sh on your user account, follow the Docker instructions outlined in Requirements .","title":"Procedure"},{"location":"variants/novacustom_nv4x/ec_update/","text":"EC firmware update coreboot has been developed and tested in combination with Embedded Controller firmware version 1.07.05 and 1.07.08. Therefore, before flashing coreboot, it's necessary to first check and update/downgrade the EC firmware to one of these versions. At the moment, the EC firmware version can only be checked while running stock Insyde BIOS firmware. Check EC firmware version To check the current EC firmware version while running stock Insyde BIOS, run the following command: dmidecode -t 0 | grep ` Firmware Revision ` Firmware Revision: 7 .5 The line Firmware Revision: 7.5 indicates that the EC is running firmware version 1.07.05, which is one of the supported versions. If the version is different, it is necessary to upgrade (or downgrade) the EC firmware to a supported version. Update EC firmware Updating the EC is performed with the EcFlash EFI application. Download EC firmware 1.07.05 Format a USB stick to FAT32 Extract the update to root directory of the USB stick Plug the stick into the laptop Boot the laptop into the UEFI shell Open the USB stick, e.g. by running the command FS0: - one of the filesystems in the FS list will be the USB stick Run the command EcFlash.NSH to update the EC The laptop will update the EC and reboot automatically. EcFlash can also be used while running coreboot .","title":"EC firmware update"},{"location":"variants/novacustom_nv4x/ec_update/#ec-firmware-update","text":"coreboot has been developed and tested in combination with Embedded Controller firmware version 1.07.05 and 1.07.08. Therefore, before flashing coreboot, it's necessary to first check and update/downgrade the EC firmware to one of these versions. At the moment, the EC firmware version can only be checked while running stock Insyde BIOS firmware.","title":"EC firmware update"},{"location":"variants/novacustom_nv4x/ec_update/#check-ec-firmware-version","text":"To check the current EC firmware version while running stock Insyde BIOS, run the following command: dmidecode -t 0 | grep ` Firmware Revision ` Firmware Revision: 7 .5 The line Firmware Revision: 7.5 indicates that the EC is running firmware version 1.07.05, which is one of the supported versions. If the version is different, it is necessary to upgrade (or downgrade) the EC firmware to a supported version.","title":"Check EC firmware version"},{"location":"variants/novacustom_nv4x/ec_update/#update-ec-firmware","text":"Updating the EC is performed with the EcFlash EFI application. Download EC firmware 1.07.05 Format a USB stick to FAT32 Extract the update to root directory of the USB stick Plug the stick into the laptop Boot the laptop into the UEFI shell Open the USB stick, e.g. by running the command FS0: - one of the filesystems in the FS list will be the USB stick Run the command EcFlash.NSH to update the EC The laptop will update the EC and reboot automatically. EcFlash can also be used while running coreboot .","title":"Update EC firmware"},{"location":"variants/novacustom_nv4x/flashing_external/","text":"coreboot external flashing Intro Currently, the only supported method of external flashing is with a ch341a programmer and a Pomona SOIC-8 clip. Other external programmers are currently unsupported. Requirements: ch341a SPI programmer Pomona SOIC-8 clip with ribbon connecting cable Computer running Linux with flashrom Preparation Ensure that the EC is running updated firmware. Follow the steps outlined in EC firmware update Install Flashrom from your distribution's repositories. For Ubuntu, Debian and derivatives: sudo apt install flashrom For Fedora: sudo dnf install flashrom For Arch Linux: sudo pacman -S flashrom Create a file layout.txt with the following contents: 00000000 :00000fff fd 00500000 :00ffffff bios 00001000 :004fffff me Setup Connect the Pomona clip to the programmmer. The red wire should be connected towards the rear of the programmer (away from the USB port). Remove the bottom cover from the laptop. Disconnect the internal battery and CMOS battery. Locate the BIOS chip - the square chip located next to the Wi-Fi card, with the text AJ2001 25B127DSIG written on top of it. Attach the clip to the BIOS chip. The clip should be attached so that the red wire is aligned with the identifying dot on the in one of the corners of the chip. Once the clip is connected, connect the programmer to a computer. To test if the programmer is detected properly, run the following command: flashrom -p ch341a_spi The output should contain the following text: Found GigaDevice flash chip \"GD25Q128B\" ( 16384 kB, SPI ) on linux_spi. Found GigaDevice flash chip \"GD25Q128C\" ( 16384 kB, SPI ) on linux_spi. Multiple flash chip definitions match the detected chip ( s ) : \"GD25Q128B\" , \"GD25Q128C\" If it doesn't, disconnect the programmer from the PC, detach the clip and re-attach everything again. The final setup should look like in the picture below: Reading from the flash Before writing anything to the flash, it's important to always make a backup. Read the flash 3 times and ensure the backup is correct: flashrom -p ch341a_spi -c GD25B128B/GD25Q128B -r backup1.rom flashrom -p ch341a_spi -c GD25B128B/GD25Q128B -r backup2.rom flashrom -p ch341a_spi -c GD25B128B/GD25Q128B -r backup3.rom md5sum backup1.rom backup2.rom backup3.rom The output of the last command should contain 3 identical hashes. 6e5599d95ad03eb9ead7390bd1be4146 backup1.rom 6e5599d95ad03eb9ead7390bd1be4146 backup2.rom 6e5599d95ad03eb9ead7390bd1be4146 backup3.rom Your hashes may be different to these depending on the current flash contents, but they must be identical to each other. If they're not identical, reseat the Pomona clip and try again. Once the backups are verified, save and store one of the backup*.rom files securely. Writing to the flash Once you have the backups saved, proceed to flashing the chip - replace [path] with the path to the binary you want to write - e.g. build/coreboot.rom flashrom -p ch341a_spi -c GD25B128B/GD25Q128B -w [ path ] -l layout.txt -i bios flashrom will read the flash, erase it, write the new image and verify that it's written correctly. If the flash was successful, the output will contain the text VERIFIED .","title":"Flashing with external programmer"},{"location":"variants/novacustom_nv4x/flashing_external/#coreboot-external-flashing","text":"","title":"coreboot external flashing"},{"location":"variants/novacustom_nv4x/flashing_external/#intro","text":"Currently, the only supported method of external flashing is with a ch341a programmer and a Pomona SOIC-8 clip. Other external programmers are currently unsupported. Requirements: ch341a SPI programmer Pomona SOIC-8 clip with ribbon connecting cable Computer running Linux with flashrom","title":"Intro"},{"location":"variants/novacustom_nv4x/flashing_external/#preparation","text":"Ensure that the EC is running updated firmware. Follow the steps outlined in EC firmware update Install Flashrom from your distribution's repositories. For Ubuntu, Debian and derivatives: sudo apt install flashrom For Fedora: sudo dnf install flashrom For Arch Linux: sudo pacman -S flashrom Create a file layout.txt with the following contents: 00000000 :00000fff fd 00500000 :00ffffff bios 00001000 :004fffff me","title":"Preparation"},{"location":"variants/novacustom_nv4x/flashing_external/#setup","text":"Connect the Pomona clip to the programmmer. The red wire should be connected towards the rear of the programmer (away from the USB port). Remove the bottom cover from the laptop. Disconnect the internal battery and CMOS battery. Locate the BIOS chip - the square chip located next to the Wi-Fi card, with the text AJ2001 25B127DSIG written on top of it. Attach the clip to the BIOS chip. The clip should be attached so that the red wire is aligned with the identifying dot on the in one of the corners of the chip. Once the clip is connected, connect the programmer to a computer. To test if the programmer is detected properly, run the following command: flashrom -p ch341a_spi The output should contain the following text: Found GigaDevice flash chip \"GD25Q128B\" ( 16384 kB, SPI ) on linux_spi. Found GigaDevice flash chip \"GD25Q128C\" ( 16384 kB, SPI ) on linux_spi. Multiple flash chip definitions match the detected chip ( s ) : \"GD25Q128B\" , \"GD25Q128C\" If it doesn't, disconnect the programmer from the PC, detach the clip and re-attach everything again. The final setup should look like in the picture below:","title":"Setup"},{"location":"variants/novacustom_nv4x/flashing_external/#reading-from-the-flash","text":"Before writing anything to the flash, it's important to always make a backup. Read the flash 3 times and ensure the backup is correct: flashrom -p ch341a_spi -c GD25B128B/GD25Q128B -r backup1.rom flashrom -p ch341a_spi -c GD25B128B/GD25Q128B -r backup2.rom flashrom -p ch341a_spi -c GD25B128B/GD25Q128B -r backup3.rom md5sum backup1.rom backup2.rom backup3.rom The output of the last command should contain 3 identical hashes. 6e5599d95ad03eb9ead7390bd1be4146 backup1.rom 6e5599d95ad03eb9ead7390bd1be4146 backup2.rom 6e5599d95ad03eb9ead7390bd1be4146 backup3.rom Your hashes may be different to these depending on the current flash contents, but they must be identical to each other. If they're not identical, reseat the Pomona clip and try again. Once the backups are verified, save and store one of the backup*.rom files securely.","title":"Reading from the flash"},{"location":"variants/novacustom_nv4x/flashing_external/#writing-to-the-flash","text":"Once you have the backups saved, proceed to flashing the chip - replace [path] with the path to the binary you want to write - e.g. build/coreboot.rom flashrom -p ch341a_spi -c GD25B128B/GD25Q128B -w [ path ] -l layout.txt -i bios flashrom will read the flash, erase it, write the new image and verify that it's written correctly. If the flash was successful, the output will contain the text VERIFIED .","title":"Writing to the flash"},{"location":"variants/novacustom_nv4x/flashing_internal/","text":"Dasharo internal flashing (Ubuntu 20.04) Intro Flashing Dasharo can be done from Linux using flashrom with the internal programmer. This document describes the process of building, installing and running flashrom on Ubuntu 20.04. Pre-setup Ensure that the EC is running updated firmware. Follow the steps outlined in EC firmware update Build flashrom Currently, the latest flashrom release lacks support for Tiger Lake-U internal flashing. Because of this, we need to build flashrom from source. Install build dependencies: apt install git build-essential debhelper pkg-config libpci-dev libusb-1.0-0-dev libftdi1-dev meson Obtain source code: git clone https://review.coreboot.org/flashrom.git cd flashrom Build flashrom: make sudo make install Reading flash contents To read from the flash and save them to a file ( dump.rom ), execute the following command: flashrom -p internal -r dump.rom Flashing Dasharo To flash Dasharo to the laptop, execute the following command - replace [path] with the path to the Dasharo image you want to flash, e.g. build/coreboot.rom . If stock firmware or Dasharo version below v1.1.0 is currently installed: flashrom -p internal -w [ path ] --ifd -i bios If version v1.1.0 or higher is currently installed, only the RW_SECTION_A partition of the flash needs to be updated. Flash it using the following command: flashrom -p internal -w [ path ] --fmap -i RW_SECTION_A This command also preserves the bootsplash, UEFI settings and the boot order.","title":"Flashing with internal programmer"},{"location":"variants/novacustom_nv4x/flashing_internal/#dasharo-internal-flashing-ubuntu-2004","text":"","title":"Dasharo internal flashing (Ubuntu 20.04)"},{"location":"variants/novacustom_nv4x/flashing_internal/#intro","text":"Flashing Dasharo can be done from Linux using flashrom with the internal programmer. This document describes the process of building, installing and running flashrom on Ubuntu 20.04.","title":"Intro"},{"location":"variants/novacustom_nv4x/flashing_internal/#pre-setup","text":"Ensure that the EC is running updated firmware. Follow the steps outlined in EC firmware update","title":"Pre-setup"},{"location":"variants/novacustom_nv4x/flashing_internal/#build-flashrom","text":"Currently, the latest flashrom release lacks support for Tiger Lake-U internal flashing. Because of this, we need to build flashrom from source. Install build dependencies: apt install git build-essential debhelper pkg-config libpci-dev libusb-1.0-0-dev libftdi1-dev meson Obtain source code: git clone https://review.coreboot.org/flashrom.git cd flashrom Build flashrom: make sudo make install","title":"Build flashrom"},{"location":"variants/novacustom_nv4x/flashing_internal/#reading-flash-contents","text":"To read from the flash and save them to a file ( dump.rom ), execute the following command: flashrom -p internal -r dump.rom","title":"Reading flash contents"},{"location":"variants/novacustom_nv4x/flashing_internal/#flashing-dasharo","text":"To flash Dasharo to the laptop, execute the following command - replace [path] with the path to the Dasharo image you want to flash, e.g. build/coreboot.rom . If stock firmware or Dasharo version below v1.1.0 is currently installed: flashrom -p internal -w [ path ] --ifd -i bios If version v1.1.0 or higher is currently installed, only the RW_SECTION_A partition of the flash needs to be updated. Flash it using the following command: flashrom -p internal -w [ path ] --fmap -i RW_SECTION_A This command also preserves the bootsplash, UEFI settings and the boot order.","title":"Flashing Dasharo"},{"location":"variants/novacustom_nv4x/hardware-matrix/","text":"Hardware configuration matrix - NovaCustom NV4X Introduction This document describes the hardware configurations used for validation of the coreboot port on the NovaCustom NV4X laptop. NV41MZ Component Description CPU Intel(R) Core(TM) i7-1165G7 Internal Cooling RAM Slot 1: KVR29S21S6/8 Slot 2: KVR29S21S6/8 SSD Samsung 980 PRO NVMe 500 GB Flash memory GigaDevice 25B127DSIG 16 MB Network Local network wired connection Internal devices 1. 1920x1080 14 inch screen 2. Internal keyboard with LED backlight 3. Touchpad 4. Camera 5. Audio subsystem Attached devices 1. SanDisk Ultra USB 3.0 64 GB 2. SanDisk Ultra Flair USB 3.0 16 GB 3. Kingston DataTraveler 3.1Gen1 16 GB 4. SanDisk Ultra microSD HC I 16 GB + SD Adapter 5. Logitech, Inc. Keyboard K120 6. Pi-KVM virtual mouse and keyboard 7. Expansion Dock Type-C Power Supply Chicony 65 W Power Control N/A Remote Testing Environment OpenSSH_8.2p1 OpenSSL 1.1.1f NV41MB Component Description CPU Intel(R) Core(TM) i7-1165G7 Internal Cooling GPU NVIDIA GeForce GTX1650 4 GB RAM Slot 1: KVR29S21D8/32 Slot 2: KVR29S21D8/32 SSD Samsung 980 PRO NVMe 250 GB Flash memory GigaDevice 25B127DSIG 16 MB Network Local network wired connection Internal devices 1. 1920x1080 14 inch screen 2. Internal keyboard with LED backlight 3. Touchpad 4. Camera 5. Audio subsystem Attached devices 1. SanDisk Ultra USB 3.0 64 GB 2. SanDisk Ultra Flair USB 3.0 16 GB 3. Kingston DataTraveler 3.1Gen1 16 GB 4. SanDisk Ultra microSD HC I 16 GB + SD Adapter 5. Logitech, Inc. Keyboard K120 6. Pi-KVM virtual mouse and keyboard 7. Expansion Dock Type-C Power Supply Chicony 90 W Power Control N/A Remote Testing Environment OpenSSH_8.2p1 OpenSSL 1.1.1f","title":"Hardware Configuration Matrix"},{"location":"variants/novacustom_nv4x/hardware-matrix/#hardware-configuration-matrix-novacustom-nv4x","text":"","title":"Hardware configuration matrix - NovaCustom NV4X"},{"location":"variants/novacustom_nv4x/hardware-matrix/#introduction","text":"This document describes the hardware configurations used for validation of the coreboot port on the NovaCustom NV4X laptop.","title":"Introduction"},{"location":"variants/novacustom_nv4x/hardware-matrix/#nv41mz","text":"Component Description CPU Intel(R) Core(TM) i7-1165G7 Internal Cooling RAM Slot 1: KVR29S21S6/8 Slot 2: KVR29S21S6/8 SSD Samsung 980 PRO NVMe 500 GB Flash memory GigaDevice 25B127DSIG 16 MB Network Local network wired connection Internal devices 1. 1920x1080 14 inch screen 2. Internal keyboard with LED backlight 3. Touchpad 4. Camera 5. Audio subsystem Attached devices 1. SanDisk Ultra USB 3.0 64 GB 2. SanDisk Ultra Flair USB 3.0 16 GB 3. Kingston DataTraveler 3.1Gen1 16 GB 4. SanDisk Ultra microSD HC I 16 GB + SD Adapter 5. Logitech, Inc. Keyboard K120 6. Pi-KVM virtual mouse and keyboard 7. Expansion Dock Type-C Power Supply Chicony 65 W Power Control N/A Remote Testing Environment OpenSSH_8.2p1 OpenSSL 1.1.1f","title":"NV41MZ"},{"location":"variants/novacustom_nv4x/hardware-matrix/#nv41mb","text":"Component Description CPU Intel(R) Core(TM) i7-1165G7 Internal Cooling GPU NVIDIA GeForce GTX1650 4 GB RAM Slot 1: KVR29S21D8/32 Slot 2: KVR29S21D8/32 SSD Samsung 980 PRO NVMe 250 GB Flash memory GigaDevice 25B127DSIG 16 MB Network Local network wired connection Internal devices 1. 1920x1080 14 inch screen 2. Internal keyboard with LED backlight 3. Touchpad 4. Camera 5. Audio subsystem Attached devices 1. SanDisk Ultra USB 3.0 64 GB 2. SanDisk Ultra Flair USB 3.0 16 GB 3. Kingston DataTraveler 3.1Gen1 16 GB 4. SanDisk Ultra microSD HC I 16 GB + SD Adapter 5. Logitech, Inc. Keyboard K120 6. Pi-KVM virtual mouse and keyboard 7. Expansion Dock Type-C Power Supply Chicony 90 W Power Control N/A Remote Testing Environment OpenSSH_8.2p1 OpenSSL 1.1.1f","title":"NV41MB"},{"location":"variants/novacustom_nv4x/lvfs_report/","text":"NovaCustom fwupd/LVFS support service Introduction This document contains the report of the discovery of the most appropriate fwupd/LVFS firmware update method, including potential risks and roadblocks. Device specification NovaCustom NV4x system firmware Intel i7-1165G7 (Tiger Lake ULV platform) Samsung 980PRO NVMe SSD 2x SO-DIMM DDR4 system memory Optional NVIDIA discrete graphics Dasharo coreboot-based firmware Firmware stored on a SPI flash chip, flashable internally via flashrom Update protocol The device is flashable internally via flashrom No special unlocks necessary for flashing the required BIOS flash portions (only requirement is that UEFI Secure Boot is disabled while updating) Feasibility analysis Tiger Lake-U is supported in flashrom Present since this commit , not yet released to stable as of 14.01.2022 flashrom is supported in fwupd flashrom plugin is enabled by default in many common desktop Linux distributions, including Ubuntu (starting with 21.10) and Arch Linux enabling a device in the flashrom plugin is a matter of adding device-specific entries to the plugin quirk list Potential risk: vboot support in fwupd flashrom supports flashing vboot rw slots, which are coreboot images located within the BIOS partition of the flash however, fwupd only implements flashing the entire BIOS region of the SPI flash, which includes other firmware components such as vboot keys, vboot recovery partition and user settings the device currently has vboot partially implemented - the BIOS flash is not protected and the binaries are signed with (public) developer keys this means we can currently update the BIOS using the traditional fwupd update path once we decide to change the vboot keys and lock down the rest of the, flash, proper vboot support will need to be implemented in fwupd until then, it will not be possible to enable vboot fully Further steps: Vboot support In case full vboot support in fwupd is desired, the following are currently missing and need to be implemented: Support reading and processing VBNV (Vboot non-volatile store) data in fwupd: this store contains information about the current vboot state, e.g. currently booted slot (A/B/Recovery), recovery reason, firmware signature verification status. This information is stored in CMOS, but the exact offset varies by device - so a method for determining the offset is also required. For Google Chromebooks, this offset is exposed in a Chromebook-specific ACPI device which we cannot use in non-Chromebook device. An alternative interface or possibly a quirk in fwupd's flashrom plugin will need to be added (though this approach is not preferred by fwupd maintainers). Support for flashing fmap regions in fwupd's flashrom plugin: currently, fwupd only attempts to read flash layout from the Intel Flash Descriptor located in the flash. This only allows fwupd to flash the entire BIOS region, while vboot requires only a portion of the BIOS partition to be updated at a given time, with some of the BIOS partition being read-only. This means that with vboot fully enabled, updating will fail by attempting to write to a read-only portion of the flash. Vboot partitions (slots) are a subset of the bios partition and are defined in FMAP (flashmap). Support for it will need to be implemented in fwupd (possible by utilizing libflashrom). Additionally, some user settings like boot order and setup options are stored in a separate FMAP region, so implementing FMAP support in fwupd will allow us to preserve them across firmware updates. Vboot A/B slot support In Google Chromebooks, the firmware updater only updates one slot at a time and if it succeeds (the device reboots into it successfully and works stably), then it will also update the other slot to the same (now confirmed good) firmware. fwupd does not currently support anything like this, so support for it will also need to be implemented. Prior work: fwupd #1370 fwupd #1481 LKML thread","title":"LVFS report"},{"location":"variants/novacustom_nv4x/lvfs_report/#novacustom-fwupdlvfs-support-service","text":"","title":"NovaCustom fwupd/LVFS support service"},{"location":"variants/novacustom_nv4x/lvfs_report/#introduction","text":"This document contains the report of the discovery of the most appropriate fwupd/LVFS firmware update method, including potential risks and roadblocks.","title":"Introduction"},{"location":"variants/novacustom_nv4x/openness_analysis/","text":"Intro This document aims to compare the openness of Dasharo Firmware and Insyde BIOS. There is an ongoing discussion about the methodology of the openness metric. BIOS versions used in the analysis Dasharo coreboot v0.5.0 Insyde BIOS Insyde BIOS In the case of the Insyde bios, the entire image should be considered proprietary. There are several parts of the image that have a well-known structure or make use of a public standard. However, to decode these structures, one needs to employ reverse-engineering tools and techniques to know what structures are present. Dasharo BIOS CBFS image size (bytes) Is it open-source? cbfs master header 20h Yes fallback/romstage 14770h Yes cpu_microcode_blob.bin 31C00h No intel_fit 50h Yes fallback/ramstage 1E626h Yes config 579h Yes revision 351h Yes build_info 5Dh Yes fallback/dsdt.aml 6233h Yes vbt.bin 51Ch Yes (empty) 1E4h N/A fspm.bin 9F000h No cmos_layout.bin 22Ch Yes (empty) D24h N/A fsps.bin 43676h No fallback/postcar 8F24h Yes fallback/payload 1771C5h Yes fallback/verstage 12C80h Yes (empty) 10E5E4h N/A bootblock 74C0h Yes Summary 3F7A33h In 62.9% Open and closed source images are in the table below. type summarised size Percent open-source 1D42D1h 62.9% closed-source 114276h 37.1% empty (not included) 10F4ECh Whole flash image region size open-source percent (bytes) descriptor 1000h 0% ME 4FF000h 0% BIOS B00000h 62.9% Summary 1000000h 43.2% Summary image open-source percent (bytes) Insyde 0% Dasharo 43.2%","title":"Openness score"},{"location":"variants/novacustom_nv4x/openness_analysis/#intro","text":"This document aims to compare the openness of Dasharo Firmware and Insyde BIOS. There is an ongoing discussion about the methodology of the openness metric.","title":"Intro"},{"location":"variants/novacustom_nv4x/openness_analysis/#bios-versions-used-in-the-analysis","text":"Dasharo coreboot v0.5.0 Insyde BIOS","title":"BIOS versions used in the analysis"},{"location":"variants/novacustom_nv4x/openness_analysis/#insyde-bios","text":"In the case of the Insyde bios, the entire image should be considered proprietary. There are several parts of the image that have a well-known structure or make use of a public standard. However, to decode these structures, one needs to employ reverse-engineering tools and techniques to know what structures are present.","title":"Insyde BIOS"},{"location":"variants/novacustom_nv4x/openness_analysis/#dasharo-bios","text":"","title":"Dasharo BIOS"},{"location":"variants/novacustom_nv4x/openness_analysis/#summary","text":"image open-source percent (bytes) Insyde 0% Dasharo 43.2%","title":"Summary"},{"location":"variants/novacustom_nv4x/overview/","text":"Overview Releases - list of all releases Building manual - how to build Dasharo compatible with NovaCustom NV4x Installation manual - how to install Dasharo firmware on NovaCustom NV4x Updating firmware using fwupd - fwupd usage instructions Hardware configuration matrix - definition of hardware configuration used during validation Test matrix - validation scope for NovaCustom NV4x Post installation steps - Post-installation tweaks","title":"Overview"},{"location":"variants/novacustom_nv4x/overview/#overview","text":"Releases - list of all releases Building manual - how to build Dasharo compatible with NovaCustom NV4x Installation manual - how to install Dasharo firmware on NovaCustom NV4x Updating firmware using fwupd - fwupd usage instructions Hardware configuration matrix - definition of hardware configuration used during validation Test matrix - validation scope for NovaCustom NV4x Post installation steps - Post-installation tweaks","title":"Overview"},{"location":"variants/novacustom_nv4x/post_install/","text":"Post-installation setup This document contains extra steps to perform after installing Dasharo in order to enable full functionality. Touchpad hotkey enablement (Linux) The touchpad hotkey needs extra setup to function correctly under Linux. To enable the touchpad hotkey to work under Linux, follow the steps below: Create a file /etc/udev/hwdb.d/60-keyboard.hwdb with the following contents: evdev:atkbd:dmi:bvn*:bvr*:svnNotebook:pnNV4XMB,ME,MZ:* KEYBOARD_KEY_f7 = 191 KEYBOARD_KEY_f8 = 191 Execute the following commands: sudo systemd-hwdb update sudo udevadm trigger After executing these steps, it should be possible to enable and disable the touchpad using the touchpad hotkey (Fn+F1) on the keyboard when using GNOME.","title":"Post-installation steps"},{"location":"variants/novacustom_nv4x/post_install/#post-installation-setup","text":"This document contains extra steps to perform after installing Dasharo in order to enable full functionality.","title":"Post-installation setup"},{"location":"variants/novacustom_nv4x/post_install/#touchpad-hotkey-enablement-linux","text":"The touchpad hotkey needs extra setup to function correctly under Linux. To enable the touchpad hotkey to work under Linux, follow the steps below: Create a file /etc/udev/hwdb.d/60-keyboard.hwdb with the following contents: evdev:atkbd:dmi:bvn*:bvr*:svnNotebook:pnNV4XMB,ME,MZ:* KEYBOARD_KEY_f7 = 191 KEYBOARD_KEY_f8 = 191 Execute the following commands: sudo systemd-hwdb update sudo udevadm trigger After executing these steps, it should be possible to enable and disable the touchpad using the touchpad hotkey (Fn+F1) on the keyboard when using GNOME.","title":"Touchpad hotkey enablement (Linux)"},{"location":"variants/novacustom_nv4x/releases/","text":"NovaCustom NV4X Dasharo Release Notes Following Release Notes describe status of Open Source Firmware development for NovaCustom NV4X For details about our release process please read Dasharo Standard Release Process . Subscribe to NovaCustom NV4X Dasharo Release Newsletter Test results for this platform can be found here . v1.2.1 - 2022-06-23 Fixed cbfstool logo replacement not working on NV4x v1.2.0 Known issues Custom fan curve after suspend UCM-UCSI ACPI device displays an error in Windows Device Manager USB4 Root Device Router device displays an error in Windows 11 Device Manager Windows 10 SD card reader driver needs manual installation on NV41MB Low level interfering crackling/popping of the speakers while playing no sound Laptop cannot output video via the Tunderbolt 4 USB Type-C port Binaries novacustom_nv4x_v1.2.1.rom sha256 sha256.sig See how to verify signatures on this video SBOM (Software Bill of Materials) coreboot based on e3e965b1 revision baada726 edk2 based on 2020.03.17 revision cad23725 Blobs based on v1.0 revision 5b0453b6 v1.2.0 - 2022-06-10 Added Renamed device to NovaCustom NV4x Fixed Wake from suspend doesn't work with certain SSDs CVE-2022-29264 SMM loader vulnerability Fix BIOS vendor name in SMBIOS Known issues Custom fan curve after suspend UCM-UCSI ACPI device displays an error in Windows Device Manager USB4 Root Device Router device displays an error in Windows 11 Device Manager Windows 10 SD card reader driver needs manual installation on NV41MB Low level interfering crackling/popping of the speakers while playing no sound Laptop cannot output video via the Tunderbolt 4 USB Type-C port Binaries novacustom_nv4x_v1.2.0.rom sha256 sha256.sig See how to verify signatures on this video SBOM (Software Bill of Materials) coreboot based on e3e965b1 revision baada726 edk2 based on 2020.03.17 revision cad23725 Blobs based on v1.0 revision 5b0453b6 v1.1.0 - 2022-03-23 Added Add Dasharo Tools Suite network boot integration Add a persistent bootlogo implementation Known issues UCM-UCSI ACPI device displays an error in Windows Device Manager USB4 Root Device Router device displays an error in Windows 11 Device Manager Windows 10 SD card reader driver needs manual installation on NV41MB Low level interfering crackling/popping of the speakers while playing no sound Laptop cannot output video via the Tunderbolt 4 USB Type-C port Binaries clevo_nv41mz_v1.1.0.rom sha256 sha256.sig SBOM (Software Bill of Materials) coreboot based on ae9a8447 revision 0722fdf0 edk2 based on 2020.03.17 revision ec6805c2 Blobs based on v1.0 revision 39d95913 v1.0.1 - 2022-03-01 Added Change DMI fields to match previous Insyde firmware Hide unknown ACPI devices Set correct Realtek HD Audio subsystem ID Set correct ACPI path for the TPM Set TPM IRQ in a manner understood by Windows Removed Removed proprietary blobs from built coreboot images Fixed Updating firmware using fwupd MIC-in phone jack not working This PC can't run Windows 11 error while installing Windows 11 from a USB pen drive Known issues Custom fan curve is not functional after suspend UCM-UCSI ACPI device displays an error in Windows Device Manager USB4 Root Device Router device displays an error in Windows 11 Device Manager Windows 10 SD card reader driver needs manual installation on NV41MB Low level interfering crackling/popping of the speakers while playing no sound Laptop cannot output video via the Tunderbolt 4 USB Type-C port Binaries clevo_nv41mz_v1.0.1.rom sha256 sha256.sig SBOM (Software Bill of Materials) coreboot based on ae9a8447 revision 3a3808f9 edk2 based on 2020.03.17 revision e0334c22 Blobs based on v1.0 revision 39d95913 v1.0.0 - 2022-01-19 Added Documentation for touchpad hotkey enablement on Linux Removed Removed proprietary blobs from built coreboot images Fixed The touchpad ON/OFF switch Fn key is not functional Charging indicator displays wrong state if power adapter was unplugged while in sleep mode Bluetooth does not work under Windows Known issues Unable to download the system by using iPXE Laptop cannot output video via the Tunderbolt 4 USB Type-C port Windows 10 SD card reader driver needs manual installation on NV41MB Binaries clevo_nv41mz_v1.0.0.rom sha256 sha256.sig SBOM (Software Bill of Materials) coreboot based on ae9a8447 revision e995fc1c edk2 based on 2020.03.17 revision 59ae285f Blobs based on v1.0 revision 39d95913 v0.5.0 - 2021-11-19 Added vboot Verified Boot TPM Measured Boot Custom fan curve Microcode for Tiger Lake stepping 0x2 Documentation for EC firmware update Changed Disabled unused DPTF device Fixed Performance drop when the power adaptor is disconnected High Nvidia GPU energy draw at idle in Windows Known issues Unable to download the system by using iPXE Laptop cannot output video via the Tunderbolt 4 USB Type-C port The touchpad ON/OFF switch Fn key is not functional Binaries dasharo_clevo_nv41mz_v0.5.0.rom sha256 sha256.sig SBOM (Software Bill of Materials) coreboot based on ae9a8447 revision 7d439573 EDK2 based on 2020.03.17 revision bfd3d1a2 Blobs based on v1.0 revision 462f0c80 v0.4.0 - 2021-10-26 Added Added full support for sleep mode (s0ix / Modern Standby) Added support for NV41MB model Added support for nvidia discrete graphics (doesn't power off in Windows yet) Changed Fixed regression with non-funtional airplane mode hotkey on Windows Disabled legacy 8254 timer for lower power draw Fixed Sleep mode is not functional The camera ON/OFF switch Fn key is not functional Known issues Unable to download the system by using iPXE Laptop cannot output video via the Tunderbolt 4 USB Type-C port High Nvidia GPU energy draw at idle in Windows Performance drop when the power adaptor is disconnected The touchpad ON/OFF switch Fn key is not functional Binaries dasharo_clevo_nv41mz_v0.4.0.rom sha256 sha256.sig SBOM (Software Bill of Materials) coreboot based on ae9a8447 revision 03972293 EDK2 based on 2020.03.17 revision bfd3d1a2 Blobs based on v1.0 revision 462f0c80 v0.3.0 - 2021-10-11 Added Support for discrete TPM USB Type-C ACPI support (UCSI) Improved runtime power management for SSD (reduces power usage while in sleep) Added partial sleep support (system saves power, but fans still spin) Changed Rebased on coreboot revision ae9a8447 Known issues Sleep mode is not functional The camera ON/OFF switch Fn key is not functional The touchpad ON/OFF switch Fn key is not functional Binaries dasharo_clevo_nv41mz_v0.3.0.rom sha256 sha256.sig SBOM (Software Bill of Materials) coreboot based on ae9a8447 revision v0.3.0 EDK2 based on 2020.03.17 revision bfd3d1a2 Blobs based on v1.0 revision 462f0c80 v0.2.1 - 2021-9-29 Added Integrated graphics backlight configuration for Windows Changed Updated the Video Bios Table Fixed Screen brightness is stuck at 0% in the Windows Installer Known issues Sleep mode is not functional The camera ON/OFF switch Fn key is not functional The touchpad ON/OFF switch Fn key is not functional Binaries dasharo_clevo_nv41mz_v0.2.1.rom sha256 sha256.sig SBOM (Software Bill of Materials) coreboot based on 4.14 revision 43c9604b EDK2 based on 2020.03.17 revision bfd3d1a2 Blobs based on v1.0 revision 462f0c80 v0.2.0 - 2021-9-24 Added UEFI Secure Boot support UEFI Shell selectable in boot menu iPXE selectable in boot menu NovaCustom boot logo Customized boot menu keys Customized setup menu keys Support for backlight hotkey in Windows Preserve boot order settings after Dasharo update Changed Replaced CorebootPayloadPkg with Dasharo UEFIPayloadPkg Changed the behavior of airplane mode to match stock firmware (now it can be disabled in software) Known issues Screen brightness is stuck at 0% in the Windows Installer Sleep mode is not functional The camera ON/OFF switch Fn key is not functional The touchpad ON/OFF switch Fn key is not functional Binaries dasharo_clevo_nv41mz_v0.2.0.rom sha256 sha256.sig SBOM (Software Bill of Materials) coreboot based on 4.14 revision ff1c6572 EDK2 based on 2020.03.17 revision bfd3d1a2 Blobs based on v1.0 revision 462f0c80 v0.1.2 - 2021-08-31 Added Clevo NV41MZ platform support Clevo IT5570 EC support UEFI boot support configurable boot order configurable boot options Integreated graphics initialization for internal LCD (eDP) and external HDMI port Binaries clevo_nv41mz_v0.1.2.rom sha256 sha256.sig All in one zip SBOM (Software Bill of Materials) coreboot 4.14 (with additional commits for Clevo NV41MZ board support) EDK2 Binary blobs blobs extracted from the vendor firmware","title":"Releases"},{"location":"variants/novacustom_nv4x/releases/#novacustom-nv4x-dasharo-release-notes","text":"Following Release Notes describe status of Open Source Firmware development for NovaCustom NV4X For details about our release process please read Dasharo Standard Release Process . Subscribe to NovaCustom NV4X Dasharo Release Newsletter Test results for this platform can be found here .","title":"NovaCustom NV4X Dasharo Release Notes"},{"location":"variants/novacustom_nv4x/releases/#v121-2022-06-23","text":"","title":"v1.2.1 - 2022-06-23"},{"location":"variants/novacustom_nv4x/releases/#v120-2022-06-10","text":"","title":"v1.2.0 - 2022-06-10"},{"location":"variants/novacustom_nv4x/releases/#v110-2022-03-23","text":"","title":"v1.1.0 - 2022-03-23"},{"location":"variants/novacustom_nv4x/releases/#v101-2022-03-01","text":"","title":"v1.0.1 - 2022-03-01"},{"location":"variants/novacustom_nv4x/releases/#v100-2022-01-19","text":"","title":"v1.0.0 - 2022-01-19"},{"location":"variants/novacustom_nv4x/releases/#v050-2021-11-19","text":"","title":"v0.5.0 - 2021-11-19"},{"location":"variants/novacustom_nv4x/releases/#v040-2021-10-26","text":"","title":"v0.4.0 - 2021-10-26"},{"location":"variants/novacustom_nv4x/releases/#v030-2021-10-11","text":"","title":"v0.3.0 - 2021-10-11"},{"location":"variants/novacustom_nv4x/releases/#v021-2021-9-29","text":"","title":"v0.2.1 - 2021-9-29"},{"location":"variants/novacustom_nv4x/releases/#v020-2021-9-24","text":"","title":"v0.2.0 - 2021-9-24"},{"location":"variants/novacustom_nv4x/releases/#v012-2021-08-31","text":"","title":"v0.1.2 - 2021-08-31"},{"location":"variants/novacustom_nv4x/test-matrix/","text":"Test matrix - NovaCustom NV41 About The test matrix is used to determine the scope of tests which the DUT is subjected from before the release of the new binary. Test matrix - NovaCustom NV41MZ Module: Dasharo compatibility No. Supported test suite Test suite ID Supported test cases 1. Memory HCL HCL All 2. UEFI compatible interface EFI All 3. Display ports and LCD support DSP DSP001.001, DSP001.002, DSP001.003, DSP002.001, DSP002.002, DSP002.003 4. Embedded Controller and Super I/O initialization ECR Without ECR021.xxx - ECR024.xxx 5. NVMe support NVM All 6. Custom logo CLG All 7. Custom boot menu key CBK All 8. USB HID and MSC Support USB All 9. Debian Stable and Ubuntu LTS support LBT All 10. UEFI Shell USH All 11. Windows booting WBT WBT001.001 12. Audio subsystem AUD All 13. USB-C/Thunderbolt UTC All 14. Network boot PXE All 15. M.2 WiFi/Bluetooth WLE All 16. SD card support SDC All 17. USB Camera verification CAM All 18. Nvidia Graphics support NVI All 19. Custom fan curve FAN All 20. SMBIOS DMI DMI002.001, DMI003.001, DMI005.001, DMI006.001, DMI007.001, DMI008.001 21. Docking station detect DUD All 22. Docking station USB devices DUB All 23. Docking station Audio DAU All 24. Docking station USB-C DUC All 25. Firmware update using fwupd FFW All 26. Firmware update using Dasharo Tools Suite FDT All Module: Dasharo security No. Supported test suite Test suite ID Supported test cases 1. TPM Support TPM All 2. Verified Boot support VBO VBO001.002, VBO002.002, VBO003.001 3. Measured Boot support MBO All 4. Secure Boot support SBO All Test matrix - NovaCustom NV41MB Module: Dasharo compatibility No. Supported test suite Test suite ID Supported test cases 1. Memory HCL HCL All 2. UEFI compatible interface EFI All 3. Display ports and LCD support DSP DSP001.001, DSP001.002, DSP001.003, DSP002.001, DSP002.002, DSP002.003 4. Embedded Controller and Super I/O initialization ECR Without ECR021.xxx - ECR024.xxx 5. NVMe support NVM All 6. Custom logo CLG All 7. Custom boot menu key CBK All 8. USB HID and MSC Support USB All 9. Debian Stable and Ubuntu LTS support LBT All 10. UEFI Shell USH All 11. Windows booting WBT WBT001.001 12. Audio subsystem AUD All 13. USB-C/Thunderbolt UTC All 14. Network boot PXE All 15. M.2 WiFi/Bluetooth WLE All 16. SD card support SDC All 17. USB Camera verification CAM All 18. Custom fan curve FAN FAN001.001 19. SMBIOS DMI DMI002.001, DMI003.001, DMI005.001, DMI006.001, DMI007.001, DMI008.001 20. Docking station detect DUD All 21. Docking station USB devices DUB All 22. Docking station Audio DAU All 23. Docking station USB-C DUC All 24. Firmware update using fwupd FFW All 25. Firmware update using Dasharo Tools Suite FDT All Module: Dasharo security No. Supported test suite Test suite ID Supported test cases 1. TPM Support TPM All 2. Verified Boot support VBO VBO001.002, VBO002.002, VBO003.001 3. Measured Boot support MBO All 4. Secure Boot support SBO All","title":"Test matrix"},{"location":"variants/novacustom_nv4x/test-matrix/#test-matrix-novacustom-nv41","text":"","title":"Test matrix - NovaCustom NV41"},{"location":"variants/novacustom_nv4x/test-matrix/#about","text":"The test matrix is used to determine the scope of tests which the DUT is subjected from before the release of the new binary.","title":"About"},{"location":"variants/novacustom_nv4x/test-matrix/#test-matrix-novacustom-nv41mz","text":"","title":"Test matrix - NovaCustom NV41MZ"},{"location":"variants/novacustom_nv4x/test-matrix/#test-matrix-novacustom-nv41mb","text":"","title":"Test matrix - NovaCustom NV41MB"},{"location":"variants/protectli_fw6/building-manual/","text":"Protectli Dasharo on FW6 - building manual Requirements Docker follow Install Docker Engine on Ubuntu follow Post-installation steps for Linux Git sudo apt-get install git Building To build Dasharo firmware image, follow the steps below: Clone the coreboot repository: git clone https://github.com/Dasharo/coreboot.git -b protectli_vault_kbl/release To build a specific version replace protectli_vault_kbl/release to protectli_vault_kbl_v1.0.x where x is the version number. Start build process (note it requires certain blobs to proceed): cd coreboot git submodule update --init --checkout # you will need to obtain the ZIP with blobs at this point unzip protectli_blobs.zip -d 3rdparty/blobs/mainboard ./build.sh fw6","title":"Building manual"},{"location":"variants/protectli_fw6/building-manual/#protectli-dasharo-on-fw6-building-manual","text":"","title":"Protectli Dasharo on FW6 - building manual"},{"location":"variants/protectli_fw6/building-manual/#requirements","text":"Docker follow Install Docker Engine on Ubuntu follow Post-installation steps for Linux Git sudo apt-get install git","title":"Requirements"},{"location":"variants/protectli_fw6/building-manual/#building","text":"To build Dasharo firmware image, follow the steps below: Clone the coreboot repository: git clone https://github.com/Dasharo/coreboot.git -b protectli_vault_kbl/release To build a specific version replace protectli_vault_kbl/release to protectli_vault_kbl_v1.0.x where x is the version number. Start build process (note it requires certain blobs to proceed): cd coreboot git submodule update --init --checkout # you will need to obtain the ZIP with blobs at this point unzip protectli_blobs.zip -d 3rdparty/blobs/mainboard ./build.sh fw6","title":"Building"},{"location":"variants/protectli_fw6/hardware-matrix/","text":"Hardware configuration matrix - Protectli FW6 Introduction This document describes the hardware configuration used for validation of the coreboot port on the Protectli FW6 firewall. Protectli FW6E Dasharo Component Description CPU IIntel(R) Celeron(TM) 3865U SSD M.2 SSD SATA: Hoodisk SSL032GTTC7-S9A-2S external SATA 2.5 inch: Goodram SSDPR-CL100-240-G2 240GB RAM CRUCIAL CT4G4SFS824A CRUCIAL CT4G4SFS824A Wireless card Qualcomm Atheros QCA9377 LTE miniPCIe card Quectel EC-20 Display HDMI 1920x1080p Ethernet 6x Intel i211 (on-board) Attached devices 1. SanDisk USB 3.2Gen1 16 GB 2. SanDisk USB 3.2Gen1 16 GB 3. SanDisk USB 3.2Gen1 16 GB 4. USB Type-C Hub Pro UCN3286 USB Keyboard DELL KB216 Power supply Channel Well Technology 12V, 7.5A 90W Protectli FW6B Dasharo Component Description CPU Intel(R) Core(TM) i3-7100U SSD M.2 SSD SATA: Hoodisk SSL032GTTC7-S9A-2S external SATA 2.5 inch: Goodram SSDPR-CL100-240-G2 240GB RAM CRUCIAL CT4G4SFS824A CRUCIAL CT4G4SFS824A Wireless card Qualcomm Atheros QCA9377 LTE miniPCIe card Quectel EC-20 Display HDMI 1920x1080p Ethernet 6x Intel i211 (on-board) Attached devices 1. SanDisk USB 3.2Gen1 16 GB 2. SanDisk USB 3.2Gen1 16 GB 3. SanDisk USB 3.2Gen1 16 GB 4. USB Type-C Hub Pro UCN3286 USB Keyboard DELL KB216 Power supply Channel Well Technology 12V, 7.5A 90W Protectli FW6C Dasharo Component Description CPU Intel(R) Core(TM) i5-7200U SSD M.2 SSD SATA: Hoodisk SSL032GTTC7-S9A-2S external SATA 2.5 inch: Goodram SSDPR-CL100-240-G2 240GB RAM CRUCIAL CT4G4SFS824A CRUCIAL CT4G4SFS824A Wireless card Qualcomm Atheros QCA9377 LTE miniPCIe card Quectel EC-20 Display HDMI 1920x1080p Ethernet 6x Intel i210 (on-board) Attached devices 1. SanDisk USB 3.2Gen1 16 GB 2. SanDisk USB 3.2Gen1 16 GB 3. SanDisk USB 3.2Gen1 16 GB 4. USB Type-C Hub Pro UCN3286 USB Keyboard DELL KB216 Power supply Channel Well Technology 12V, 7.5A 90W Protectli FW6D Dasharo Component Description CPU Intel(R) Core(TM) i5-8250U SSD M.2 SSD SATA: Hoodisk SSL032GTTC7-S9A-2S external SATA 2.5 inch: Goodram SSDPR-CL100-240-G2 240GB RAM CRUCIAL CT4G4SFS824A CRUCIAL CT4G4SFS824A Wireless card Qualcomm Atheros QCA9377 LTE miniPCIe card Quectel EC-20 Display HDMI 1920x1080p Ethernet 6x Intel i210 (on-board) Attached devices 1. SanDisk USB 3.2Gen1 16 GB 2. SanDisk USB 3.2Gen1 16 GB 3. SanDisk USB 3.2Gen1 16 GB 4. USB Type-C Hub Pro UCN3286 USB Keyboard DELL KB216 Power supply Channel Well Technology 12V, 7.5A 90W Protectli FW6E Dasharo Component Description CPU Intel(R) Core(TM) i5-8250U SSD M.2 SSD SATA: Hoodisk SSL032GTTC7-S9A-2S external SATA 2.5 inch: Goodram SSDPR-CL100-240-G2 240GB RAM CRUCIAL CT4G4SFS824A CRUCIAL CT4G4SFS824A Wireless card Qualcomm Atheros QCA9377 LTE miniPCIe card Quectel EC-20 Display HDMI 1920x1080p Ethernet 6x Intel i210 (on-board) Attached devices 1. SanDisk USB 3.2Gen1 16 GB 2. SanDisk USB 3.2Gen1 16 GB 3. SanDisk USB 3.2Gen1 16 GB 4. USB Type-C Hub Pro UCN3286 USB Keyboard DELL KB216 Power supply Channel Well Technology 12V, 7.5A 90W","title":"Hardware Configuration Matrix"},{"location":"variants/protectli_fw6/hardware-matrix/#hardware-configuration-matrix-protectli-fw6","text":"","title":"Hardware configuration matrix - Protectli FW6"},{"location":"variants/protectli_fw6/hardware-matrix/#introduction","text":"This document describes the hardware configuration used for validation of the coreboot port on the Protectli FW6 firewall.","title":"Introduction"},{"location":"variants/protectli_fw6/hardware-matrix/#protectli-fw6e-dasharo","text":"Component Description CPU IIntel(R) Celeron(TM) 3865U SSD M.2 SSD SATA: Hoodisk SSL032GTTC7-S9A-2S external SATA 2.5 inch: Goodram SSDPR-CL100-240-G2 240GB RAM CRUCIAL CT4G4SFS824A CRUCIAL CT4G4SFS824A Wireless card Qualcomm Atheros QCA9377 LTE miniPCIe card Quectel EC-20 Display HDMI 1920x1080p Ethernet 6x Intel i211 (on-board) Attached devices 1. SanDisk USB 3.2Gen1 16 GB 2. SanDisk USB 3.2Gen1 16 GB 3. SanDisk USB 3.2Gen1 16 GB 4. USB Type-C Hub Pro UCN3286 USB Keyboard DELL KB216 Power supply Channel Well Technology 12V, 7.5A 90W","title":"Protectli FW6E Dasharo"},{"location":"variants/protectli_fw6/hardware-matrix/#protectli-fw6b-dasharo","text":"Component Description CPU Intel(R) Core(TM) i3-7100U SSD M.2 SSD SATA: Hoodisk SSL032GTTC7-S9A-2S external SATA 2.5 inch: Goodram SSDPR-CL100-240-G2 240GB RAM CRUCIAL CT4G4SFS824A CRUCIAL CT4G4SFS824A Wireless card Qualcomm Atheros QCA9377 LTE miniPCIe card Quectel EC-20 Display HDMI 1920x1080p Ethernet 6x Intel i211 (on-board) Attached devices 1. SanDisk USB 3.2Gen1 16 GB 2. SanDisk USB 3.2Gen1 16 GB 3. SanDisk USB 3.2Gen1 16 GB 4. USB Type-C Hub Pro UCN3286 USB Keyboard DELL KB216 Power supply Channel Well Technology 12V, 7.5A 90W","title":"Protectli FW6B Dasharo"},{"location":"variants/protectli_fw6/hardware-matrix/#protectli-fw6c-dasharo","text":"Component Description CPU Intel(R) Core(TM) i5-7200U SSD M.2 SSD SATA: Hoodisk SSL032GTTC7-S9A-2S external SATA 2.5 inch: Goodram SSDPR-CL100-240-G2 240GB RAM CRUCIAL CT4G4SFS824A CRUCIAL CT4G4SFS824A Wireless card Qualcomm Atheros QCA9377 LTE miniPCIe card Quectel EC-20 Display HDMI 1920x1080p Ethernet 6x Intel i210 (on-board) Attached devices 1. SanDisk USB 3.2Gen1 16 GB 2. SanDisk USB 3.2Gen1 16 GB 3. SanDisk USB 3.2Gen1 16 GB 4. USB Type-C Hub Pro UCN3286 USB Keyboard DELL KB216 Power supply Channel Well Technology 12V, 7.5A 90W","title":"Protectli FW6C Dasharo"},{"location":"variants/protectli_fw6/hardware-matrix/#protectli-fw6d-dasharo","text":"Component Description CPU Intel(R) Core(TM) i5-8250U SSD M.2 SSD SATA: Hoodisk SSL032GTTC7-S9A-2S external SATA 2.5 inch: Goodram SSDPR-CL100-240-G2 240GB RAM CRUCIAL CT4G4SFS824A CRUCIAL CT4G4SFS824A Wireless card Qualcomm Atheros QCA9377 LTE miniPCIe card Quectel EC-20 Display HDMI 1920x1080p Ethernet 6x Intel i210 (on-board) Attached devices 1. SanDisk USB 3.2Gen1 16 GB 2. SanDisk USB 3.2Gen1 16 GB 3. SanDisk USB 3.2Gen1 16 GB 4. USB Type-C Hub Pro UCN3286 USB Keyboard DELL KB216 Power supply Channel Well Technology 12V, 7.5A 90W","title":"Protectli FW6D Dasharo"},{"location":"variants/protectli_fw6/hardware-matrix/#protectli-fw6e-dasharo_1","text":"Component Description CPU Intel(R) Core(TM) i5-8250U SSD M.2 SSD SATA: Hoodisk SSL032GTTC7-S9A-2S external SATA 2.5 inch: Goodram SSDPR-CL100-240-G2 240GB RAM CRUCIAL CT4G4SFS824A CRUCIAL CT4G4SFS824A Wireless card Qualcomm Atheros QCA9377 LTE miniPCIe card Quectel EC-20 Display HDMI 1920x1080p Ethernet 6x Intel i210 (on-board) Attached devices 1. SanDisk USB 3.2Gen1 16 GB 2. SanDisk USB 3.2Gen1 16 GB 3. SanDisk USB 3.2Gen1 16 GB 4. USB Type-C Hub Pro UCN3286 USB Keyboard DELL KB216 Power supply Channel Well Technology 12V, 7.5A 90W","title":"Protectli FW6E Dasharo"},{"location":"variants/protectli_fw6/installation-manual/","text":"Protectli Dasharo on FW6 - installation manual Flashing coreboot can be done from Linux using flashrom with the internal programmer. This document describes the process of building, installing and running flashrom on Ubuntu 20.04. Installing flashrom Your distribution will need at least flashrom v1.0. sudo apt install flashrom Reading flash contents Always prepare a backup of the current firmware image. To read from the flash and save them to a file ( dump.rom ), execute the following command: sudo flashrom -p internal -r dump.rom Flashing Dasharo flashrom -p internal -w [ path ] --ifd -i bios To flash Dasharo on the platform, execute the following command - replace [path] with the path to the Dasharo image you want to flash, e.g. protectli_fw6_DF_v1.0.14.rom . sudo flashrom -p internal -w protectli_fw6_DF_v1.0.14.rom --ifd -i bios After successful operation reboot the platform.","title":"Installation manual"},{"location":"variants/protectli_fw6/installation-manual/#protectli-dasharo-on-fw6-installation-manual","text":"Flashing coreboot can be done from Linux using flashrom with the internal programmer. This document describes the process of building, installing and running flashrom on Ubuntu 20.04.","title":"Protectli Dasharo on FW6 - installation manual"},{"location":"variants/protectli_fw6/installation-manual/#installing-flashrom","text":"Your distribution will need at least flashrom v1.0. sudo apt install flashrom","title":"Installing flashrom"},{"location":"variants/protectli_fw6/installation-manual/#reading-flash-contents","text":"Always prepare a backup of the current firmware image. To read from the flash and save them to a file ( dump.rom ), execute the following command: sudo flashrom -p internal -r dump.rom","title":"Reading flash contents"},{"location":"variants/protectli_fw6/installation-manual/#flashing-dasharo","text":"flashrom -p internal -w [ path ] --ifd -i bios To flash Dasharo on the platform, execute the following command - replace [path] with the path to the Dasharo image you want to flash, e.g. protectli_fw6_DF_v1.0.14.rom . sudo flashrom -p internal -w protectli_fw6_DF_v1.0.14.rom --ifd -i bios After successful operation reboot the platform.","title":"Flashing Dasharo"},{"location":"variants/protectli_fw6/overview/","text":"Overview Releases - list of all releases Building manual - how to build Dasharo for Protectli FW6 Installation manual - how to install Dasharo for Protectli FW6 Hardware configuration matrix - definition of hardware configuration used during validation Test matrix - validation scope for the Protectli FW6","title":"Overview"},{"location":"variants/protectli_fw6/overview/#overview","text":"Releases - list of all releases Building manual - how to build Dasharo for Protectli FW6 Installation manual - how to install Dasharo for Protectli FW6 Hardware configuration matrix - definition of hardware configuration used during validation Test matrix - validation scope for the Protectli FW6","title":"Overview"},{"location":"variants/protectli_fw6/releases/","text":"Protectli FW6 Dasharo Release Notes Following Release Notes describe status of Open Source Firmware development for Protectli FW6. For details about our release process please read Dasharo Standard Release Process . Subscribe to Protectli FW6 Dasharo Release Newsletter Test results for this platform can be found here . v1.0.14 - 2022-05-13 Changed Throttling temperature to 75 Celsius degrees Known issues Samsung memory modules do not work properly on older FW6A/B/C (SKU6LAV20) Binaries protectli_vault_kbl_v1.0.14.rom sha256 sha256.sig See how to verify signatures on this video SBOM (Software Bill of Materials) coreboot based on 87f9fc85 revision e04b0ac8 seabios based on v1.0.6 revision 03bcdcaf ipxe based on 2019.3 stable revision ebf2eaf5 memtest based on v002 revision dd5b4ff2","title":"Releases"},{"location":"variants/protectli_fw6/releases/#protectli-fw6-dasharo-release-notes","text":"Following Release Notes describe status of Open Source Firmware development for Protectli FW6. For details about our release process please read Dasharo Standard Release Process . Subscribe to Protectli FW6 Dasharo Release Newsletter Test results for this platform can be found here .","title":"Protectli FW6 Dasharo Release Notes"},{"location":"variants/protectli_fw6/releases/#v1014-2022-05-13","text":"","title":"v1.0.14 - 2022-05-13"},{"location":"variants/protectli_fw6/test-matrix/","text":"Test matrix - Protectli FW6 About The test matrix is used to determine the scope of tests which the DUT is subjected from before the release of the new binary. Module: Dasharo compatibility No. Supported test suite Test suite ID Supported test cases 1. Memory HCL HCL All 2. Display ports and LCD support DSP DSP002.001, DSP002.003 3. USB HID and MSC Support USB USB001.001, USB001.002, USB002.001, USB002.002 4. SMBIOS DMI DMI002.001, DMI003.001, DMI004.001, DMI005.001, DMI006.001 5. Custom boot logo CLG DMI002.001, DMI003.001, DMI004.001, DMI005.001, DMI006.001 6. M.2 WiFi/Bluetooth WLE WLE001.001, WLE002.001, WLE003.001 7. Network boot PXE All 8. Debian Stable and Ubuntu LTS support LBT All 9. Custom boot menu key CBK All 10. FreeBSD support BSD All 11. miniPCIe LTE/WiFi/Bluetooth MWL MWL004.001 12. Custom network boot entries CNB CNB001.002 Module: Dasharo performance No. Supported test suite Test suite ID Supported test cases 1. CPU temperature CPT All","title":"Test matrix"},{"location":"variants/protectli_fw6/test-matrix/#test-matrix-protectli-fw6","text":"","title":"Test matrix - Protectli FW6"},{"location":"variants/protectli_fw6/test-matrix/#about","text":"The test matrix is used to determine the scope of tests which the DUT is subjected from before the release of the new binary.","title":"About"},{"location":"variants/protectli_fw6/test-matrix/#module-dasharo-compatibility","text":"No. Supported test suite Test suite ID Supported test cases 1. Memory HCL HCL All 2. Display ports and LCD support DSP DSP002.001, DSP002.003 3. USB HID and MSC Support USB USB001.001, USB001.002, USB002.001, USB002.002 4. SMBIOS DMI DMI002.001, DMI003.001, DMI004.001, DMI005.001, DMI006.001 5. Custom boot logo CLG DMI002.001, DMI003.001, DMI004.001, DMI005.001, DMI006.001 6. M.2 WiFi/Bluetooth WLE WLE001.001, WLE002.001, WLE003.001 7. Network boot PXE All 8. Debian Stable and Ubuntu LTS support LBT All 9. Custom boot menu key CBK All 10. FreeBSD support BSD All 11. miniPCIe LTE/WiFi/Bluetooth MWL MWL004.001 12. Custom network boot entries CNB CNB001.002","title":"Module: Dasharo compatibility"},{"location":"variants/protectli_fw6/test-matrix/#module-dasharo-performance","text":"No. Supported test suite Test suite ID Supported test cases 1. CPU temperature CPT All","title":"Module: Dasharo performance"},{"location":"variants/protectli_vp2410/building-manual/","text":"Protectli Dasharo on VP2410 - building manual To build Dasharo firmware image, follow the steps below: Clone the coreboot repository: git clone https://github.com/Dasharo/coreboot.git -b protectli_vault_glk/release Check out the desired version e.g. v1.0.10 : cd coreboot git checkout protectli_vault_glk_v1.0.10 Start build process (note it requires certain blobs to proceed): # you will need to put the ZIP with blobs and FSP at this point ./build.sh vp2410","title":"Building manual"},{"location":"variants/protectli_vp2410/building-manual/#protectli-dasharo-on-vp2410-building-manual","text":"To build Dasharo firmware image, follow the steps below: Clone the coreboot repository: git clone https://github.com/Dasharo/coreboot.git -b protectli_vault_glk/release Check out the desired version e.g. v1.0.10 : cd coreboot git checkout protectli_vault_glk_v1.0.10 Start build process (note it requires certain blobs to proceed): # you will need to put the ZIP with blobs and FSP at this point ./build.sh vp2410","title":"Protectli Dasharo on VP2410 - building manual"},{"location":"variants/protectli_vp2410/hardware-matrix/","text":"Hardware configuration matrix - Protectli VP2410 Introduction This document describes the hardware configuration used for validation of the coreboot port on the Protectli VP2410 firewall. Protectli VP2410 Dasharo v1.0.15 Component Description CPU Intel Celeron J4125 SSD M.2 SSD SATA: Hoodisk SSL032GTTC7-S9A-2S external SATA 2.5 inch: Goodram SSDPR-CL100-240-G2 240GB RAM CRUCIAL CT4G4SFS824A SAMSUNG M471A4G43MB1-CTD SAMSUNG M471A1K43CB1-CTD SAMSUNG M471A5244BB0-CRC KINGSTON KVR24S17S8/8 KINGSTON KVR26S19S8/16 Wireless card Intel Wi-Fi 6 AX200 LTE miniPCIe card Quectel EC-20 Display HDMI 1920x1080p, DP 1920x1080p Ethernet 4x intel i211 (on-board) Attached devices 1. SanDisk USB 3.2Gen1 16 GB 2. SanDisk USB 3.2Gen1 16 GB 4. USB Type-C Hub Pro UCN3286 USB Keyboard DELL KB216 MMC drive SAMSUNG 8GTF4R (on-board) TPM PC Engines TPM1A LPC TPM Power supply Channel Well Technology 12V, 5.0A 60W Note, that in RAM section all used during verification procedure modules have been listed. Device has only one RAM mounting slot.","title":"Hardware Configuration Matrix"},{"location":"variants/protectli_vp2410/hardware-matrix/#hardware-configuration-matrix-protectli-vp2410","text":"","title":"Hardware configuration matrix - Protectli VP2410"},{"location":"variants/protectli_vp2410/hardware-matrix/#introduction","text":"This document describes the hardware configuration used for validation of the coreboot port on the Protectli VP2410 firewall.","title":"Introduction"},{"location":"variants/protectli_vp2410/hardware-matrix/#protectli-vp2410-dasharo-v1015","text":"Component Description CPU Intel Celeron J4125 SSD M.2 SSD SATA: Hoodisk SSL032GTTC7-S9A-2S external SATA 2.5 inch: Goodram SSDPR-CL100-240-G2 240GB RAM CRUCIAL CT4G4SFS824A SAMSUNG M471A4G43MB1-CTD SAMSUNG M471A1K43CB1-CTD SAMSUNG M471A5244BB0-CRC KINGSTON KVR24S17S8/8 KINGSTON KVR26S19S8/16 Wireless card Intel Wi-Fi 6 AX200 LTE miniPCIe card Quectel EC-20 Display HDMI 1920x1080p, DP 1920x1080p Ethernet 4x intel i211 (on-board) Attached devices 1. SanDisk USB 3.2Gen1 16 GB 2. SanDisk USB 3.2Gen1 16 GB 4. USB Type-C Hub Pro UCN3286 USB Keyboard DELL KB216 MMC drive SAMSUNG 8GTF4R (on-board) TPM PC Engines TPM1A LPC TPM Power supply Channel Well Technology 12V, 5.0A 60W Note, that in RAM section all used during verification procedure modules have been listed. Device has only one RAM mounting slot.","title":"Protectli VP2410 Dasharo v1.0.15"},{"location":"variants/protectli_vp2410/installation-manual/","text":"Protectli Dasharo on VP2410 - installation manual Flashing Dasharo firmware can be done from Linux using flashrom with the internal programmer. This document describes the process of building, installing and running flashrom on Ubuntu 20.04. Build flashrom Currently, the latest flashrom release lacks support for Comet Lake U internal flashing. Because of this, we need to build flashrom from source. Install build dependencies: apt install git build-essential debhelper pkg-config libpci-dev libusb-1.0-0-dev libftdi1-dev meson Obtain source code: git clone https://github.com/Dasharo/flashrom -b dasharo-release cd flashrom Build flashrom: sudo make install Reading flash contents Always prepare a backup of the current firmware image. To read from the flash and save them to a file ( dump.rom ), execute the following command: flashrom -p internal -r dump.rom Keep the backup for later recovery if needed. Flashing Dasharo To flash Dasharo on the platform, execute the following command - replace [path] with the path to the Dasharo image you want to flash, e.g. protectli_vault_glk_v1.0.15.rom . If stock firmware is currently installed: flashrom -p internal -w [ path ] If Dasharo is currently installed, only the COREBOOT and IFWI partitions of the flash needs to be updated. Flash it using the following command: flashrom -p internal -w protectli_vault_glk_v1.0.15.rom --fmap -i COREBOOT -i IFWI This command also preserves Dasharo UEFI settings and the boot order.","title":"Installation manual"},{"location":"variants/protectli_vp2410/installation-manual/#protectli-dasharo-on-vp2410-installation-manual","text":"Flashing Dasharo firmware can be done from Linux using flashrom with the internal programmer. This document describes the process of building, installing and running flashrom on Ubuntu 20.04.","title":"Protectli Dasharo on VP2410 - installation manual"},{"location":"variants/protectli_vp2410/installation-manual/#build-flashrom","text":"Currently, the latest flashrom release lacks support for Comet Lake U internal flashing. Because of this, we need to build flashrom from source. Install build dependencies: apt install git build-essential debhelper pkg-config libpci-dev libusb-1.0-0-dev libftdi1-dev meson Obtain source code: git clone https://github.com/Dasharo/flashrom -b dasharo-release cd flashrom Build flashrom: sudo make install","title":"Build flashrom"},{"location":"variants/protectli_vp2410/installation-manual/#reading-flash-contents","text":"Always prepare a backup of the current firmware image. To read from the flash and save them to a file ( dump.rom ), execute the following command: flashrom -p internal -r dump.rom Keep the backup for later recovery if needed.","title":"Reading flash contents"},{"location":"variants/protectli_vp2410/installation-manual/#flashing-dasharo","text":"To flash Dasharo on the platform, execute the following command - replace [path] with the path to the Dasharo image you want to flash, e.g. protectli_vault_glk_v1.0.15.rom . If stock firmware is currently installed: flashrom -p internal -w [ path ] If Dasharo is currently installed, only the COREBOOT and IFWI partitions of the flash needs to be updated. Flash it using the following command: flashrom -p internal -w protectli_vault_glk_v1.0.15.rom --fmap -i COREBOOT -i IFWI This command also preserves Dasharo UEFI settings and the boot order.","title":"Flashing Dasharo"},{"location":"variants/protectli_vp2410/overview/","text":"Overview Releases - list of all releases Building manual - how to build Dasharo for Protectli VP2410 Installation manual - how to install Dasharo for Protectli VP2410 Hardware configuration matrix - definition of hardware configuration used during validation Test matrix - validation scope for the Protectli VP2410","title":"Overview"},{"location":"variants/protectli_vp2410/overview/#overview","text":"Releases - list of all releases Building manual - how to build Dasharo for Protectli VP2410 Installation manual - how to install Dasharo for Protectli VP2410 Hardware configuration matrix - definition of hardware configuration used during validation Test matrix - validation scope for the Protectli VP2410","title":"Overview"},{"location":"variants/protectli_vp2410/releases/","text":"Protectli VP2410 Dasharo Release Notes Following Release Notes describe status of Open Source Firmware development for Protectli VP2410 For details about our release process please read Dasharo Standard Release Process . Subscribe to Protectli VP2410 Dasharo Release Newsletter Test results for this platform can be found here . v1.0.15 - 2022-05-31 Changed Customized Network boot menu and strings Fixed SMBIOS memory information showing 0 MB DRAM in setup Known issues USB 2.0 sticks not detected on VP2410 S3 resume does not work in Geminilake FSP Binaries The binaries will be published by Protectli on their webpage. As soon as they show up, Dasharo will link to them as well. SBOM (Software Bill of Materials) coreboot based on b77cf229 revision f59b1ec9 edk2 based on 7f90b9cd revision 90364638","title":"Releases"},{"location":"variants/protectli_vp2410/releases/#protectli-vp2410-dasharo-release-notes","text":"Following Release Notes describe status of Open Source Firmware development for Protectli VP2410 For details about our release process please read Dasharo Standard Release Process . Subscribe to Protectli VP2410 Dasharo Release Newsletter Test results for this platform can be found here .","title":"Protectli VP2410 Dasharo Release Notes"},{"location":"variants/protectli_vp2410/releases/#v1015-2022-05-31","text":"","title":"v1.0.15 - 2022-05-31"},{"location":"variants/protectli_vp2410/test-matrix/","text":"Test matrix - Protectli VP2410 About The test matrix is used to determine the scope of tests which the DUT is subjected from before the release of the new binary. Module: Dasharo compatibility No. Supported test suite Test suite ID Supported test cases 1. Memory HCL HCL All 2. UEFI compatible interface EFI EFI001.001 3. Display ports DSP DSP002.001, DSP002.003, DSP003.001, DSP003.003 4. Network boot PXE All 6. Custom logo CLG All 7. Custom boot menu key CBK All 8. USB HID and MSC Support USB USB001.001, USB001.002, USB002.001, USB002.002 9. FreeBSD support BSD All 10. Debian Stable and Ubuntu LTS support LBT All 11. USB-C/Thunderbolt UTC UTC004.001 12. M.2 WiFi/Bluetooth WLE WLE001.001, WLE002.001, WLE003.001 13. miniPCIe LTE/WiFi/Bluetooth MWL MWL001.001, MWL002.001, MWL003.001, MWL004.001 14. eMMC support MMC MMC001.001 15. SMBIOS DMI DMI002.001, DMI003.001, DMI004.001, DMI005.001, DMI006.001 16. Custom network boot entries CNB CNB001.002 Module: Dasharo security No. Supported test suite Test suite ID Supported test cases 1. TPM Support TPM TPM001.001","title":"Test matrix"},{"location":"variants/protectli_vp2410/test-matrix/#test-matrix-protectli-vp2410","text":"","title":"Test matrix - Protectli VP2410"},{"location":"variants/protectli_vp2410/test-matrix/#about","text":"The test matrix is used to determine the scope of tests which the DUT is subjected from before the release of the new binary.","title":"About"},{"location":"variants/protectli_vp2410/test-matrix/#module-dasharo-compatibility","text":"No. Supported test suite Test suite ID Supported test cases 1. Memory HCL HCL All 2. UEFI compatible interface EFI EFI001.001 3. Display ports DSP DSP002.001, DSP002.003, DSP003.001, DSP003.003 4. Network boot PXE All 6. Custom logo CLG All 7. Custom boot menu key CBK All 8. USB HID and MSC Support USB USB001.001, USB001.002, USB002.001, USB002.002 9. FreeBSD support BSD All 10. Debian Stable and Ubuntu LTS support LBT All 11. USB-C/Thunderbolt UTC UTC004.001 12. M.2 WiFi/Bluetooth WLE WLE001.001, WLE002.001, WLE003.001 13. miniPCIe LTE/WiFi/Bluetooth MWL MWL001.001, MWL002.001, MWL003.001, MWL004.001 14. eMMC support MMC MMC001.001 15. SMBIOS DMI DMI002.001, DMI003.001, DMI004.001, DMI005.001, DMI006.001 16. Custom network boot entries CNB CNB001.002","title":"Module: Dasharo compatibility"},{"location":"variants/protectli_vp2410/test-matrix/#module-dasharo-security","text":"No. Supported test suite Test suite ID Supported test cases 1. TPM Support TPM TPM001.001","title":"Module: Dasharo security"},{"location":"variants/protectli_vp4620/building-manual/","text":"Protectli Dasharo on VP4620 - building manual To build Dasharo firmware image, follow the steps below: Clone the coreboot repository: git clone https://github.com/Dasharo/coreboot.git -b protectli_vault_cml/release Start build process (note it requires certain blobs to proceed): cd coreboot # you will need to put the ZIP with blobs at this point ./build.sh vp4620","title":"Building manual"},{"location":"variants/protectli_vp4620/building-manual/#protectli-dasharo-on-vp4620-building-manual","text":"To build Dasharo firmware image, follow the steps below: Clone the coreboot repository: git clone https://github.com/Dasharo/coreboot.git -b protectli_vault_cml/release Start build process (note it requires certain blobs to proceed): cd coreboot # you will need to put the ZIP with blobs at this point ./build.sh vp4620","title":"Protectli Dasharo on VP4620 - building manual"},{"location":"variants/protectli_vp4620/hardware-matrix/","text":"Hardware configuration matrix - Protectli VP4620 Introduction This document describes the hardware configuration used for validation of the coreboot port on the Protectli VP4620 firewall. Protectli VP4620 Dasharo v1.0.13 Component Description CPU Intel Core i7-10510U SSD M.2 SSD SATA: Hoodisk SSL032GTTC7-S9A-2S M.2 SSD PCIE4X: Samsung MZVLB256HBHQ-00000 external SATA 2.5 inch: Goodram SSDPR-CL100-240-G2 240GB RAM CRUCIAL CT4G4SFS824A SAMSUNG M471A4G43MB1-CTD SAMSUNG M471A1K43CB1-CTD SAMSUNG M471A5244BB0-CRC KINGSTON KVR24S17S8/8 KINGSTON KVR26S19S8/16 Wireless card Intel Wi-Fi 6 AX201 LTE miniPCIe card Quectel EC-20 Display HDMI 1920x1080p, DP 1920x1080p Ethernet 6x intel i225 (on-board) Attached devices 1. SanDisk USB 3.2Gen1 16 GB 2. SanDisk USB 3.2Gen1 16 GB 3. SanDisk USB 3.2Gen1 16 GB 4. USB Type-C Hub Pro UCN3286 USB Keyboard DELL KB216 MMC drive SAMSUNG KLM8G1GETF-B041 (on-board) TPM PC Engines TPM1A LPC TPM Power supply Channel Well Technology 12V, 7.5A 90W Note, that in RAM section all used during verification procedure modules have been listed. Device has only two RAM mounting slots.","title":"Hardware Configuration Matrix"},{"location":"variants/protectli_vp4620/hardware-matrix/#hardware-configuration-matrix-protectli-vp4620","text":"","title":"Hardware configuration matrix - Protectli VP4620"},{"location":"variants/protectli_vp4620/hardware-matrix/#introduction","text":"This document describes the hardware configuration used for validation of the coreboot port on the Protectli VP4620 firewall.","title":"Introduction"},{"location":"variants/protectli_vp4620/hardware-matrix/#protectli-vp4620-dasharo-v1013","text":"Component Description CPU Intel Core i7-10510U SSD M.2 SSD SATA: Hoodisk SSL032GTTC7-S9A-2S M.2 SSD PCIE4X: Samsung MZVLB256HBHQ-00000 external SATA 2.5 inch: Goodram SSDPR-CL100-240-G2 240GB RAM CRUCIAL CT4G4SFS824A SAMSUNG M471A4G43MB1-CTD SAMSUNG M471A1K43CB1-CTD SAMSUNG M471A5244BB0-CRC KINGSTON KVR24S17S8/8 KINGSTON KVR26S19S8/16 Wireless card Intel Wi-Fi 6 AX201 LTE miniPCIe card Quectel EC-20 Display HDMI 1920x1080p, DP 1920x1080p Ethernet 6x intel i225 (on-board) Attached devices 1. SanDisk USB 3.2Gen1 16 GB 2. SanDisk USB 3.2Gen1 16 GB 3. SanDisk USB 3.2Gen1 16 GB 4. USB Type-C Hub Pro UCN3286 USB Keyboard DELL KB216 MMC drive SAMSUNG KLM8G1GETF-B041 (on-board) TPM PC Engines TPM1A LPC TPM Power supply Channel Well Technology 12V, 7.5A 90W Note, that in RAM section all used during verification procedure modules have been listed. Device has only two RAM mounting slots.","title":"Protectli VP4620 Dasharo v1.0.13"},{"location":"variants/protectli_vp4620/installation-manual/","text":"Protectli Dasharo on VP4620 - installation manual Flashing coreboot can be done from Linux using flashrom with the internal programmer. This document describes the process of building, installing and running flashrom on Ubuntu 20.04. Build flashrom Currently, the latest flashrom release lacks support for Comet Lake U internal flashing. Because of this, we need to build flashrom from source. Install build dependencies: apt install git build-essential debhelper pkg-config libpci-dev libusb-1.0-0-dev libftdi1-dev meson Obtain source code: git clone https://review.coreboot.org/flashrom.git cd flashrom Build flashrom: make sudo make install Reading flash contents Always prepare a backup of the current firmware image. To read from the flash and save them to a file ( dump.rom ), execute the following command: flashrom -p internal -r dump.rom Flashing Dasharo To flash Dasharo on the platform, execute the following command - replace [path] with the path to the Dasharo image you want to flash, e.g. protectli_vault_cml_v1.0.13.rom . If stock firmware is currently installed: flashrom -p internal -w protectli_vault_cml_v1.0.13.rom This will flash the full image including Intel ME. The operation requires a hard reset of the platform. To perform a hard reset: Power off the platform. Note, it may not power off completely due to flashed ME. Disconnect power supply from the board when OS finishes all tasks before power off (the screen goes dark or black). Disconnect the RTC/CMOS battery OR clear the CMOS using the pin header located near memory slots. Wait about half a minute (unshort the pins). Connect the power supply back. The platform should power on normally now. You can connect the battery back if it was disconnected. If Dasharo is currently installed, only the COREBOOT partition of the flash needs to be updated. Flash it using the following command: flashrom -p internal -w protectli_vault_cml_v1.0.13.rom --fmap -i COREBOOT This command also preserves Dasharo UEFI settings and the boot order.","title":"Installation manual"},{"location":"variants/protectli_vp4620/installation-manual/#protectli-dasharo-on-vp4620-installation-manual","text":"Flashing coreboot can be done from Linux using flashrom with the internal programmer. This document describes the process of building, installing and running flashrom on Ubuntu 20.04.","title":"Protectli Dasharo on VP4620 - installation manual"},{"location":"variants/protectli_vp4620/installation-manual/#build-flashrom","text":"Currently, the latest flashrom release lacks support for Comet Lake U internal flashing. Because of this, we need to build flashrom from source. Install build dependencies: apt install git build-essential debhelper pkg-config libpci-dev libusb-1.0-0-dev libftdi1-dev meson Obtain source code: git clone https://review.coreboot.org/flashrom.git cd flashrom Build flashrom: make sudo make install","title":"Build flashrom"},{"location":"variants/protectli_vp4620/installation-manual/#reading-flash-contents","text":"Always prepare a backup of the current firmware image. To read from the flash and save them to a file ( dump.rom ), execute the following command: flashrom -p internal -r dump.rom","title":"Reading flash contents"},{"location":"variants/protectli_vp4620/installation-manual/#flashing-dasharo","text":"To flash Dasharo on the platform, execute the following command - replace [path] with the path to the Dasharo image you want to flash, e.g. protectli_vault_cml_v1.0.13.rom . If stock firmware is currently installed: flashrom -p internal -w protectli_vault_cml_v1.0.13.rom This will flash the full image including Intel ME. The operation requires a hard reset of the platform. To perform a hard reset: Power off the platform. Note, it may not power off completely due to flashed ME. Disconnect power supply from the board when OS finishes all tasks before power off (the screen goes dark or black). Disconnect the RTC/CMOS battery OR clear the CMOS using the pin header located near memory slots. Wait about half a minute (unshort the pins). Connect the power supply back. The platform should power on normally now. You can connect the battery back if it was disconnected. If Dasharo is currently installed, only the COREBOOT partition of the flash needs to be updated. Flash it using the following command: flashrom -p internal -w protectli_vault_cml_v1.0.13.rom --fmap -i COREBOOT This command also preserves Dasharo UEFI settings and the boot order.","title":"Flashing Dasharo"},{"location":"variants/protectli_vp4620/releases/","text":"Protectli VP4620 Dasharo Release Notes Following Release Notes describe status of Open Source Firmware development for Protectli VP4620 For details about our release process please read Dasharo Standard Release Process . Subscribe to Protectli VP4620 Dasharo Release Newsletter Test results for this platform can be found here . v1.0.13 - 2022-03-22 Added UEFI boot support i225 network controller network boot support Customized boot menu keys Customized setup menu keys Configurable boot order Configurable boot options Changed ME version to 14.0.47.1558 Known issues i225 network controller initialization takes too much time Binaries protectli_vault_cml_v1.0.13.rom sha256 sha256.sig See how to verify signatures on asciinema SBOM (Software Bill of Materials) coreboot based on 4.16 revision 546e1c86 edk2 based on 7f90b9cd revision 7f90b9cd","title":"Releases"},{"location":"variants/protectli_vp4620/releases/#protectli-vp4620-dasharo-release-notes","text":"Following Release Notes describe status of Open Source Firmware development for Protectli VP4620 For details about our release process please read Dasharo Standard Release Process . Subscribe to Protectli VP4620 Dasharo Release Newsletter Test results for this platform can be found here .","title":"Protectli VP4620 Dasharo Release Notes"},{"location":"variants/protectli_vp4620/releases/#v1013-2022-03-22","text":"","title":"v1.0.13 - 2022-03-22"},{"location":"variants/protectli_vp4620/test-matrix/","text":"Test matrix - Protectli VP4620 About The test matrix is used to determine the scope of tests which the DUT is subjected from before the release of the new binary. Module: Dasharo compatibility No. Supported test suite Test suite ID Supported test cases 1. Memory HCL HCL All 2. UEFI compatible interface EFI EFI001.001 3. Display ports DSP DSP002.001, DSP002.003, DSP003.001, DSP003.003 4. Network boot PXE All 5. NVMe support NVM NVM001.001, NVM001.002 6. Custom logo CLG All 7. Custom boot menu key CBK All 8. USB HID and MSC Support USB USB001.001, USB001.002, USB002.001, USB002.002 9. FreeBSD support BSD All 10. Debian Stable and Ubuntu LTS support LBT All 11. USB-C/Thunderbolt UTC UTC004.001 12. M.2 WiFi/Bluetooth WLE WLE001.001, WLE002.001, WLE003.001 13. miniPCIe LTE/WiFi/Bluetooth MWL MWL004.001 14. eMMC support MMC MMC001.001 15. SMBIOS DMI DMI002.001, DMI003.001, DMI004.001, DMI005.001, DMI006.001 16. Custom network boot entries CNB CNB001.002 17. M.2 automatic SATA/NVMe switching support MSS MSS001.001 Module: Dasharo security No. Supported test suite Test suite ID Supported test cases 1. TPM Support TPM TPM001.001","title":"Test matrix"},{"location":"variants/protectli_vp4620/test-matrix/#test-matrix-protectli-vp4620","text":"","title":"Test matrix - Protectli VP4620"},{"location":"variants/protectli_vp4620/test-matrix/#about","text":"The test matrix is used to determine the scope of tests which the DUT is subjected from before the release of the new binary.","title":"About"},{"location":"variants/protectli_vp4620/test-matrix/#module-dasharo-compatibility","text":"No. Supported test suite Test suite ID Supported test cases 1. Memory HCL HCL All 2. UEFI compatible interface EFI EFI001.001 3. Display ports DSP DSP002.001, DSP002.003, DSP003.001, DSP003.003 4. Network boot PXE All 5. NVMe support NVM NVM001.001, NVM001.002 6. Custom logo CLG All 7. Custom boot menu key CBK All 8. USB HID and MSC Support USB USB001.001, USB001.002, USB002.001, USB002.002 9. FreeBSD support BSD All 10. Debian Stable and Ubuntu LTS support LBT All 11. USB-C/Thunderbolt UTC UTC004.001 12. M.2 WiFi/Bluetooth WLE WLE001.001, WLE002.001, WLE003.001 13. miniPCIe LTE/WiFi/Bluetooth MWL MWL004.001 14. eMMC support MMC MMC001.001 15. SMBIOS DMI DMI002.001, DMI003.001, DMI004.001, DMI005.001, DMI006.001 16. Custom network boot entries CNB CNB001.002 17. M.2 automatic SATA/NVMe switching support MSS MSS001.001","title":"Module: Dasharo compatibility"},{"location":"variants/protectli_vp4620/test-matrix/#module-dasharo-security","text":"No. Supported test suite Test suite ID Supported test cases 1. TPM Support TPM TPM001.001","title":"Module: Dasharo security"},{"location":"variants/talos_2/building-manual/","text":"Insurgo Dasharo on Talos II - building manual Building coreboot To build coreboot image, follow the steps below: Clone the coreboot repository: git clone https://github.com/Dasharo/coreboot.git -b raptor-cs_talos-2/release Get the submodules: cd coreboot git submodule update --init --recursive --checkout Start docker container: docker run --rm -it \\ -v $PWD :/home/coreboot/coreboot \\ -w /home/coreboot/coreboot \\ 3mdeb/coreboot-sdk:mkimage /bin/bash Inside of the container, configure and start the build process: ( docker ) cp configs/config.raptor-cs-talos-2 .config ( docker ) make olddefconfig ( docker ) make Building heads Clone the heads repository: git clone https://github.com/Dasharo/heads.git -b raptor-cs_talos-2/release Start docker container: docker run --rm -it -v $PWD : $PWD -w $PWD 3mdeb/heads-docker:2.3.0 /bin/bash Build: make BOARD = talos-2_server","title":"Building manual"},{"location":"variants/talos_2/building-manual/#insurgo-dasharo-on-talos-ii-building-manual","text":"","title":"Insurgo Dasharo on Talos II - building manual"},{"location":"variants/talos_2/building-manual/#building-coreboot","text":"To build coreboot image, follow the steps below: Clone the coreboot repository: git clone https://github.com/Dasharo/coreboot.git -b raptor-cs_talos-2/release Get the submodules: cd coreboot git submodule update --init --recursive --checkout Start docker container: docker run --rm -it \\ -v $PWD :/home/coreboot/coreboot \\ -w /home/coreboot/coreboot \\ 3mdeb/coreboot-sdk:mkimage /bin/bash Inside of the container, configure and start the build process: ( docker ) cp configs/config.raptor-cs-talos-2 .config ( docker ) make olddefconfig ( docker ) make","title":"Building coreboot"},{"location":"variants/talos_2/building-manual/#building-heads","text":"Clone the heads repository: git clone https://github.com/Dasharo/heads.git -b raptor-cs_talos-2/release Start docker container: docker run --rm -it -v $PWD : $PWD -w $PWD 3mdeb/heads-docker:2.3.0 /bin/bash Build: make BOARD = talos-2_server","title":"Building heads"},{"location":"variants/talos_2/conferences/","text":"Insurgo Dasharo on Talos II - Conference materails OpenPOWER Summit, 2021 coreboot on POWER9 - Piotr Kr\u00f3l OpenPOWER Summit, 2020 POWER9 Support in coreboot - Micha\u0142 \u017bygowski Fosdem, 2021 Status of OpenPOWER support in coreboot - Micha\u0142 \u017bygowski Open Source Firmware Conference, 2020 POWER9 support in coreboot - Micha\u0142 \u017bygowski","title":"Conference materials"},{"location":"variants/talos_2/conferences/#insurgo-dasharo-on-talos-ii-conference-materails","text":"","title":"Insurgo Dasharo on Talos II - Conference materails"},{"location":"variants/talos_2/conferences/#openpower-summit-2021","text":"coreboot on POWER9 - Piotr Kr\u00f3l","title":"OpenPOWER Summit, 2021"},{"location":"variants/talos_2/conferences/#openpower-summit-2020","text":"POWER9 Support in coreboot - Micha\u0142 \u017bygowski","title":"OpenPOWER Summit, 2020"},{"location":"variants/talos_2/conferences/#fosdem-2021","text":"Status of OpenPOWER support in coreboot - Micha\u0142 \u017bygowski","title":"Fosdem, 2021"},{"location":"variants/talos_2/conferences/#open-source-firmware-conference-2020","text":"POWER9 support in coreboot - Micha\u0142 \u017bygowski","title":"Open Source Firmware Conference, 2020"},{"location":"variants/talos_2/hardware-matrix/","text":"Hardware configuration matrix - Talos II Introduction This document describes the hardware configuration used for validation of the coreboot port on the Talos II platform. Board No. 1 Component Description CPU TBD TBD CPU Cooler RAM TBD Flash memory TBD Network Local network wired connection Attached devices 1. TBD 2. TBD Power Supply TBD W ATX type power supply Power Control 1. Sonoff S20 switch 2. Goldpin cables (RTE <-> Board connection) Remote Testing Environment 1. RTE v1.0.0 (firmware v0.5.3 ) connected via RS232 2. Goldpin cables + qspimux (RTE <-> flash memory connection) Following RAM configurations were tested and are proved to be properly initialized. MCS0, MCA0 DIMM0: 1Rx4 16GB PC4-2666V-RC2-12-PA0 DIMM1: not installed MCS0, MCA1 DIMM0: 1Rx8 8GB PC4-2666V-RD1-12 DIMM1: not installed MCS1, MCA0 DIMM0: 2Rx4 32GB PC4-2666V-RB2-12-MA0 DIMM1: not installed MCS1, MCA1 DIMM0: 2Rx8 16GB PC4-2666V-RE2-12 DIMM1: not installed All 3 major DRAM vendors are supported, namely Samsung, Micron and Hynix.","title":"Hardware configuration matrix - Talos II"},{"location":"variants/talos_2/hardware-matrix/#hardware-configuration-matrix-talos-ii","text":"","title":"Hardware configuration matrix - Talos II"},{"location":"variants/talos_2/hardware-matrix/#introduction","text":"This document describes the hardware configuration used for validation of the coreboot port on the Talos II platform.","title":"Introduction"},{"location":"variants/talos_2/hardware-matrix/#board-no-1","text":"Component Description CPU TBD TBD CPU Cooler RAM TBD Flash memory TBD Network Local network wired connection Attached devices 1. TBD 2. TBD Power Supply TBD W ATX type power supply Power Control 1. Sonoff S20 switch 2. Goldpin cables (RTE <-> Board connection) Remote Testing Environment 1. RTE v1.0.0 (firmware v0.5.3 ) connected via RS232 2. Goldpin cables + qspimux (RTE <-> flash memory connection) Following RAM configurations were tested and are proved to be properly initialized. MCS0, MCA0 DIMM0: 1Rx4 16GB PC4-2666V-RC2-12-PA0 DIMM1: not installed MCS0, MCA1 DIMM0: 1Rx8 8GB PC4-2666V-RD1-12 DIMM1: not installed MCS1, MCA0 DIMM0: 2Rx4 32GB PC4-2666V-RB2-12-MA0 DIMM1: not installed MCS1, MCA1 DIMM0: 2Rx8 16GB PC4-2666V-RE2-12 DIMM1: not installed All 3 major DRAM vendors are supported, namely Samsung, Micron and Hynix.","title":"Board No. 1"},{"location":"variants/talos_2/installation-manual/","text":"Insurgo Dasharo on Talos II - installation manual coreboot installation Copy the binaries to the BMC (assuming in the coreboot root directory): scp build/bootblock.signed.ecc root@<BMC_IP>:/tmp/bootblock.signed.ecc scp build/coreboot.rom.signed.ecc root@<BMC_IP>:/tmp/coreboot.rom.signed.ecc If that file is not present, use coreboot.rom instead Backup the HBB partition (for faster later recovery) by invoking this command on BMC: pflash -P HBB -r /tmp/hbb.bin pflash -P HBI -r /tmp/hbi.bin Flash the binaries by replacing HBB partition (execute from BMC): pflash -e -P HBB -p /tmp/bootblock.signed.ecc pflash -e -P HBI -p /tmp/coreboot.rom.signed.ecc Again, if that file is not present, use coreboot.rom instead Answer yes to the prompt and wait for the process to finish. Log into the BMC GUI again at https://<BMC_IP> . Enter the Server power operations ( https://<BMC_IP>/#/server-control/power-operations ) and invoke warm reboot . Go to Serial over LAN remote console ( https://<BMC_IP>/#/server-control/remote-console ). Wait for a while until coreboot shows up: Enjoy the coreboot running on Talos II. Optional: In order to recovery the platform quickly to healthy state, flash the HBB partition back with: pflash -e -P HBB -p /tmp/hbb.bin pflash -e -P HBI -p /tmp/hbi.bin Heads installation Copy the Heads binary to the BMC (assuming in the Heads root directory): scp build/zImage.bundled root@<BMC_IP>:/tmp/zImage.bundled Log in to the BMC: ssh root@<BMC_IP> Flash the BOOTKERNEL partition with Heads: pflash -e -P BOOTKERNEL -p /tmp/zImage.bundled Answer yes to the prompt and wait for the process to finish. Log into the BMC GUI at https://<BMC_IP>/ . Enter the Server power operations ( https://<BMC_IP>/#/server-control/power-operations ) and invoke warm reboot . Go to Serial over LAN remote console ( https://<BMC_IP>/#/server-control/remote-console ). Wait for a while until Heads shows up: Enjoy the Heads running on Talos II. Testing firmware images without flashing BMC firmware v2.00+ allows testing new firmware images without flashing the physical flash device. This makes testing and switching between two versions (e.g. Hostboot and coreboot) much faster and safer. There are two ways of doing so, here's a more convenient one that uses mboxctl : Read original flash: For earlier versions of coreboot port it is required to read from system that booted at least once, since some of the partitions are modified on the first boot. this is no longer necessary since v0.5.0. root@talos:~# pflash -r /tmp/talos.pnor This file may also be copied out of BMC to a secure place and serve as a backup of whole flash contents. Keep in mind that tmpfs size is limited and exceeding that limit may result in unresponsive BMC, which in most severe cases requires hard power cycle. \"Flashing\" modified partition(s): This is similar to flashing real device with two changes: no need to erase the flash and target file must be specified. New command looks like this: root@talos:~# pflash -P <partition> -p <partition>.bin -F /tmp/talos.pnor Since the real flash device is not used, backup can be skipped. The rest is like above: # bootblock pflash -P HBB -p /tmp/bootblock.signed.ecc -F /tmp/talos.pnor # coreboot pflash -P HBI -p /tmp/coreboot.rom.signed.ecc -F /tmp/talos.pnor # Heads pflash -P BOOTKERNEL -p /tmp/zImage.bundled -F /tmp/talos.pnor Mount the file as flash device: root@talos:~# mboxctl --backend file:/tmp/talos.pnor Sometimes this command fails with timeout, in that case repeat it until it succeeds. Optionally, success can be tested with: root@talos:~# mboxctl --lpc-state LPC Bus Maps: BMC Memory BMC Memory tells that emulated flash is used instead of real one. Host doesn't see any difference (except maybe different access times and erase block size), it still reads and writes PNOR the same way as with physical device. Start the platform as described in previous sections and test it. To get back to using real PNOR: root@talos:~# mboxctl --backend vpnor Failed to post message: Connection timed out root@talos:~# mboxctl --lpc-state LPC Bus Maps: Flash Device Even though that command reports failure, it maps LPC back to flash device. This can be tested with mboxctl --lpc-state . (Optional) Flash tested image to permanent storage: root@talos:~# pflash -E -p /tmp/talos.pnor The other method is described on Raptor's wiki and requires starting mboxd manually (still needs BMC firmware v2.00+). It's worth to take a look there because sometimes mboxd stops working ( mboxctl errors every time) and that page shows how it can be started.","title":"Installation manual"},{"location":"variants/talos_2/installation-manual/#insurgo-dasharo-on-talos-ii-installation-manual","text":"","title":"Insurgo Dasharo on Talos II - installation manual"},{"location":"variants/talos_2/installation-manual/#coreboot-installation","text":"Copy the binaries to the BMC (assuming in the coreboot root directory): scp build/bootblock.signed.ecc root@<BMC_IP>:/tmp/bootblock.signed.ecc scp build/coreboot.rom.signed.ecc root@<BMC_IP>:/tmp/coreboot.rom.signed.ecc If that file is not present, use coreboot.rom instead Backup the HBB partition (for faster later recovery) by invoking this command on BMC: pflash -P HBB -r /tmp/hbb.bin pflash -P HBI -r /tmp/hbi.bin Flash the binaries by replacing HBB partition (execute from BMC): pflash -e -P HBB -p /tmp/bootblock.signed.ecc pflash -e -P HBI -p /tmp/coreboot.rom.signed.ecc Again, if that file is not present, use coreboot.rom instead Answer yes to the prompt and wait for the process to finish. Log into the BMC GUI again at https://<BMC_IP> . Enter the Server power operations ( https://<BMC_IP>/#/server-control/power-operations ) and invoke warm reboot . Go to Serial over LAN remote console ( https://<BMC_IP>/#/server-control/remote-console ). Wait for a while until coreboot shows up: Enjoy the coreboot running on Talos II. Optional: In order to recovery the platform quickly to healthy state, flash the HBB partition back with: pflash -e -P HBB -p /tmp/hbb.bin pflash -e -P HBI -p /tmp/hbi.bin","title":"coreboot installation"},{"location":"variants/talos_2/installation-manual/#heads-installation","text":"Copy the Heads binary to the BMC (assuming in the Heads root directory): scp build/zImage.bundled root@<BMC_IP>:/tmp/zImage.bundled Log in to the BMC: ssh root@<BMC_IP> Flash the BOOTKERNEL partition with Heads: pflash -e -P BOOTKERNEL -p /tmp/zImage.bundled Answer yes to the prompt and wait for the process to finish. Log into the BMC GUI at https://<BMC_IP>/ . Enter the Server power operations ( https://<BMC_IP>/#/server-control/power-operations ) and invoke warm reboot . Go to Serial over LAN remote console ( https://<BMC_IP>/#/server-control/remote-console ). Wait for a while until Heads shows up: Enjoy the Heads running on Talos II.","title":"Heads installation"},{"location":"variants/talos_2/installation-manual/#testing-firmware-images-without-flashing","text":"BMC firmware v2.00+ allows testing new firmware images without flashing the physical flash device. This makes testing and switching between two versions (e.g. Hostboot and coreboot) much faster and safer. There are two ways of doing so, here's a more convenient one that uses mboxctl : Read original flash: For earlier versions of coreboot port it is required to read from system that booted at least once, since some of the partitions are modified on the first boot. this is no longer necessary since v0.5.0. root@talos:~# pflash -r /tmp/talos.pnor This file may also be copied out of BMC to a secure place and serve as a backup of whole flash contents. Keep in mind that tmpfs size is limited and exceeding that limit may result in unresponsive BMC, which in most severe cases requires hard power cycle. \"Flashing\" modified partition(s): This is similar to flashing real device with two changes: no need to erase the flash and target file must be specified. New command looks like this: root@talos:~# pflash -P <partition> -p <partition>.bin -F /tmp/talos.pnor Since the real flash device is not used, backup can be skipped. The rest is like above: # bootblock pflash -P HBB -p /tmp/bootblock.signed.ecc -F /tmp/talos.pnor # coreboot pflash -P HBI -p /tmp/coreboot.rom.signed.ecc -F /tmp/talos.pnor # Heads pflash -P BOOTKERNEL -p /tmp/zImage.bundled -F /tmp/talos.pnor Mount the file as flash device: root@talos:~# mboxctl --backend file:/tmp/talos.pnor Sometimes this command fails with timeout, in that case repeat it until it succeeds. Optionally, success can be tested with: root@talos:~# mboxctl --lpc-state LPC Bus Maps: BMC Memory BMC Memory tells that emulated flash is used instead of real one. Host doesn't see any difference (except maybe different access times and erase block size), it still reads and writes PNOR the same way as with physical device. Start the platform as described in previous sections and test it. To get back to using real PNOR: root@talos:~# mboxctl --backend vpnor Failed to post message: Connection timed out root@talos:~# mboxctl --lpc-state LPC Bus Maps: Flash Device Even though that command reports failure, it maps LPC back to flash device. This can be tested with mboxctl --lpc-state . (Optional) Flash tested image to permanent storage: root@talos:~# pflash -E -p /tmp/talos.pnor The other method is described on Raptor's wiki and requires starting mboxd manually (still needs BMC firmware v2.00+). It's worth to take a look there because sometimes mboxd stops working ( mboxctl errors every time) and that page shows how it can be started.","title":"Testing firmware images without flashing"},{"location":"variants/talos_2/releases/","text":"Raptor Computing Systems Talos II Dasharo Release Notes Following Release Notes describe status of Open Source Firmware development for Raptor Computing Systems Talos II For details about our release process please read Dasharo Standard Release Process . Subscribe to Release Newsletter Test results for this platform can be found here . v0.5.0 - 2022-04-12 Changed Add FSI initialization and functions for accessing devices behind FSI bus Cache MVPD between stages Initialize and train XBus links Change SCOM API to be able to access second CPU Initialize PCIe, MCS, OCC and TOD for second CPU Switch to ELF payload, clean up Device Tree generation Various boot time optimizations Fixed Only one CPU is started SPDs are not exposed in sysfs automatically Known issues Missing parts of Device Tree describing specific unit (VPD, serial numbers) CBMEM can no longer be accessed from OS Binaries raptor-cs_talos-2_bootblock_v0.5.0.signed.ecc sha256 sha256.sig raptor-cs_talos-2_coreboot_v0.5.0.rom.signed.ecc sha256 sha256.sig Heads was not modified in this release, its binary from previous releases can be used. SBOM (Software Bill of Materials) coreboot based on 5621a1e revision c92383f9 skiboot based on 04-16-2019 revision 98581863 v0.4.1 - 2022-01-10 Changed Simplify memlayout Replace PPC_SHIFT with PPC_PLACE macro Change SPR numbers definitions to decimal Print signing output to terminal Fixed Watchdog timing out Sporadic signing failure due to the tools not being built Building with cross compiler other than powerpc64-linux-gnu- Known issues Only one CPU is started SPDs are not exposed in sysfs automatically Missing parts of Device Tree describing specific unit (VPD, serial numbers) Binaries dasharo_talos_2_bootblock_v0.4.1.signed.ecc sha256 sha256.sig dasharo_talos_2_coreboot_v0.4.1.rom.signed.ecc sha256 sha256.sig dasharo_talos_2_zImage_v0.4.1.bundled sha256 sha256.sig SBOM (Software Bill of Materials) coreboot based on 5621a1e revision 13b58058 skiboot based on 04-16-2019 revision 98581863 heads based on 21e50681 revision 34c77951 v0.4.0 - 2021-10-29 Added OCC support XIVE support PCIe initialization IPMI block transfer interface Non-constant nodes in Device Tree are generated programmatically Known issues Only one CPU is started SPDs are not exposed in sysfs automatically Missing parts of Device Tree describing specific unit (VPD, serial numbers) Watchdog times out Binaries dasharo_talos_2_bootblock_v0.4.0.signed.ecc sha256 sha256.sig dasharo_talos_2_coreboot.rom.signed.ecc sha256 sha256.sig zImage_v0.4.0.bundled sha256 sha256.sig SBOM (Software Bill of Materials) coreboot based on 5621a1e revision b535763b skiboot based on 04-16-2019 revision 98581863 heads based on 21e50681 revision 34c77951","title":"Releases"},{"location":"variants/talos_2/releases/#raptor-computing-systems-talos-ii-dasharo-release-notes","text":"Following Release Notes describe status of Open Source Firmware development for Raptor Computing Systems Talos II For details about our release process please read Dasharo Standard Release Process . Subscribe to Release Newsletter Test results for this platform can be found here .","title":"Raptor Computing Systems Talos II Dasharo Release Notes"},{"location":"variants/talos_2/releases/#v050-2022-04-12","text":"","title":"v0.5.0 - 2022-04-12"},{"location":"variants/talos_2/releases/#v041-2022-01-10","text":"","title":"v0.4.1 - 2022-01-10"},{"location":"variants/talos_2/releases/#v040-2021-10-29","text":"","title":"v0.4.0 - 2021-10-29"},{"location":"variants/talos_2/test-matrix/","text":"Test matrix - Talos II About The test matrix is used to determine the scope of tests which the DUT is subjected from before the release of the new binary. Module: Dasharo compatibility No. Supported test suite Test suite ID Supported test cases 1. coreboot base port CBP CBP001.001, CBP002.001, CBP004.001 2. Petitboot payload support PBT All 3. Heads bootloader support HDS All 4. Device Tree DVT All 5. USB detection USB All 6. USB booting UBB All 7. Debian Stable and Ubuntu LTS support LBT LBT002.001 8. CPU status CPU All Module: Dasharo performance No. Supported test suite Test suite ID Supported test cases 1. coreboot bring up time measurement CBMEM All","title":"Test matrix"},{"location":"variants/talos_2/test-matrix/#test-matrix-talos-ii","text":"","title":"Test matrix - Talos II"},{"location":"variants/talos_2/test-matrix/#about","text":"The test matrix is used to determine the scope of tests which the DUT is subjected from before the release of the new binary.","title":"About"},{"location":"variants/talos_2/test-matrix/#module-dasharo-compatibility","text":"No. Supported test suite Test suite ID Supported test cases 1. coreboot base port CBP CBP001.001, CBP002.001, CBP004.001 2. Petitboot payload support PBT All 3. Heads bootloader support HDS All 4. Device Tree DVT All 5. USB detection USB All 6. USB booting UBB All 7. Debian Stable and Ubuntu LTS support LBT LBT002.001 8. CPU status CPU All","title":"Module: Dasharo compatibility"},{"location":"variants/talos_2/test-matrix/#module-dasharo-performance","text":"No. Supported test suite Test suite ID Supported test cases 1. coreboot bring up time measurement CBMEM All","title":"Module: Dasharo performance"},{"location":"variants/tuxedo_ibs15/building/","text":"Dasharo for Tuxedo IBS15 Gen6 - Building manual Intro This documents describes the procedure for compiling coreboot for Tuxedo IBS15. Requirements Docker follow Install Docker Engine on Ubuntu follow Post-installation steps for Linux Git Procedure The easiest way to build coreboot is to use the official Docker image. Obtain the image: docker pull coreboot/coreboot-sdk:0ad5fbd48d Obtain coreboot source code for Tuxedo IBS15: git clone https://github.com/Dasharo/coreboot.git Navigate to the source code directory and checkout to the desired revision: Replace the REVISION with one of the: - tuxedo_ibs15/release for the latest released version - tuxedo_ibs15/vVERSION (e.g. v1.0.0 ) for the given release cd coreboot git checkout REVISION git submodule update --init --recursive --checkout ./build.sh build The resulting coreboot image will be placed in artifacts/dasharo_tuxedo_ibs15_VERSION.rom . Warning: Do not run ./build.sh as root. This command uses docker and should be executed as your current user. If you're having trouble running build.sh on your user account, follow the Docker instructions outlined in Requirements .","title":"Building manual"},{"location":"variants/tuxedo_ibs15/building/#dasharo-for-tuxedo-ibs15-gen6-building-manual","text":"","title":"Dasharo for Tuxedo IBS15 Gen6 - Building manual"},{"location":"variants/tuxedo_ibs15/building/#intro","text":"This documents describes the procedure for compiling coreboot for Tuxedo IBS15.","title":"Intro"},{"location":"variants/tuxedo_ibs15/building/#requirements","text":"Docker follow Install Docker Engine on Ubuntu follow Post-installation steps for Linux Git","title":"Requirements"},{"location":"variants/tuxedo_ibs15/building/#procedure","text":"The easiest way to build coreboot is to use the official Docker image. Obtain the image: docker pull coreboot/coreboot-sdk:0ad5fbd48d Obtain coreboot source code for Tuxedo IBS15: git clone https://github.com/Dasharo/coreboot.git Navigate to the source code directory and checkout to the desired revision: Replace the REVISION with one of the: - tuxedo_ibs15/release for the latest released version - tuxedo_ibs15/vVERSION (e.g. v1.0.0 ) for the given release cd coreboot git checkout REVISION git submodule update --init --recursive --checkout ./build.sh build The resulting coreboot image will be placed in artifacts/dasharo_tuxedo_ibs15_VERSION.rom . Warning: Do not run ./build.sh as root. This command uses docker and should be executed as your current user. If you're having trouble running build.sh on your user account, follow the Docker instructions outlined in Requirements .","title":"Procedure"},{"location":"variants/tuxedo_ibs15/hardware-matrix/","text":"Hardware configuration matrix - Tuxedo IBS15 Introduction This document describes the hardware configurations used for validation of the coreboot port on the Tuxedo IBS15 laptop. IBS15 #1 Component Description CPU Intel(R) Core(TM) i5-1135G7 Internal Cooling RAM Slot 1: KVR29S21S6/8 Slot 2: KVR29S21S6/4 SSD 1. Samsung 980 PRO NVMe 250 GB 2. Samsung 860 EVO SATA M.2 250 GB Flash memory GigaDevice 25B127DSIG 16 MB Network Local network wired connection Internal devices 1. 1920x1080 15 inch screen 2. Internal keyboard with LED backlight 3. Touchpad 4. Fingerprint scanner 5. Camera 6. Audio subsystem 7. Intel Wi-Fi 6 AX201 wireless card Attached devices 1. SanDisk Ultra USB 3.0 64 GB 2. SanDisk Ultra Flair USB 3.0 16 GB 3. Kingston DataTraveler 3.1Gen1 16 GB 4. SanDisk Ultra microSD HC I 16 GB + SD Adapter 5. DELL KB216 USB Keyboard 6. 4-port USB Type-C Hub Pro 7. HDMI 1920x1080p Display 8. Sony MDR-EX15AP headset Power Supply Chicony 65 W Power Control N/A Remote Testing Environment OpenSSH_8.2p1 OpenSSL 1.1.1f IBS15 #2 Component Description CPU Intel(R) Core(TM) i5-11300H Internal Cooling RAM Slot 1: KVR29S21S6/8 Slot 2: KVR29S21S6/4 SSD Toshiba KXG50NV256G NVMe 256GB Flash memory GigaDevice 25B127DSIG 16 MB Network Local network wired connection Internal devices 1. 1920x1080 14 inch screen 2. Internal keyboard with LED backlight 3. Touchpad 4. Fingerprint scanner 5. Camera 6. Audio subsystem 7. Intel Wi-Fi 6 AX201 wireless card Attached devices 1. SanDisk Ultra USB 3.0 64 GB 2. SanDisk Ultra Flair USB 3.0 16 GB 3. Kingston DataTraveler 3.1Gen1 16 GB 4. SanDisk Ultra microSD HC I 16 GB + SD Adapter 5. DELL KB216 USB Keyboard 6. 4-port USB Type-C Hub Pro 7. HDMI 1920x1080p Display 8. Sony MDR-EX15AP headset Power Supply Chicony 65 W Power Control N/A Remote Testing Environment OpenSSH_8.2p1 OpenSSL 1.1.1f","title":"Hardware Configuration Matrix"},{"location":"variants/tuxedo_ibs15/hardware-matrix/#hardware-configuration-matrix-tuxedo-ibs15","text":"","title":"Hardware configuration matrix - Tuxedo IBS15"},{"location":"variants/tuxedo_ibs15/hardware-matrix/#introduction","text":"This document describes the hardware configurations used for validation of the coreboot port on the Tuxedo IBS15 laptop.","title":"Introduction"},{"location":"variants/tuxedo_ibs15/hardware-matrix/#ibs15-1","text":"Component Description CPU Intel(R) Core(TM) i5-1135G7 Internal Cooling RAM Slot 1: KVR29S21S6/8 Slot 2: KVR29S21S6/4 SSD 1. Samsung 980 PRO NVMe 250 GB 2. Samsung 860 EVO SATA M.2 250 GB Flash memory GigaDevice 25B127DSIG 16 MB Network Local network wired connection Internal devices 1. 1920x1080 15 inch screen 2. Internal keyboard with LED backlight 3. Touchpad 4. Fingerprint scanner 5. Camera 6. Audio subsystem 7. Intel Wi-Fi 6 AX201 wireless card Attached devices 1. SanDisk Ultra USB 3.0 64 GB 2. SanDisk Ultra Flair USB 3.0 16 GB 3. Kingston DataTraveler 3.1Gen1 16 GB 4. SanDisk Ultra microSD HC I 16 GB + SD Adapter 5. DELL KB216 USB Keyboard 6. 4-port USB Type-C Hub Pro 7. HDMI 1920x1080p Display 8. Sony MDR-EX15AP headset Power Supply Chicony 65 W Power Control N/A Remote Testing Environment OpenSSH_8.2p1 OpenSSL 1.1.1f","title":"IBS15 #1"},{"location":"variants/tuxedo_ibs15/hardware-matrix/#ibs15-2","text":"Component Description CPU Intel(R) Core(TM) i5-11300H Internal Cooling RAM Slot 1: KVR29S21S6/8 Slot 2: KVR29S21S6/4 SSD Toshiba KXG50NV256G NVMe 256GB Flash memory GigaDevice 25B127DSIG 16 MB Network Local network wired connection Internal devices 1. 1920x1080 14 inch screen 2. Internal keyboard with LED backlight 3. Touchpad 4. Fingerprint scanner 5. Camera 6. Audio subsystem 7. Intel Wi-Fi 6 AX201 wireless card Attached devices 1. SanDisk Ultra USB 3.0 64 GB 2. SanDisk Ultra Flair USB 3.0 16 GB 3. Kingston DataTraveler 3.1Gen1 16 GB 4. SanDisk Ultra microSD HC I 16 GB + SD Adapter 5. DELL KB216 USB Keyboard 6. 4-port USB Type-C Hub Pro 7. HDMI 1920x1080p Display 8. Sony MDR-EX15AP headset Power Supply Chicony 65 W Power Control N/A Remote Testing Environment OpenSSH_8.2p1 OpenSSL 1.1.1f","title":"IBS15 #2"},{"location":"variants/tuxedo_ibs15/installation/","text":"Dasharo for Tuxedo IBS15 Gen6 - Installation manual Intro Flashing coreboot can be done from Linux using flashrom with the internal programmer. This document describes the process of building, installing and running flashrom on Ubuntu 20.04. Build flashrom Currently, the latest flashrom release lacks support for Tiger Lake-U internal flashing. Because of this, we need to build flashrom from source. Install build dependencies: apt install git build-essential debhelper pkg-config libpci-dev libusb-1.0-0-dev libftdi1-dev meson Obtain source code: git clone https://review.coreboot.org/flashrom.git cd flashrom Build flashrom: make sudo make install Reading flash contents To read from the flash and save them to a file ( dump.rom ), execute the following command: flashrom -p internal -r dump.rom Installing Dasharo Initial Installation During initial installation of Dasharo, you should deploy supported Intel ME version (and configuration) on the device. Publicly released binaries do not contain ME binary. If you need an Intel ME update for your device, contact us via already established commercial support channel. When flashing binaries with ME binary included, flashing of the whole chip is required. Follow the steps below: Power off the laptop While holding the Fn+M keys, power on the laptop - This unlocks the ME and allows for it to be overwritten. The fans will spin at 100% speed at this point Execute the following command, replacing [path] with the path to the firmware image you want to flash, e.g. tuxedo_ibs15_full_v1.0.0.rom flashrom -p internal -w [ path ] Reboot the laptop The laptop will boot into Dasharo. After Dasharo has booted, it is safe to shut down the laptop to silence the fans Note: if you shut down the laptop instead of rebooting, it may be necessary to hold Fn+M for it to boot the first time after flashing. Updating Dasharo If Dasharo is currently installed, only the RW_SECTION_A partition of the flash needs to be updated. Flash it using the following command: flashrom -p internal -w [ path ] --fmap -i RW_SECTION_A This command also preserves UEFI settings and the boot order.","title":"Installation manual"},{"location":"variants/tuxedo_ibs15/installation/#dasharo-for-tuxedo-ibs15-gen6-installation-manual","text":"","title":"Dasharo for Tuxedo IBS15 Gen6 - Installation manual"},{"location":"variants/tuxedo_ibs15/installation/#intro","text":"Flashing coreboot can be done from Linux using flashrom with the internal programmer. This document describes the process of building, installing and running flashrom on Ubuntu 20.04.","title":"Intro"},{"location":"variants/tuxedo_ibs15/installation/#build-flashrom","text":"Currently, the latest flashrom release lacks support for Tiger Lake-U internal flashing. Because of this, we need to build flashrom from source. Install build dependencies: apt install git build-essential debhelper pkg-config libpci-dev libusb-1.0-0-dev libftdi1-dev meson Obtain source code: git clone https://review.coreboot.org/flashrom.git cd flashrom Build flashrom: make sudo make install","title":"Build flashrom"},{"location":"variants/tuxedo_ibs15/installation/#reading-flash-contents","text":"To read from the flash and save them to a file ( dump.rom ), execute the following command: flashrom -p internal -r dump.rom","title":"Reading flash contents"},{"location":"variants/tuxedo_ibs15/installation/#installing-dasharo","text":"","title":"Installing Dasharo"},{"location":"variants/tuxedo_ibs15/post_install/","text":"Post-installation setup This document contains extra steps to perform after installing Dasharo in order to enable full functionality. Touchpad hotkey enablement (Linux) The touchpad hotkey needs extra setup to function correctly under Linux. To enable the touchpad hotkey to work under Linux, follow the steps below: Create a file /etc/udev/hwdb.d/60-keyboard.hwdb with the following contents: evdev:atkbd:dmi:bvn*:bvr*:svnNotebook:pnNS50MU:* KEYBOARD_KEY_f7 = 191 KEYBOARD_KEY_f8 = 191 Execute the following commands: sudo systemd-hwdb update sudo udevadm trigger After executing these steps, it should be possible to enable and disable the touchpad using the touchpad hotkey (Fn+F1) on the keyboard when using GNOME.","title":"Post-installation steps"},{"location":"variants/tuxedo_ibs15/post_install/#post-installation-setup","text":"This document contains extra steps to perform after installing Dasharo in order to enable full functionality.","title":"Post-installation setup"},{"location":"variants/tuxedo_ibs15/post_install/#touchpad-hotkey-enablement-linux","text":"The touchpad hotkey needs extra setup to function correctly under Linux. To enable the touchpad hotkey to work under Linux, follow the steps below: Create a file /etc/udev/hwdb.d/60-keyboard.hwdb with the following contents: evdev:atkbd:dmi:bvn*:bvr*:svnNotebook:pnNS50MU:* KEYBOARD_KEY_f7 = 191 KEYBOARD_KEY_f8 = 191 Execute the following commands: sudo systemd-hwdb update sudo udevadm trigger After executing these steps, it should be possible to enable and disable the touchpad using the touchpad hotkey (Fn+F1) on the keyboard when using GNOME.","title":"Touchpad hotkey enablement (Linux)"},{"location":"variants/tuxedo_ibs15/releases/","text":"Tuxedo IBS15 Dasharo Release Notes Following Release Notes describe status of Open Source Firmware development for Tuxedo IBS15 For details about our release process please read Dasharo Standard Release Process . Subscribe to Tuxedo IBS15 Dasharo Release Newsletter Test results for this platform can be found here . v1.0.0 - 2022-03-15 Added Support for Tuxedo InfinityBook S 15 Gen6 Support for EC firmware 1.07.02 Support for Intel ME version 15.0.30.1776 UEFI Boot Support Configurable boot order Configurable boot options UEFI Secure Boot support Tuxedo boot logo Known issues The touchpad ON/OFF switch Fn key is not functional Binaries tuxedo_ibs15_v1.0.0.rom sha256 sha256.sig SBOM (Software Bill of Materials) coreboot based on 4.16 revision cf13d6c7 tianocore based on 9522071f7497a1a0b1077d2b0d5fcc97a126cfd0 revision 7f90b9cd","title":"Releases"},{"location":"variants/tuxedo_ibs15/releases/#tuxedo-ibs15-dasharo-release-notes","text":"Following Release Notes describe status of Open Source Firmware development for Tuxedo IBS15 For details about our release process please read Dasharo Standard Release Process . Subscribe to Tuxedo IBS15 Dasharo Release Newsletter Test results for this platform can be found here .","title":"Tuxedo IBS15 Dasharo Release Notes"},{"location":"variants/tuxedo_ibs15/releases/#v100-2022-03-15","text":"","title":"v1.0.0 - 2022-03-15"},{"location":"variants/tuxedo_ibs15/test-matrix/","text":"Test matrix - Tuxedo - Tuxedo IBS15 About The test matrix is used to determine the scope of tests which the DUT is subjected from before the release of the new binary. Module: Dasharo compatibility No. Supported test suite Test suite ID Supported test cases 1. Memory HCL HCL All 2. UEFI compatible interface EFI All 3. Display ports and LCD support DSP DSP001.001, DSP001.002, DSP001.003, DSP002.001, DSP002.002, DSP002.003 4. Embedded Controller and Super I/O initialization ECR Without ECR021.xxx - ECR024.xxx 5. NVMe support NVM All 6. Custom logo CLG All 7. Custom boot menu key CBK All 8. USB HID and MSC Support USB All 9. Debian Stable and Ubuntu LTS support LBT All 10. UEFI Shell USH All 11. Windows booting WBT WBT001.001 12. Audio subsystem AUD All 13. USB-C/Thunderbolt UTC All 14. Network boot PXE All 15. M.2 WiFi/Bluetooth WLE All 16. SD card support SDC All 17. USB Camera verification CAM All 19. Custom fan curve FAN FAN001.001 20. SMBIOS DMI DMI002.001, DMI003.001, DMI005.001, DMI006.001, DMI007.001, DMI008.001 Module: Dasharo security No. Supported test suite Test suite ID Supported test cases 1. TPM Support TPM All 2. Verified Boot support VBO VBO001.002, VBO002.002, 3. Measured Boot support MBO All 4. Secure Boot support SBO All","title":"Test matrix - Tuxedo - Tuxedo IBS15"},{"location":"variants/tuxedo_ibs15/test-matrix/#test-matrix-tuxedo-tuxedo-ibs15","text":"","title":"Test matrix - Tuxedo - Tuxedo IBS15"},{"location":"variants/tuxedo_ibs15/test-matrix/#about","text":"The test matrix is used to determine the scope of tests which the DUT is subjected from before the release of the new binary.","title":"About"},{"location":"variants/tuxedo_ibs15/test-matrix/#module-dasharo-compatibility","text":"No. Supported test suite Test suite ID Supported test cases 1. Memory HCL HCL All 2. UEFI compatible interface EFI All 3. Display ports and LCD support DSP DSP001.001, DSP001.002, DSP001.003, DSP002.001, DSP002.002, DSP002.003 4. Embedded Controller and Super I/O initialization ECR Without ECR021.xxx - ECR024.xxx 5. NVMe support NVM All 6. Custom logo CLG All 7. Custom boot menu key CBK All 8. USB HID and MSC Support USB All 9. Debian Stable and Ubuntu LTS support LBT All 10. UEFI Shell USH All 11. Windows booting WBT WBT001.001 12. Audio subsystem AUD All 13. USB-C/Thunderbolt UTC All 14. Network boot PXE All 15. M.2 WiFi/Bluetooth WLE All 16. SD card support SDC All 17. USB Camera verification CAM All 19. Custom fan curve FAN FAN001.001 20. SMBIOS DMI DMI002.001, DMI003.001, DMI005.001, DMI006.001, DMI007.001, DMI008.001","title":"Module: Dasharo compatibility"},{"location":"variants/tuxedo_ibs15/test-matrix/#module-dasharo-security","text":"No. Supported test suite Test suite ID Supported test cases 1. TPM Support TPM All 2. Verified Boot support VBO VBO001.002, VBO002.002, 3. Measured Boot support MBO All 4. Secure Boot support SBO All","title":"Module: Dasharo security"}]}